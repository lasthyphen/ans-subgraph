
Š€€€er.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n","export const TEMPLATE_LOADING = Symbol('TEMPLATE_LOADING')\nexport const TEMPLATE_AVAILABLE = Symbol('TEMPLATE_AVAILABLE')\nexport const TEMPLATE_UNAVAILABLE = Symbol('TEMPLATE_UNAVAILABLE')\n","const templateStateKey = 'create-org'\n\nexport function loadTemplateState() {\n  const value = localStorage.getItem(templateStateKey)\n  try {\n    const data = JSON.parse(value)\n    return {\n      networkType: data.networkType,\n      templateScreenIndex: data.templateScreenIndex,\n      templateData: data.templateData || {},\n      templateId: data.templateId,\n    }\n  } catch (err) {\n    return {}\n  }\n}\n\nexport function saveTemplateState(state) {\n  localStorage.setItem(templateStateKey, JSON.stringify(state))\n}\n\nexport function prepareTransactionCreatorFromAbi(web3, abi, toAddress) {\n  const contract = new web3.eth.Contract(abi)\n\n  return function(methodName, paramsList) {\n    const method = contract.methods[methodName]\n    if (!method) {\n      throw new Error(\n        `Could not create transaction: no method found on ABI for ${methodName}`\n      )\n    }\n\n    return {\n      data: method(...paramsList).encodeABI(),\n      to: toAddress,\n    }\n  }\n}\n","import React, { useState, useEffect } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, springs, useViewport } from '@aragon/ui'\nimport { Transition, animated } from 'react-spring'\n\nconst AnimatedDiv = animated.div\n\nfunction ConfigureTemplateScreens({\n  TemplateScreen,\n  onNext,\n  onPrev,\n  screenIndex,\n  screens,\n  templateData,\n}) {\n  const [prevIndex, setPrevIndex] = useState(-1)\n  const { below } = useViewport()\n\n  useEffect(() => {\n    setPrevIndex(screenIndex)\n  }, [screenIndex])\n\n  const direction = screenIndex > prevIndex ? 1 : -1\n\n  return (\n    <Transition\n      native\n      reset\n      unique\n      items={{ screenIndex, Screen: TemplateScreen }}\n      keys={({ screenIndex }) => screenIndex}\n      from={{\n        opacity: 0,\n        position: 'absolute',\n        transform: `translate3d(${10 * direction}%, 0, 0)`,\n      }}\n      enter={{\n        opacity: 1,\n        position: 'static',\n        transform: `translate3d(0%, 0, 0)`,\n      }}\n      leave={{\n        opacity: 0,\n        position: 'absolute',\n        transform: `translate3d(${-10 * direction}%, 0, 0)`,\n      }}\n      config={springs.smooth}\n    >\n      {({ screenIndex, Screen }) =>\n        /* eslint-disable react/prop-types */\n        ({ opacity, transform, position }) => (\n          <AnimatedDiv\n            style={{ opacity, transform, position }}\n            css={`\n              top: 0;\n              left: 0;\n              right: 0;\n            `}\n          >\n            <div\n              css={`\n                margin: 0 auto;\n                max-width: ${82 * GU}px;\n                padding: 0 ${3 * GU}px ${(below('medium') ? 9 : 6) * GU}px\n                  ${3 * GU}px;\n              `}\n            >\n              <Screen\n                data={templateData}\n                fields={\n                  {\n                    /* TODO: pass the fields from the template contract */\n                  }\n                }\n                next={onNext}\n                back={onPrev}\n                screens={screens}\n                screenIndex={screenIndex}\n              />\n            </div>\n          </AnimatedDiv>\n        )\n      /* eslint-enable react/prop-types */\n      }\n    </Transition>\n  )\n}\n\nConfigureTemplateScreens.propTypes = {\n  TemplateScreen: PropTypes.func.isRequired,\n  onNext: PropTypes.func.isRequired,\n  onPrev: PropTypes.func.isRequired,\n  screenIndex: PropTypes.number.isRequired,\n  screens: PropTypes.array.isRequired,\n  templateData: PropTypes.object.isRequired,\n}\n\nexport default ConfigureTemplateScreens\n","import React, { useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, IconCheck, useTheme } from '@aragon/ui'\n\nfunction ConfigureStepsItem({ stepNumber, step, label, currentStep }) {\n  const theme = useTheme()\n\n  const stepStyles = useMemo(() => {\n    if (step === currentStep) {\n      return `\n        padding-top: 2px;\n        background: ${theme.selected};\n        color: ${theme.selectedContent};\n      `\n    }\n    if (step < currentStep) {\n      return `\n        background: ${theme.positive};\n        color: ${theme.positiveContent};\n      `\n    }\n    return `\n      padding-top: 2px;\n      background: #ECEFF4;\n      color: #9CA7B8;\n    `\n  }, [step, currentStep, theme])\n\n  return (\n    <div\n      css={`\n        display: flex;\n        align-items: center;\n        height: ${5 * GU}px;\n        & + & {\n          margin-top: ${3 * GU}px;\n        }\n      `}\n    >\n      <div\n        css={`\n          width: ${5 * GU}px;\n          height: ${5 * GU}px;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          border-radius: 50%;\n          font-size: 18px;\n          font-weight: 600;\n          ${stepStyles};\n          flex-shrink: 0;\n          flex-grow: 0;\n        `}\n      >\n        {step < currentStep ? <IconCheck /> : stepNumber}\n      </div>\n      <div\n        css={`\n          margin-left: ${3 * GU}px;\n          font-size: 18px;\n          font-weight: ${step === currentStep ? '600' : '400'};\n          overflow: hidden;\n          text-overflow: ellipsis;\n        `}\n      >\n        {label}\n      </div>\n    </div>\n  )\n}\n\nConfigureStepsItem.propTypes = {\n  currentStep: PropTypes.number.isRequired,\n  label: PropTypes.string.isRequired,\n  step: PropTypes.number.isRequired,\n  stepNumber: PropTypes.number.isRequired,\n}\n\nexport default ConfigureStepsItem\n","// Copied from aragonUI until these changes + the changes from this PR get\n// merged together: https://github.com/aragon/aragon-ui/pull/458\n\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\nimport { Spring, animated } from 'react-spring'\nimport { useTheme } from '@aragon/ui'\n\nconst STROKE_WIDTH = 4\n\nconst VALUE_DEFAULT = 1\nconst SIZE_DEFAULT = 80\nconst LABEL_DEFAULT = value => `${Math.round(value * 100)}`\n\nconst { span: AnimatedSpan, circle: AnimatedCircle } = animated\n\nfunction CircleGraph({ value, label, size, strokeWidth }) {\n  const theme = useTheme()\n  const length = Math.PI * 2 * (size - strokeWidth)\n  const radius = (size - strokeWidth) / 2\n  return (\n    <Spring to={{ progressValue: value }} native>\n      {({ progressValue }) => (\n        <Main\n          style={{\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'center',\n            width: `${size}px`,\n            height: `${size}px`,\n          }}\n        >\n          <CircleSvg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>\n            <circle\n              cx={size / 2}\n              cy={size / 2}\n              r={radius}\n              style={{ strokeWidth }}\n              fill=\"none\"\n              stroke={theme.border}\n            />\n            <AnimatedCircle\n              cx={size / 2}\n              cy={size / 2}\n              r={radius}\n              fill=\"none\"\n              stroke={theme.accent}\n              strokeLinecap=\"round\"\n              strokeDasharray={length}\n              strokeWidth={strokeWidth}\n              style={{\n                strokeDashoffset: progressValue.interpolate(\n                  t => length - (length * t) / 2\n                ),\n              }}\n              css={`\n                transform: rotate(270deg);\n                transform-origin: 50% 50%;\n              `}\n            />\n          </CircleSvg>\n          <div\n            css={`\n              display: flex;\n              align-items: flex-start;\n            `}\n          >\n            <AnimatedSpan\n              css={`\n                font-size: 52px;\n                font-weight: 600;\n                color: ${theme.surfaceContent};\n              `}\n            >\n              {progressValue.interpolate(t =>\n                label(Math.min(1, Math.max(0, t)))\n              )}\n            </AnimatedSpan>\n            <span\n              css={`\n                font-size: 24px;\n                font-weight: 400;\n                margin-top: 12px;\n              `}\n            >\n              %\n            </span>\n          </div>\n        </Main>\n      )}\n    </Spring>\n  )\n}\n\nCircleGraph.propTypes = {\n  value: PropTypes.number,\n  size: PropTypes.number,\n  label: PropTypes.func,\n  strokeWidth: PropTypes.number,\n}\n\nCircleGraph.defaultProps = {\n  value: VALUE_DEFAULT,\n  size: SIZE_DEFAULT,\n  label: LABEL_DEFAULT,\n  strokeWidth: STROKE_WIDTH,\n}\n\nconst Main = styled.div`\n  position: relative;\n`\n\nconst CircleSvg = styled.svg`\n  position: absolute;\n  top: 0;\n  left: 0;\n`\n\nexport default CircleGraph\n","import React, { useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, useTheme } from '@aragon/ui'\nimport ConfigureStepsItem from './ConfigureStepsItem'\nimport CircleGraph from '../CircleGraph'\n\nfunction SetupStepsPanel({ step, steps }) {\n  const theme = useTheme()\n\n  // Mark identical siblings to only show the last step\n  const [groupedSteps, displayedSteps] = useMemo(() => {\n    // these get updated by the .map() to avoid another iteration\n    let displayCount = 0\n\n    const groupedSteps = steps.map((step, index) => {\n      const hiddenCount = index - displayCount\n\n      if (step !== steps[index + 1]) {\n        displayCount++\n        return [index, index - hiddenCount, true]\n      }\n\n      let statusIndex = index\n      while (step === steps[statusIndex + 1] && statusIndex < steps.length) {\n        statusIndex++\n      }\n\n      return [\n        // The index used for the status in the panel (last of the group)\n        statusIndex,\n        // The index used for the display in the panel (first of the group)\n        index - hiddenCount,\n        // Do not display the step\n        false,\n      ]\n    })\n\n    return [groupedSteps, displayCount]\n  }, [steps])\n\n  return (\n    <aside\n      css={`\n        width: 100%;\n        min-height: 100%;\n        padding-top: ${10 * GU}px;\n        background: ${theme.surface};\n        border-right: 1px solid ${theme.border};\n      `}\n    >\n      <div\n        css={`\n          position: relative;\n          display: flex;\n          width: 100%;\n          justify-content: center;\n          height: ${25 * GU}px;\n        `}\n      >\n        <CircleGraph\n          value={groupedSteps[step][1] / (displayedSteps - 1)}\n          size={25 * GU}\n        />\n        <div\n          css={`\n            position: absolute;\n            top: 130px;\n            font-size: 20px;\n            color: #8e97b5;\n            opacity: 0.7;\n          `}\n        >\n          {`${groupedSteps[step][1] + 1}/${displayedSteps}`}\n        </div>\n      </div>\n      <div\n        css={`\n          padding: ${8 * GU}px ${3 * GU}px ${3 * GU}px;\n        `}\n      >\n        {groupedSteps.map(\n          ([statusIndex, displayIndex, show], index) =>\n            show && (\n              <ConfigureStepsItem\n                key={index}\n                currentStep={groupedSteps[step][0]}\n                label={steps[statusIndex]}\n                step={statusIndex}\n                stepNumber={displayIndex + 1}\n              />\n            )\n        )}\n      </div>\n    </aside>\n  )\n}\n\nSetupStepsPanel.propTypes = {\n  step: PropTypes.number.isRequired,\n  steps: PropTypes.arrayOf(PropTypes.string).isRequired,\n}\n\nexport default SetupStepsPanel\n","export const STATUS_SELECT_TEMPLATE = Symbol('STATUS_TEMPLATE')\nexport const STATUS_TEMPLATE_SCREENS = Symbol('STATUS_TEMPLATE_SCREENS')\nexport const STATUS_DEPLOYMENT = Symbol('STATUS_DEPLOYMENT')\n","import React from 'react'\nimport { Fn, Vector2, EventOptions, Coordinates, FullGestureState, DistanceAngle, TransformedEvent } from './types'\n\n// blank function\nexport const noop = () => {}\n\n// returns a function that chains all functions given as parameters\nexport const chainFns = (...fns: Fn[]): Fn => (...args: any[]) => fns.forEach(fn => fn(...args))\n\n// vector add\nexport const addV = <T extends number[]>(v1: T, v2: T): T => <T>v1.map((v, i) => v + v2[i])\n\n// vector substract\nexport const subV = <T extends number[]>(v1: T, v2: T): T => <T>v1.map((v, i) => v - v2[i])\n\nconst setListeners = (add: boolean) => (el: EventTarget, listeners: [string, Fn][], options: EventOptions): void => {\n  const action = add ? 'addEventListener' : 'removeEventListener'\n  listeners.forEach(([type, fn]) => el[action](type, fn, options))\n}\n\nexport const addListeners = setListeners(true)\nexport const removeListeners = setListeners(false)\n\ninterface ModifierKeys {\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\n/**\n * Gets modifier keys from event\n * @param event\n * @returns modifier keys\n */\nexport function getModifierKeys(event: TransformedEvent): ModifierKeys {\n  const { shiftKey, altKey, metaKey, ctrlKey } = event\n  return { shiftKey, altKey, metaKey, ctrlKey }\n}\ntype ScrollEventData = Pick<FullGestureState<Coordinates>, 'values'> & ModifierKeys\n\n/**\n * Gets scroll event data\n * @param event\n * @returns scroll event data\n */\nexport function getScrollEventData(event: TransformedEvent): ScrollEventData {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = <Element & Window>event.currentTarget\n  return { values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0], ...getModifierKeys(event) }\n}\n\ntype WheelEventData = Pick<FullGestureState<Coordinates>, 'values'> & ModifierKeys\n\n/**\n * Gets wheel event data\n * @param event\n * @returns wheel event data\n */\nexport function getWheelEventData(event: TransformedEvent<React.WheelEvent>): WheelEventData {\n  const { deltaX, deltaY } = event\n  //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n  return { values: [deltaX, deltaY], ...getModifierKeys(event) }\n}\ntype PointerEventData = Pick<FullGestureState<Coordinates>, 'values' | 'touches' | 'down' | 'buttons'> & ModifierKeys\n\n/**\n * Gets pointer event data\n * @param event\n * @returns pointer event data\n */\nexport function getPointerEventData(event: React.MouseEvent | React.TouchEvent | React.PointerEvent): PointerEventData {\n  const { touches, buttons, changedTouches } = event as any\n  const touchEvents = touches && touches.length > 0 ? touches : changedTouches && changedTouches.length > 0 ? changedTouches : null\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : event\n  const down = (touchEvents && touchEvents.length > 0) || buttons > 0\n  return {\n    values: [clientX, clientY],\n    touches: (touchEvents && touchEvents.length) || 0,\n    down,\n    buttons,\n    ...getModifierKeys(event),\n  }\n}\n\ntype TwoTouchesEventData = Pick<FullGestureState<DistanceAngle>, 'values' | 'touches' | 'down' | 'origin'> & ModifierKeys\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventData(event: React.TouchEvent): TwoTouchesEventData {\n  const { touches } = event\n  const dx = touches[1].clientX - touches[0].clientX\n  const dy = touches[1].clientY - touches[0].clientY\n\n  const da: Vector2 = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI]\n  const origin: Vector2 = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2]\n\n  return { values: da, origin, touches: 2, down: touches.length > 0, ...getModifierKeys(event) }\n}\n\n/**\n * Calculates velocity\n * @param diff the difference between current and previous vectors\n * @param delta_t the time delta\n * @param len the length of the diff vector\n * @returns velocity\n */\nexport function calculateVelocity(diff: number[], delta_t: number, len: number): number {\n  len = len || Math.hypot(...diff)\n  return delta_t ? len / delta_t : 0\n}\n\n/**\n * Calculates velocities vector\n * @template T the expected vector type\n * @param diff the previous value\n * @param delta_t the time delta\n * @returns velocities vector\n */\nexport function calculateVelocities<T extends number[]>(diff: T, delta_t: number): T {\n  return delta_t ? <T>diff.map(v => v / delta_t) : <T>Array(diff.length).fill(0)\n}\n\n/**\n * Calculates distance\n * @param delta the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(delta: number[]): number {\n  return Math.hypot(...delta)\n}\n\n/**\n * Calculates direction\n * @template T the expected vector type\n * @param diff\n * @param len\n * @returns direction\n */\nexport function calculateDirection<T extends number[]>(diff: T, len: number): T {\n  len = len || Math.hypot(...diff) || 1\n  return <T>diff.map(v => v / len)\n}\n\ninterface Kinematics<T extends number[]> {\n  velocities: T\n  velocity: number\n  distance: number\n  direction: T\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param delta the difference between current and initial vectors\n * @param diff the difference between current and previous vectors\n * @param delta_t the time delta between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(delta: T, diff: T, delta_t: number): Kinematics<T> {\n  const len = Math.hypot(...diff)\n\n  return {\n    velocities: calculateVelocities(diff, delta_t),\n    velocity: calculateVelocity(diff, delta_t, len),\n    distance: calculateDistance(delta),\n    direction: calculateDirection(diff, len),\n  }\n}\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvent(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: Unreachable code error\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n","import { noop } from './utils'\nimport { GestureConfig, HandlerKey, CommonGestureState, Coordinates, DistanceAngle, StateObject, StateKey, GestureKey } from './types'\n\ntype MappedKeys = { [K in GestureKey]: { stateKey: StateKey; handlerKey: HandlerKey } }\n\n/**\n * Some gestures might use the state key from another gesture (i.e. hover)\n * so mappedKeys is a commodity object to get the state key and handler key\n * for every gesture\n */\nexport const mappedKeys: MappedKeys = {\n  drag: { stateKey: 'drag', handlerKey: 'onDrag' },\n  pinch: { stateKey: 'pinch', handlerKey: 'onPinch' },\n  move: { stateKey: 'move', handlerKey: 'onMove' },\n  scroll: { stateKey: 'scroll', handlerKey: 'onScroll' },\n  wheel: { stateKey: 'wheel', handlerKey: 'onWheel' },\n  hover: { stateKey: 'move', handlerKey: 'onHover' },\n}\n\n// default config (will extend user config)\nexport const defaultConfig: GestureConfig = {\n  domTarget: undefined,\n  event: { passive: true, capture: false },\n  pointerEvents: false,\n  window: typeof window !== 'undefined' ? window : undefined,\n  transform: { x: (x: number): number => x, y: (y: number): number => y },\n  enabled: true,\n  drag: true,\n  pinch: true,\n  scroll: true,\n  wheel: true,\n  hover: true,\n  move: true,\n}\n\n// common initial state for all gestures\nexport const initialCommon: CommonGestureState = {\n  event: undefined,\n  currentTarget: undefined,\n  pointerId: undefined,\n  values: [0, 0],\n  velocities: [0, 0],\n  delta: [0, 0],\n  initial: [0, 0],\n  previous: [0, 0],\n  transform: undefined,\n  local: [0, 0],\n  lastLocal: [0, 0],\n  first: false,\n  last: false,\n  active: false,\n  time: undefined,\n  cancel: noop,\n  canceled: false,\n  memo: undefined,\n  args: undefined,\n}\n\n// initial state for coordinates-based gestures\nconst initialCoordinates: Coordinates = { xy: [0, 0], vxvy: [0, 0], velocity: 0, distance: 0, direction: [0, 0] } // xy coordinates\n\n// initial state for distance and angle-based gestures (pinch)\nconst initialDistanceAngle: DistanceAngle = { da: [0, 0], vdva: [0, 0], origin: [0, 0], turns: 0 } // distance and angle\n\n// initial state object (used by the gesture controller)\nexport const initialState: StateObject = {\n  shared: {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n  },\n  move: { ...initialCommon, ...initialCoordinates },\n  drag: { ...initialCommon, ...initialCoordinates },\n  scroll: { ...initialCommon, ...initialCoordinates },\n  wheel: { ...initialCommon, ...initialCoordinates },\n  pinch: { ...initialCommon, ...initialDistanceAngle },\n}\n\n// generic end state for all gestures\nexport const genericEndState = { first: false, last: true, active: false }\n","import { initialState, mappedKeys } from '../defaults'\nimport GestureController from '../controllers/GestureController'\nimport {\n  Coordinates,\n  DistanceAngle,\n  StateKey,\n  GestureState,\n  GestureKey,\n  SharedGestureState,\n  Fn,\n  Vector2,\n  TransformType,\n  ReactEventHandlerKey,\n  GestureFlag,\n  TransformedEvent,\n} from '../types'\n\n/**\n * Recognizer abstract class\n * @template GestureType whether the Recognizer should deal with coordinates or distance / angle\n */\nexport default abstract class Recognizer<GestureType extends Coordinates | DistanceAngle> {\n  protected stateKey: StateKey\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param gestureKey drag, move, hover, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(\n    protected readonly gestureKey: GestureKey,\n    protected readonly controller: GestureController,\n    protected readonly args: any[] = []\n  ) {\n    // mapping this.stateKey to the state key the gesture handles\n    // (ie hover actually deals with the move gesture state)\n    this.stateKey = mappedKeys[gestureKey].stateKey\n  }\n\n  protected isEnabled = (): boolean => {\n    return this.controller.config.enabled && this.controller.config[this.gestureKey]\n  }\n\n  // convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  // get the controller state for a given gesture\n  protected getState = (): GestureState<GestureType> => this.controller.state[this.stateKey] as GestureState<GestureType>\n  // get the controller shared state\n  protected getSharedState = () => this.controller.state.shared\n  // does the controller config has pointer events enabled\n  protected pointerEventsEnabled = () => this.controller.config.pointerEvents\n  // gets the transform config of the controller\n  protected getTransformConfig = () => this.controller.config.transform\n\n  // convenience method to add window listeners for a given gesture\n  protected addWindowListeners = (listeners: [string, Fn][]) => {\n    this.controller.addWindowListeners(this.stateKey, listeners)\n  }\n\n  // convenience method to remove window listeners for a given gesture\n  protected removeWindowListeners = () => {\n    this.controller.removeWindowListeners(this.stateKey)\n  }\n\n  // should return the bindings for a given gesture\n  public abstract getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][]\n\n  /**\n   * convenience method to update the controller state for a given gesture\n   * @param sharedState shared partial state object\n   * @param gestureState partial state object for the gesture handled by the recognizer\n   * @param [gestureFlag] if set, will also fire the gesture handler set by the user\n   */\n  protected updateState = (\n    sharedState: Partial<SharedGestureState> | null,\n    gestureState: Partial<GestureState<GestureType>>,\n    gestureFlag?: GestureFlag\n  ): void => {\n    this.controller.updateState(sharedState, gestureState, this.gestureKey, gestureFlag)\n  }\n\n  /**\n   * returns the start state for a given gesture\n   * @param values the values of the start state\n   * @param event the event that triggers the gesture start\n   */\n  protected getStartState = (values: Vector2, event: TransformedEvent): GestureState<GestureType> => {\n    const state = this.getState()\n    const initial = initialState[this.stateKey]\n    const transform: TransformType = state.transform || event.transform || this.getTransformConfig()\n    const lastLocal = state.local || initial.local\n\n    return <GestureState<GestureType>>{\n      ...(initial as object),\n      event,\n      values,\n      initial: values,\n      previous: values,\n      local: lastLocal,\n      lastLocal,\n      first: true,\n      active: true,\n      transform,\n      time: event.timeStamp,\n      args: this.args,\n    }\n  }\n}\n","import Recognizer from './Recognizer'\nimport { addV, subV, calculateAllKinematics } from '../utils'\nimport { TransformedEvent, Vector2, TransformType, GestureState, Coordinates } from '../types'\n\n/**\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer extends Recognizer<Coordinates> {\n  /**\n   * Utility function to get kinematics of the gesture\n   * @values values we want to calculate the kinematics from\n   * @event\n   * @returns set of values including delta, velocity, velocities, distance and direction\n   */\n  protected getKinematics = (values: Vector2, event: TransformedEvent): Partial<GestureState<Coordinates>> => {\n    // we get the gesture specific state\n    const state = this.getState()\n    const { values: xy, initial, lastLocal, time = 0 } = state\n    const transform: TransformType = state.transform || event.transform || this.getTransformConfig()\n\n    // delta is the difference between the current and initial value vectors\n    const delta = subV(values, initial).map((v, i) => Object.values(transform)[i](v)) as Vector2\n    // diff is the difference between the current and previous value vectors\n    const diff = subV(values, xy).map((v, i) => Object.values(transform)[i](v)) as Vector2\n\n    const delta_t = event.timeStamp - time\n    const { velocity, velocities, distance, direction } = calculateAllKinematics(delta, diff, delta_t)\n\n    return {\n      event,\n      values,\n      delta,\n      velocity,\n      velocities,\n      distance,\n      direction,\n      local: addV(lastLocal, delta),\n      previous: xy,\n      transform,\n      time: event.timeStamp,\n    }\n  }\n}\n","import { PointerEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { noop, getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class DragRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('drag', controller, args)\n  }\n\n  onStart = (event: TransformedEvent): void => {\n    if (!this.isEnabled()) return\n\n    const { values, ...rest } = getPointerEventData(event)\n    // making sure we're not dragging the element when more than one finger press the screen\n    if (rest.touches > 1) return\n\n    const { currentTarget, pointerId } = event as PointerEvent\n    if (this.pointerEventsEnabled()) {\n      // if pointers events\n      currentTarget && (currentTarget as any).setPointerCapture(pointerId)\n    } else {\n      this.removeWindowListeners()\n      const dragListeners: [string, Fn][] = [\n        ['mousemove', this.onChange],\n        ['mouseup', this.onEnd],\n        ['touchmove', this.onChange],\n        ['touchend', this.onEnd],\n        ['touchcancel', this.onEnd],\n      ]\n      this.addWindowListeners(dragListeners)\n    }\n\n    const startState = this.getStartState(values, event)\n\n    this.updateState(\n      { ...rest, dragging: true, down: true },\n      { ...startState, currentTarget, pointerId, cancel: () => this.onCancel(event) },\n      GestureFlag.OnStart\n    )\n  }\n\n  onChange = (event: TransformedEvent): void => {\n    const { canceled, active } = this.getState()\n    if (canceled || !active) return\n\n    const { values, ...rest } = getPointerEventData(event)\n\n    if (rest.buttons === 0 && rest.touches === 0) {\n      this.onEnd(event)\n      return\n    }\n\n    const kinematics = this.getKinematics(values, event)\n    const cancel = () => this.onCancel(event)\n\n    this.updateState(rest, { ...kinematics, first: false, cancel }, GestureFlag.OnChange)\n  }\n\n  onEnd = (event: TransformedEvent): void => {\n    const state = this.getState()\n    if (!state.active) return\n\n    const { currentTarget, pointerId } = state\n    if (currentTarget && this.pointerEventsEnabled()) (currentTarget as any).releasePointerCapture(pointerId)\n    else this.removeWindowListeners()\n\n    this.updateState({ dragging: false, down: false, buttons: 0, touches: 0 }, { ...genericEndState, event }, GestureFlag.OnEnd)\n  }\n\n  onCancel = (event: TransformedEvent): void => {\n    this.updateState(null, { canceled: true, cancel: noop })\n    requestAnimationFrame(() => this.onEnd(event))\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerDown', this.onStart], ['onPointerMove', this.onChange], [['onPointerUp', 'onPointerCancel'], this.onEnd]]\n    }\n    return [[['onMouseDown', 'onTouchStart'], this.onStart]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getScrollEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class ScrollRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('scroll', controller, args)\n  }\n\n  onChange = (event: TransformedEvent): void => {\n    if (!this.isEnabled()) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const { values, ...rest } = getScrollEventData(event)\n\n    if (!this.getState().active) {\n      const startState = this.getStartState(values, event)\n      this.updateState({ scrolling: true, ...rest }, startState, GestureFlag.OnStart)\n    } else {\n      const kinematics = this.getKinematics(values, event)\n      this.updateState(rest, { ...kinematics, first: false }, GestureFlag.OnChange)\n    }\n  }\n\n  onEnd = (): void => {\n    if (!this.getState().active) return\n    this.updateState({ scrolling: false }, { ...genericEndState, velocity: 0, velocities: [0, 0] }, GestureFlag.OnEnd)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onScroll', this.onChange]]\n  }\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { addV, getWheelEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class WheelRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('wheel', controller, args)\n  }\n\n  onChange = (event: TransformedEvent<WheelEvent>): void => {\n    if (!this.isEnabled()) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const { values: eventValues, ...rest } = getWheelEventData(event)\n    const values = addV(eventValues, this.getState().values)\n\n    if (!this.getState().active) {\n      const startState = this.getStartState(values, event)\n      this.updateState({ wheeling: true, ...rest }, startState, GestureFlag.OnStart)\n    } else {\n      const kinematics = this.getKinematics(values, event)\n      this.updateState(rest, { ...kinematics, first: false }, GestureFlag.OnChange)\n    }\n  }\n\n  onEnd = (): void => {\n    if (!this.getState().active) return\n    this.updateState({ wheeling: false }, { ...genericEndState, velocity: 0, velocities: [0, 0] }, GestureFlag.OnEnd)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onWheel', this.onChange]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class MoveRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('move', controller, args)\n  }\n\n  onChange = (event: TransformedEvent): void => {\n    if (!this.isEnabled()) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const { values, ...rest } = getPointerEventData(event)\n\n    if (!this.getState().active) {\n      const startState = this.getStartState(values, event)\n      this.updateState({ moving: true, ...rest }, startState, GestureFlag.OnStart)\n    } else {\n      const kinematics = this.getKinematics(values, event)\n      this.updateState(rest, { ...kinematics, first: false }, GestureFlag.OnChange)\n    }\n  }\n\n  onEnd = (): void => {\n    if (!this.getState().active) return\n    this.updateState({ moving: false }, { ...genericEndState, velocity: 0, velocities: [0, 0] }, GestureFlag.OnEnd)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerMove', this.onChange]]\n    }\n    return [['onMouseMove', this.onChange]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { GestureFlag, TransformedEvent, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class HoverRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('hover', controller, args)\n  }\n\n  onStart = (event: TransformedEvent): void => {\n    if (!this.isEnabled()) return\n    const { values, ...rest } = getPointerEventData(event)\n    this.updateState({ hovering: true, ...rest }, { values, event, args: this.args }, GestureFlag.OnChange)\n  }\n\n  onEnd = (event: TransformedEvent): void => {\n    if (!this.isEnabled()) return\n    const { values, ...rest } = getPointerEventData(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateState({ hovering: false, moving: false, ...rest }, { ...kinematics, ...genericEndState, velocity: 0, velocities: [0, 0] })\n\n    // when the mouse leaves the element, we also fire the move handler\n    // without waiting for move to end with debounce\n    this.controller.fireGestureHandler('move', GestureFlag.OnEnd)\n    this.controller.fireGestureHandler('hover', GestureFlag.OnChange)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerEnter', this.onStart], ['onPointerLeave', this.onEnd]]\n    }\n    return [['onMouseEnter', this.onStart], ['onMouseLeave', this.onEnd]]\n  }\n}\n","import Recognizer from './Recognizer'\nimport { addV, calculateVelocities } from '../utils'\nimport { DistanceAngle, GestureState, Vector2, TransformedEvent } from '../types'\n\n/**\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer extends Recognizer<DistanceAngle> {\n  /**\n   * Utility function to get kinematics of the gesture\n   * @d distance\n   * @a angle\n   * @event\n   * @returns set of values including delta, velocities, turns\n   */\n  protected getKinematics = ([d, a]: [number, number?], event: TransformedEvent): Partial<GestureState<DistanceAngle>> => {\n    const state = this.getState()\n    const { values: da, turns, initial, lastLocal, time = 0 } = state\n\n    // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n    a = a === undefined ? da[1] : a\n\n    const diff_d = d - da[0]\n    let diff_a = a - da[1]\n\n    /**\n     * The angle value might jump from 179deg to -179deg when we actually want to\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\n     * is supsiciously high (ie > 300deg) and increase the `turns` value\n     */\n    const newTurns = Math.abs(diff_a) > 300 ? turns + Math.sign(diff_a) : turns\n\n    // we update the angle difference to its corrected value\n    diff_a -= 360 * newTurns\n    const delta_d = d - initial[0]\n    const delta_a = a - 360 * newTurns - initial[1]\n\n    const delta: Vector2 = [delta_d, delta_a]\n\n    const delta_t = event.timeStamp - time\n    const velocities = calculateVelocities([diff_d, diff_a], delta_t) as Vector2\n\n    return {\n      event,\n      values: [d, a],\n      delta,\n      velocities,\n      turns: newTurns,\n      local: addV(lastLocal, delta),\n      previous: da,\n      time: event.timeStamp,\n    }\n  }\n}\n","import { TouchEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { noop, getTwoTouchesEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class PinchRecognizer extends DistanceAngleRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  onStart = (event: TransformedEvent<TouchEvent>): void => {\n    if (!this.isEnabled() || event.touches.length !== 2) return\n\n    const { values, origin, ...rest } = getTwoTouchesEventData(event)\n\n    const startState = this.getStartState(values, event)\n    this.updateState(\n      { ...rest, pinching: true, down: true },\n      { ...startState, origin, cancel: () => this.onCancel(event) },\n      GestureFlag.OnStart\n    )\n  }\n\n  onChange = (event: TransformedEvent<TouchEvent>): void => {\n    const { canceled, active } = this.getState()\n    if (canceled || !active || event.touches.length !== 2) return\n\n    const { values, origin, ...rest } = getTwoTouchesEventData(event)\n\n    const kinematics = this.getKinematics(values, event)\n    const cancel = () => this.onCancel(event)\n\n    this.updateState(rest, { ...kinematics, origin, first: false, cancel }, GestureFlag.OnChange)\n  }\n\n  onEnd = (event: TransformedEvent<TouchEvent>): void => {\n    if (!this.getState().active) return\n    this.updateState({ pinching: false, down: false, touches: 0 }, { ...genericEndState, event }, GestureFlag.OnEnd)\n  }\n\n  onCancel = (event: TransformedEvent<TouchEvent>): void => {\n    this.updateState(null, { canceled: true, cancel: noop })\n    requestAnimationFrame(() => this.onEnd(event))\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onTouchStart', this.onStart], ['onTouchMove', this.onChange], [['onTouchEnd', 'onTouchCancel'], this.onEnd]]\n  }\n}\n","import { WheelEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { getWheelEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class PinchWheelRecognizer extends DistanceAngleRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  onChange = (event: TransformedEvent<WheelEvent>): void => {\n    if (!this.isEnabled() || !event.ctrlKey) return\n    event.preventDefault()\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const { values, ...rest } = getWheelEventData(event)\n    const d = this.getState().values[0] - values[1]\n\n    if (!this.getState().active) {\n      const startState = this.getStartState([d, 0], event)\n      this.updateState({ pinching: true, ...rest }, startState, GestureFlag.OnStart)\n    } else {\n      const kinematics = this.getKinematics([d, undefined], event)\n      this.updateState(rest, { ...kinematics, first: false }, GestureFlag.OnChange)\n    }\n  }\n\n  onEnd = (): void => {\n    if (!this.getState().active) return\n    this.updateState({ pinching: false, down: false, touches: 0 }, { ...genericEndState }, GestureFlag.OnEnd)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onWheel', this.onChange]]\n  }\n}\n","import { TouchEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { noop, getTwoTouchesEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, GestureEvent, Fn, Vector2 } from '../types'\nimport { genericEndState } from '../defaults'\n\nconst SCALE_FACTOR = 260\n\nexport default class PinchWebKitGestureRecognizer extends DistanceAngleRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  onStart = (event: TransformedEvent<GestureEvent>): void => {\n    if (!this.isEnabled()) return\n    event.preventDefault()\n\n    const da: Vector2 = [event.scale * SCALE_FACTOR, event.rotation]\n\n    const startState = this.getStartState(da, event)\n    this.updateState({ pinching: true, down: true, touches: 2 }, { ...startState, cancel: () => this.onCancel(event) }, GestureFlag.OnStart)\n  }\n\n  onChange = (event: TransformedEvent<GestureEvent>): void => {\n    const { canceled, active } = this.getState()\n    if (canceled || !active) return\n    event.preventDefault()\n\n    const da: Vector2 = [event.scale * SCALE_FACTOR, event.rotation]\n\n    const kinematics = this.getKinematics(da, event)\n    const cancel = () => this.onCancel(event)\n\n    this.updateState(null, { ...kinematics, first: false, cancel }, GestureFlag.OnChange)\n  }\n\n  onEnd = (event: TransformedEvent): void => {\n    if (!this.getState().active) return\n    event.preventDefault()\n    this.updateState({ pinching: false, down: false, touches: 0 }, { ...genericEndState, event }, GestureFlag.OnEnd)\n  }\n\n  onCancel = (event: TransformedEvent): void => {\n    this.updateState(null, { canceled: true, cancel: noop })\n    requestAnimationFrame(() => this.onEnd(event))\n  }\n\n  updateTouchData = (event: TransformedEvent<TouchEvent>): void => {\n    if (!this.isEnabled() || event.touches.length !== 2) return\n    const { origin } = getTwoTouchesEventData(event)\n    this.updateState(null, { origin })\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [\n      ['onGestureStart', this.onStart],\n      ['onGestureChange', this.onChange],\n      [['onGestureEnd', 'onTouchCancel'], this.onEnd],\n      [['onTouchStart', 'onTouchMove'], this.updateTouchData],\n    ]\n  }\n}\n","import {\n  Coordinates,\n  DistanceAngle,\n  StateKey,\n  StateObject,\n  GestureState,\n  SharedGestureState,\n  GestureKey,\n  FullGestureState,\n  Fn,\n  ReactEventHandlerKey,\n  GestureFlag,\n  ReactEventHandlers,\n  GestureConfig,\n  GestureHandlers,\n  HandlerKey,\n  GestureHandlersPartial,\n} from '../types'\n\nimport { initialState, mappedKeys } from '../defaults'\nimport { addListeners, removeListeners, supportsGestureEvent, chainFns } from '../utils'\n\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport HoverRecognizer from '../recognizers/HoverRecognizer'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport PinchWheelRecognizer from '../recognizers/PinchWheelRecognizer'\nimport PinchWebKitGestureRecognizer from '../recognizers/PinchWebKitGestureRecognizer'\nimport CoordinatesRecognizer from '../recognizers/CoordinatesRecognizer'\nimport DistanceAngleRecognizer from '../recognizers/DistanceAngleRecognizer'\n\ntype GestureTimeouts = Partial<{ [stateKey in StateKey]: number }>\ntype WindowListeners = Partial<{ [stateKey in StateKey]: [string, Fn][] }>\ntype Bindings = Partial<{ [eventName in ReactEventHandlerKey]: Fn[] | Fn }>\n\n/**\n * Gesture controller will create gesture recognizers (which handle the gesture logic)\n * and keep track of the state for all gestures\n *\n * @template BinderType the type the bind function should return\n */\nexport default class GestureController {\n  public state: StateObject = initialState // state for all gestures\n  public timeouts: GestureTimeouts = {} // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n  private bindings: Bindings = {} // an object holding the handlers associated to the gestures\n  private domListeners: [string, Fn][] = [] // when config.domTarget is set, we attach events directly to the dom\n  private windowListeners: WindowListeners = {} // keeps track of window listeners added by gestures (drag only at the moment)\n\n  constructor(public handlers: GestureHandlersPartial, public config: GestureConfig) {}\n\n  /**\n   * Function run on component unmount\n   * Cleans timeouts and removes dom listeners set by the bind function\n   */\n  public clean = (): void => {\n    this.cleanOnBind()\n    Object.values(this.timeouts).forEach(clearTimeout)\n    Object.keys(this.windowListeners).forEach(stateKey => this.removeWindowListeners(<StateKey>stateKey))\n  }\n\n  /**\n   * Function run every time the bind function is run (ie on every render)\n   * Reset the binding object and remove dom listeners attached to config.domTarget\n   */\n  private cleanOnBind = (): void => {\n    this.bindings = {}\n    const { domTarget } = this.config\n    if (domTarget) {\n      removeListeners(<EventTarget>domTarget, this.domListeners, this.config.event)\n      this.domListeners = []\n    }\n  }\n\n  /**\n   * Commodity function to let gesture recognizer update global state\n   * @param sharedState shared partial state object\n   * @param gestureState partial gesture specific state object\n   * @param gestureKey the gesture key ('drag', 'move'...)\n   * @param [gestureFlag] if set, will also fire the gesture handler set by the user\n   */\n  public updateState = (\n    sharedState: Partial<SharedGestureState> | null,\n    gestureState: Partial<GestureState<Coordinates | DistanceAngle>>,\n    gestureKey: GestureKey,\n    gestureFlag?: GestureFlag\n  ): void => {\n    const stateKey = mappedKeys[gestureKey].stateKey\n\n    this.state = {\n      ...this.state,\n      shared: { ...this.state.shared, ...sharedState },\n      [stateKey]: { ...this.state[stateKey], ...(gestureState as object) },\n    }\n\n    if (gestureFlag) {\n      this.fireGestureHandler(gestureKey, gestureFlag)\n    }\n  }\n\n  // fire the gesture handler defined by the user\n  public fireGestureHandler = (gestureKey: GestureKey, gestureFlag: GestureFlag): void => {\n    // gets the state key and handler key from the gesture key\n    // gestureKey: 'hover' -> stateKey: 'move', handlerKey: 'onHover'\n    const { stateKey, handlerKey } = mappedKeys[gestureKey]\n    const state = { ...this.state.shared, ...this.state[stateKey] }\n\n    if (gestureKey === 'pinch') {\n      const pinchState = state as FullGestureState<DistanceAngle>\n      pinchState.da = state.values // legacy state attribute for pinch gestures\n      pinchState.vdva = state.velocities // legacy state attribute for pinch gestures\n    } else {\n      const coordinatesState = state as FullGestureState<Coordinates>\n      coordinatesState.xy = state.values // legacy state attribute for xy gestures\n      coordinatesState.vxvy = state.velocities // legacy state attribute for xy gestures\n    }\n    // TODO to be removed in future versions\n    state.temp = state.memo // legacy temp attribute\n\n    if (gestureFlag === GestureFlag.OnStart) {\n      const handlerStart = `${handlerKey}Start` as keyof GestureHandlers\n      const handler = this.handlers[handlerStart] as any\n      handler && handler(state)\n    }\n\n    // whenever a flag is set, we run the default on[Gesture] function\n    // i.e. GestureFlag.OnStart would trigger both onDragStart and onDrag\n    const handler = this.handlers[handlerKey] as any\n    if (handler) {\n      const newMemo = handler(state)\n      this.state[stateKey].memo = newMemo !== undefined ? newMemo : this.state[stateKey].memo\n    }\n\n    if (gestureFlag === GestureFlag.OnEnd) {\n      const handlerEnd = `${handlerKey}End` as keyof GestureHandlers\n      const handler = this.handlers[handlerEnd] as any\n      handler && handler(state)\n    }\n  }\n\n  /**\n   * Commodity function to let recognizers simply add listeners to config.window\n   * @param stateKey\n   * @param listeners\n   */\n  public addWindowListeners = (stateKey: StateKey, listeners: [string, Fn][]): void => {\n    if (!this.config.window) return\n    // we use this.windowListeners to keep track of the listeners we add\n    this.windowListeners[stateKey] = listeners\n    addListeners(this.config.window, listeners, this.config.event)\n  }\n\n  // commodity function to let recognizers simply remove listeners from config.window\n  public removeWindowListeners = (stateKey: StateKey): void => {\n    if (!this.config.window) return\n    const listeners = this.windowListeners[stateKey]\n    if (listeners) {\n      removeListeners(this.config.window, listeners, this.config.event)\n      delete this.windowListeners[stateKey]\n    }\n  }\n\n  /**\n   * Adds a recognizer to this.bindings\n   * @param recognizer\n   */\n  private addRecognizer = (recognizer: CoordinatesRecognizer | DistanceAngleRecognizer): void => {\n    recognizer.getEventBindings().map(this.addEventBindings)\n  }\n\n  /**\n   * this.bindings is an object which keys match ReactEventHandlerKeys (onMouseMove, onTouchStart...).\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n   * that key.\n   */\n  private addEventBindings = ([eventNames, fn]: [ReactEventHandlerKey | ReactEventHandlerKey[], Fn]): void => {\n    const eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames\n\n    eventNamesArray.forEach(eventName => {\n      this.bindings[eventName] = this.bindings[eventName] ? [...(<Fn[]>this.bindings[eventName]), fn] : [fn]\n    })\n  }\n\n  /**\n   * When config.domTarget is set, this function will add dom listeners to it\n   */\n  private addDomTargetListeners = (): void => {\n    const { domTarget } = this.config\n\n    // we iterate on the entries of this.binding\n    // for each event, we chain the array of functions mapped to it\n    // and push it to this.domListeners\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      this.domListeners.push([event.substr(2).toLowerCase(), chainFns(...(<Fn[]>fns))])\n    })\n\n    addListeners(<EventTarget>domTarget, this.domListeners, this.config.event)\n  }\n\n  /**\n   * getBindings will return an object that will be bound by users\n   * to the react component they want to interact with\n   */\n  private getBindings = (): ReactEventHandlers => {\n    const output: ReactEventHandlers = {}\n    const captureString = this.config.event.capture ? 'Capture' : ''\n\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      const fnsArray = Array.isArray(fns) ? fns : [fns]\n      const key = (event + captureString) as ReactEventHandlerKey\n      output[key] = chainFns(...(<Fn[]>fnsArray))\n    })\n\n    return output\n  }\n\n  public bind = (...args: any[]): Fn | ReactEventHandlers => {\n    // if handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n    // actions will skip on[Gesture][\"Start\"|\"End\"] functions and include\n    // ['onDrag', 'onMove']\n    const actions: Set<HandlerKey | undefined> = new Set(\n      Object.keys(this.handlers)\n        .filter(k => k.indexOf('on') === 0)\n        .map(k => {\n          const match = k.match(/(on[A-Z][a-z]+)/)\n          return match ? <HandlerKey>match[1] : undefined\n        })\n    )\n\n    const { domTarget } = this.config\n\n    const genuineHandlers = { ...this.handlers }\n\n    // cleaning before adding\n    this.cleanOnBind()\n\n    if (actions.has('onDrag')) {\n      this.addRecognizer(new DragRecognizer(this, args))\n      delete genuineHandlers.onDrag\n      delete genuineHandlers.onDragStart\n      delete genuineHandlers.onDragEnd\n    }\n    if (actions.has('onScroll')) {\n      this.addRecognizer(new ScrollRecognizer(this, args))\n      delete genuineHandlers.onScroll\n      delete genuineHandlers.onScrollStart\n      delete genuineHandlers.onScrollEnd\n    }\n    if (actions.has('onWheel')) {\n      this.addRecognizer(new WheelRecognizer(this, args))\n      delete genuineHandlers.onWheel\n      delete genuineHandlers.onWheelStart\n      delete genuineHandlers.onWheelEnd\n    }\n    if (actions.has('onMove')) {\n      this.addRecognizer(new MoveRecognizer(this, args))\n      delete genuineHandlers.onMove\n      delete genuineHandlers.onMoveStart\n      delete genuineHandlers.onMoveEnd\n    }\n    if (actions.has('onHover')) {\n      this.addRecognizer(new HoverRecognizer(this, args))\n      delete genuineHandlers.onHover\n    }\n    if (actions.has('onPinch')) {\n      // since react doesn't have handlers for gesture events we can only use them\n      // domTarget is set (and when the browser supprots them).\n      if (domTarget && supportsGestureEvent()) {\n        this.addRecognizer(new PinchWebKitGestureRecognizer(this, args))\n      } else {\n        this.addRecognizer(new PinchRecognizer(this, args))\n        this.addRecognizer(new PinchWheelRecognizer(this, args))\n      }\n      delete genuineHandlers.onPinch\n      delete genuineHandlers.onPinchStart\n      delete genuineHandlers.onPinchEnd\n    }\n\n    // we also add event bindings for genuine handlers\n    Object.entries(genuineHandlers).map(([event, fn]) => {\n      // we're cheating when it comes to event type :(\n      this.addEventBindings([<ReactEventHandlerKey>event, <Fn>fn])\n    })\n\n    // if config.domTarget is set we add event listeners to it and return the clean function\n    if (domTarget) {\n      this.addDomTargetListeners()\n      return this.clean\n    }\n\n    // if not, we return an object that contains gesture handlers mapped to react handler event keys\n    return this.getBindings()\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, ButtonIcon, IconRight, IconLeft } from '@aragon/ui'\n\nfunction PrevNext({ onClick, type }) {\n  const next = type === 'next'\n  const Icon = next ? IconRight : IconLeft\n  return (\n    <ButtonIcon\n      onClick={onClick}\n      label={next ? 'Next' : 'Previous'}\n      css={`\n        position: absolute;\n        z-index: 1;\n        top: calc(50% - ${3 * GU}px);\n        height: ${6 * GU}px;\n        ${next ? 'right' : 'left'}: ${5 * GU}px;\n      `}\n    >\n      <Icon size=\"large\" />\n    </ButtonIcon>\n  )\n}\n\nPrevNext.propTypes = {\n  onClick: PropTypes.func.isRequired,\n  type: PropTypes.oneOf(['next', 'previous']).isRequired,\n}\n\nexport default PrevNext\n","import React, { useCallback, useEffect, useState, useRef } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, useViewport, unselectable, springs } from '@aragon/ui'\nimport { animated, useSpring } from 'react-spring/hooks'\nimport { useDrag } from 'react-use-gesture'\nimport PrevNext from './PrevNext'\n\n// TODO:\n//  - Center the items when the total is smaller than the viewport.\n\nconst AnimatedDiv = animated.div\n\nfunction Carousel({ items, itemWidth, itemHeight, itemSpacing }) {\n  const [selected, setSelected] = useState(0)\n  const [containerWidth, setContainerWidth] = useState(0)\n  const [visibleItems, setVisibleItems] = useState(0)\n  const container = useRef(null)\n  const { width: vw } = useViewport()\n\n  // Set the number of visible items,\n  // and adjust the selected item if needed.\n  useEffect(() => {\n    const potencialVisibleItems = Math.max(\n      1,\n      Math.floor((containerWidth - itemSpacing * 2) / (itemWidth + itemSpacing))\n    )\n\n    const visibleItems =\n      potencialVisibleItems <= items.length\n        ? potencialVisibleItems\n        : items.length\n\n    const lastSelectionableItem =\n      items.length - visibleItems >= 0 ? items.length - visibleItems : 0\n\n    setVisibleItems(visibleItems)\n    setSelected(selected =>\n      selected > lastSelectionableItem ? lastSelectionableItem : selected\n    )\n  }, [containerWidth, itemSpacing, itemWidth, items])\n\n  const updateContainerWidth = useCallback(element => {\n    setContainerWidth(element ? element.clientWidth : 0)\n  }, [])\n\n  useEffect(() => {\n    if (container.current) {\n      updateContainerWidth(container.current)\n    }\n  }, [vw, updateContainerWidth])\n\n  const handleContainerRef = useCallback(\n    element => {\n      container.current = element\n      updateContainerWidth(element)\n    },\n    [updateContainerWidth]\n  )\n\n  const prev = useCallback(() => {\n    setSelected(selected => Math.max(0, selected - visibleItems))\n  }, [visibleItems])\n\n  const next = useCallback(() => {\n    setSelected(selected =>\n      Math.min(items.length - visibleItems, selected + visibleItems)\n    )\n  }, [items, visibleItems])\n\n  // The total width of the visible items\n  const visibleItemsWidth =\n    visibleItems * itemWidth + (visibleItems - 1) * itemSpacing\n\n  // The space on one side of the visible items\n  const sideSpace = (containerWidth - visibleItemsWidth) / 2\n\n  // Get the container x position from an item index\n  const xFromItem = useCallback(\n    index => sideSpace - (itemWidth + itemSpacing) * index,\n    [sideSpace, itemWidth, itemSpacing]\n  )\n\n  // Get an item index from the container x position\n  /*\n  const itemFromX = useCallback(\n    x =>\n      Math.max(\n        0,\n        Math.min(\n          items.length - visibleItems,\n\n          // We multiply by -1 because the resulting number is either negative\n          // (if the first item starts to disappear on the left edge), or 0.\n          Math.floor(x / (itemWidth + itemSpacing)) * -1\n        )\n      ),\n    [items, itemWidth, itemSpacing, visibleItems]\n  )\n  */\n\n  // The current x position, before the drag\n  const selectedX = xFromItem(selected)\n\n  // The x position of the last item, before the drag\n  const lastX = xFromItem(\n    items.length > visibleItems ? items.length - visibleItems : 0\n  )\n\n  // Handles the actual x position, with the drag\n  const [{ x }, setX] = useSpring(() => ({\n    x: selectedX,\n    config: springs.lazy,\n    drag: false,\n    immediate: true,\n  }))\n\n  // Update the transition during drag\n  const bindDrag = useDrag(({ event, down, delta }) => {\n    const updatedX = Math.max(lastX, Math.min(sideSpace, selectedX + delta[0]))\n\n    if (down) {\n      setX({\n        x: updatedX,\n        drag: delta[0] !== 0,\n        immediate: true, // TODO: keep going until we decelerate enough, then stick to an item\n      })\n    } else {\n      let target = selected\n      if (Math.abs(delta[0]) > itemWidth / 2) {\n        if (delta[0] > 0) {\n          target = Math.max(0, selected - 1)\n        } else {\n          target = Math.min(selected + 1, items.length - 1)\n        }\n      }\n\n      setX({\n        x: xFromItem(target),\n        drag: false,\n        immediate: false,\n      })\n      setSelected(target)\n    }\n  })\n\n  // Update the transition when the base x position updates\n  useEffect(() => {\n    setX({ x: selectedX, immediate: false })\n  }, [selectedX, setX])\n\n  return (\n    <div\n      ref={handleContainerRef}\n      css={`\n        ${unselectable};\n        position: relative;\n        overflow: hidden;\n        width: 100%;\n        height: ${itemHeight}px;\n        touch-action: none;\n      `}\n    >\n      {selected > 0 && <PrevNext type=\"previous\" onClick={prev} />}\n      {selected < items.length - visibleItems && (\n        <PrevNext type=\"next\" onClick={next} />\n      )}\n      <AnimatedDiv\n        {...bindDrag()}\n        style={{\n          // eslint-disable-next-line no-sequences\n          transform: x.interpolate(x => `translate3d(${(0, x)}px, 0, 0)`),\n          // transform: selectedX.interpolate(v => `translate3d(${v}px, 0, 0)`),\n        }}\n        css={`\n          display: flex;\n          height: 100%;\n          position: absolute;\n          touch-action: none;\n        `}\n      >\n        {items.map((item, i) => (\n          <AnimatedDiv\n            key={i}\n            // style={{\n            //   opacity: drag.interpolate(drag =>\n            //     drag || (i >= selected && i < selected + visibleItems)\n            //       ? 1\n            //       : 0.25\n            //   ),\n            // }}\n            css={`\n              flex-grow: 0;\n              flex-shrink: 0;\n              width: ${itemWidth}px;\n              height: ${itemHeight}px;\n              transition: opacity 150ms ease-in-out;\n              & + & {\n                margin-left: ${3 * GU}px;\n              }\n            `}\n          >\n            {item}\n          </AnimatedDiv>\n        ))}\n      </AnimatedDiv>\n    </div>\n  )\n}\n\nCarousel.propTypes = {\n  items: PropTypes.arrayOf(PropTypes.node).isRequired,\n  itemWidth: PropTypes.number.isRequired,\n  itemHeight: PropTypes.number.isRequired,\n  itemSpacing: PropTypes.number.isRequired,\n}\n\nexport default Carousel\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { textStyle, useTheme, GU } from '@aragon/ui'\n\nfunction Header({\n  title,\n  subtitle,\n  topSpacing = 10 * GU,\n  bottomSpacing = 7 * GU,\n}) {\n  const theme = useTheme()\n  return (\n    <header\n      css={`\n        padding: ${topSpacing}px ${2 * GU}px ${bottomSpacing}px;\n        text-align: center;\n      `}\n    >\n      <h1\n        css={`\n          // Not in aragonUI - exceptionally used here\n          font-size: 40px;\n          font-weight: 600;\n          padding-bottom: ${subtitle ? 2 * GU : 0}px;\n        `}\n      >\n        {title}\n      </h1>\n      {subtitle && (\n        <div\n          css={`\n            ${textStyle('title4')};\n            color: ${theme.contentSecondary};\n          `}\n        >\n          {subtitle}\n        </div>\n      )}\n    </header>\n  )\n}\n\nHeader.propTypes = {\n  title: PropTypes.node.isRequired,\n  subtitle: PropTypes.node,\n  topSpacing: PropTypes.number.isRequired,\n  bottomSpacing: PropTypes.number.isRequired,\n}\n\nHeader.defaultProps = {\n  topSpacing: 10 * GU,\n  bottomSpacing: 7 * GU,\n}\n\nexport default Header\n","import React, { useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { Card, Tag, textStyle, GU, Button, useTheme } from '@aragon/ui'\nimport { OrgTemplateType } from '../../prop-types'\n\nfunction TemplateCard({ onOpen, template }) {\n  const theme = useTheme()\n  const handleDetailsClick = useCallback(() => {\n    onOpen(template.id)\n  }, [onOpen, template.id])\n  return (\n    <Card\n      width=\"100%\"\n      height=\"100%\"\n      css={`\n        display: flex;\n        flex-direction: column;\n        justify-content: flex-start;\n      `}\n    >\n      <section\n        css={`\n          display: flex;\n          flex-direction: column;\n          justify-content: space-between;\n          height: 100%;\n          overflow: hidden;\n        `}\n      >\n        <div>\n          <img\n            src={template.header}\n            alt=\"\"\n            css={`\n              display: block;\n              width: 100%;\n              pointer-events: none;\n            `}\n          />\n          <div\n            css={`\n              padding: ${2.5 * GU}px ${3 * GU}px 0;\n            `}\n          >\n            <h1\n              css={`\n                display: flex;\n                align-items: center;\n                padding-bottom: ${1 * GU}px;\n                ${textStyle('body1')};\n              `}\n            >\n              <span>{template.name}</span>\n              {(template.disabled || template.new || template.beta) && (\n                <Tag\n                  mode=\"new\"\n                  css={`\n                    margin-left: ${1 * GU}px;\n                    flex-shrink: 0;\n                  `}\n                >\n                  {template.disabled\n                    ? 'Coming soon'\n                    : template.beta\n                    ? 'Beta'\n                    : 'New'}\n                </Tag>\n              )}\n            </h1>\n            <p\n              css={`\n                ${textStyle('body2')};\n                color: ${theme.surfaceContentSecondary};\n              `}\n            >\n              {template.description}\n            </p>\n          </div>\n        </div>\n        <div\n          css={`\n            padding: 0 ${3 * GU}px ${2 * GU}px;\n          `}\n        >\n          <Button wide label=\"View details\" onClick={handleDetailsClick} />\n        </div>\n      </section>\n    </Card>\n  )\n}\n\nTemplateCard.propTypes = {\n  onOpen: PropTypes.func.isRequired,\n  template: OrgTemplateType.isRequired,\n}\n\nexport default TemplateCard\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { AppBadge } from '@aragon/ui'\nimport iconSvgAddressBook from './icons/address-book.svg'\nimport iconSvgAgent from './icons/agent.svg'\nimport iconSvgAllocations from './icons/allocations.svg'\nimport iconSvgDandelionVoting from './icons/dandelion-voting.svg'\nimport iconSvgDotVoting from './icons/dot-voting.svg'\nimport iconSvgFinance from './icons/finance.svg'\nimport iconSvgFundraising from './icons/fundraising.svg'\nimport iconSvgPayroll from './icons/payroll.svg'\nimport iconSvgProjects from './icons/projects.svg'\nimport iconSvgRedemptions from './icons/redemptions.svg'\nimport iconSvgRewards from './icons/rewards.svg'\nimport iconSvgTimeLock from './icons/time-lock.svg'\nimport iconSvgTokens from './icons/token-manager.svg'\nimport iconSvgTokenRequest from './icons/token-request.svg'\nimport iconSvgVault from './icons/vault.svg'\nimport iconSvgVoting from './icons/voting.svg'\n\nconst KNOWN_ICONS = new Map([\n  ['address-book.aragonpm.eth', iconSvgAddressBook],\n  ['agent.aragonpm.eth', iconSvgAgent],\n  ['allocations.aragonpm.eth', iconSvgAllocations],\n  ['aragon-fundraising.aragonpm.eth', iconSvgFundraising],\n  ['dandelion-voting.aragonpm.eth', iconSvgDandelionVoting],\n  ['dot-voting.aragonpm.eth', iconSvgDotVoting],\n  ['finance.aragonpm.eth', iconSvgFinance],\n  ['payroll.aragonpm.eth', iconSvgPayroll],\n  ['projects.aragonpm.eth', iconSvgProjects],\n  ['redemptions.aragonpm.eth', iconSvgRedemptions],\n  ['rewards.aragonpm.eth', iconSvgRewards],\n  ['time-lock.aragonpm.eth', iconSvgTimeLock],\n  ['token-manager.aragonpm.eth', iconSvgTokens],\n  ['token-request.aragonpm.eth', iconSvgTokenRequest],\n  ['vault.aragonpm.eth', iconSvgVault],\n  ['voting.aragonpm.eth', iconSvgVoting],\n])\n\nfunction KnownAppBadge({ appName, compact, label }) {\n  return <AppBadge badgeOnly iconSrc={KNOWN_ICONS.get(appName)} label={label} />\n}\nKnownAppBadge.propTypes = {\n  appName: PropTypes.string.isRequired,\n  compact: PropTypes.bool,\n  label: PropTypes.string.isRequired,\n}\n\nexport default KnownAppBadge\n","import React, { useCallback, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  Button,\n  Switch,\n  Field,\n  IconCheck,\n  GU,\n  Link,\n  Modal,\n  Tag,\n  textStyle,\n  unselectable,\n  useViewport,\n  useTheme,\n} from '@aragon/ui'\nimport { TEMPLATE_LOADING, TEMPLATE_UNAVAILABLE } from '../symbols'\nimport { stripUrlProtocol, sanitizeCodeRepositoryUrl } from '../../util/url'\nimport AppIcon from '../../components/AppIcon/AppIcon'\nimport KnownAppBadge from '../../templates/kit/KnownAppBadge'\nimport { trackEvent, events } from '../../analytics'\nimport { useWallet } from '../../contexts/wallet'\n\nfunction TemplateDetails({ template, visible, onUse, onClose }) {\n  const theme = useTheme()\n  const { networkName } = useWallet()\n  const { above, below, width } = useViewport()\n  const [templateOptionalApps, setTemplateOptionalApps] = useState({})\n\n  const handleUseClick = useCallback(() => {\n    const selectedOptionalApps = Object.entries(templateOptionalApps)\n      .filter(([_, value]) => Boolean(value))\n      .map(([appName]) => appName)\n    onUse(template.id, selectedOptionalApps)\n\n    // analytics test\n    trackEvent(events.DAO_CREATION_TEMPLATE_SELECTED, {\n      name: template.name,\n      network: networkName,\n    })\n  }, [onUse, template, templateOptionalApps, networkName])\n\n  const handleSectionRef = useCallback(element => {\n    if (element) {\n      element.focus()\n    }\n  }, [])\n\n  const modalWidth = useCallback(() => {\n    if (above('large')) {\n      return 130 * GU\n    }\n    if (above('medium')) {\n      return 80 * GU\n    }\n    return width - 4 * GU\n  }, [above, width])\n\n  if (template === null) {\n    return null\n  }\n\n  let padding = 2 * GU\n  if (above('medium')) padding = 5 * GU\n  if (above('large')) padding = 7 * GU\n\n  const verticalMode = below('large')\n\n  return (\n    <Modal visible={visible} width={modalWidth} onClose={onClose} padding={0}>\n      <section\n        ref={handleSectionRef}\n        tabIndex=\"0\"\n        css={`\n          outline: 0;\n          ${verticalMode\n            ? ''\n            : `\n              display: grid;\n              grid-template-columns: auto ${48 * GU}px;\n            `};\n        `}\n      >\n        <div\n          css={`\n            display: flex;\n            flex-direction: column;\n            justify-content: space-between;\n            padding: ${padding}px;\n          `}\n        >\n          <div>\n            <div css=\"display: flex\">\n              <AppIcon src={template.icon} size={6.5 * GU} />\n            </div>\n            <h1\n              css={`\n                display: flex;\n                align-items: center;\n\n                // Not in aragonUI - exceptionally used here\n                font-size: 40px;\n                font-weight: 600;\n                padding: ${3 * GU}px 0 ${2 * GU}px;\n              `}\n            >\n              {template.name}\n              {(template.disabled || template.new || template.beta) && (\n                <Tag\n                  mode=\"new\"\n                  css={`\n                    margin-left: ${1 * GU}px;\n                    flex-shrink: 0;\n                  `}\n                >\n                  {template.disabled\n                    ? 'Coming soon'\n                    : template.beta\n                    ? 'Beta'\n                    : 'New'}\n                </Tag>\n              )}\n            </h1>\n            <p\n              css={`\n                ${textStyle('body1')};\n                color: ${theme.contentSecondary};\n              `}\n            >\n              {template.longdesc || template.description}\n            </p>\n            <div\n              css={`\n                margin: ${5 * GU}px 0 0;\n              `}\n            >\n              {template.caseStudyUrl && (\n                <Field label=\"Case study\">\n                  <Link href={template.caseStudyUrl}>\n                    {sanitizeCodeRepositoryUrl(\n                      stripUrlProtocol(template.caseStudyUrl)\n                    )}\n                  </Link>\n                </Field>\n              )}\n              {template.userGuideUrl && (\n                <Field label=\"User guide\">\n                  <Link href={template.userGuideUrl}>\n                    {sanitizeCodeRepositoryUrl(\n                      stripUrlProtocol(template.userGuideUrl)\n                    )}\n                  </Link>\n                </Field>\n              )}\n              <Field label=\"Source code\">\n                <Link href={template.sourceCodeUrl}>\n                  {sanitizeCodeRepositoryUrl(\n                    stripUrlProtocol(template.sourceCodeUrl)\n                  )}\n                </Link>\n              </Field>\n              <Field label=\"Registry\">{template.registry}</Field>\n            </div>\n          </div>\n\n          {!verticalMode && (\n            <SelectTemplateButton\n              onClick={handleUseClick}\n              template={template}\n            />\n          )}\n        </div>\n        <div\n          css={`\n            height: 100%;\n            width: ${verticalMode ? 'auto' : `${48 * GU}px`};\n            padding: ${verticalMode\n              ? `${padding}px`\n              : `${7 * GU}px ${3 * GU}px`};\n            background: ${theme.background};\n          `}\n        >\n          <h2\n            css={`\n              padding-bottom: ${3 * GU}px;\n              ${textStyle('body1')};\n            `}\n          >\n            Template configuration\n          </h2>\n\n          {template.apps && template.apps.length > 0 && (\n            <Field\n              label=\"Included apps\"\n              css={`\n                margin-bottom: ${4 * GU}px;\n              `}\n            >\n              {template.apps.map(({ appName, label }, index) => (\n                <div\n                  key={index}\n                  css={`\n                    display: flex;\n                    justify-content: space-between;\n                    margin-top: ${2 * GU}px;\n\n                    & + & {\n                      margin-top: ${1.5 * GU}px;\n                    }\n                  `}\n                >\n                  <KnownAppBadge appName={appName} label={label} />\n                  <div\n                    css={`\n                      display: flex;\n                      align-items: center;\n                      ${unselectable}\n                    `}\n                  >\n                    <IconCheck\n                      css={`\n                        color: ${theme.positive};\n                        margin-right: ${0.25 * GU}px;\n                      `}\n                    />\n                    Included\n                  </div>\n                </div>\n              ))}\n            </Field>\n          )}\n          {template.optionalApps && template.optionalApps.length > 0 && (\n            <Field\n              label=\"Optional apps\"\n              css={`\n                height: 150px;\n              `}\n            >\n              {() =>\n                template.optionalApps.map(({ appName, label }, index) => (\n                  <div\n                    key={index}\n                    css={`\n                      display: flex;\n                      justify-content: space-between;\n                      align-items: center;\n                      margin-top: ${2 * GU}px;\n\n                      & + & {\n                        margin-top: ${1.5 * GU}px;\n                      }\n                    `}\n                  >\n                    <KnownAppBadge appName={appName} label={label} />\n                    <Switch\n                      checked={templateOptionalApps[appName]}\n                      onChange={() => {\n                        setTemplateOptionalApps(apps => ({\n                          ...apps,\n                          [appName]: !apps[appName],\n                        }))\n                      }}\n                    />\n                  </div>\n                ))\n              }\n            </Field>\n          )}\n          {verticalMode && (\n            <SelectTemplateButton\n              onClick={handleUseClick}\n              template={template}\n            />\n          )}\n        </div>\n      </section>\n    </Modal>\n  )\n}\nTemplateDetails.propTypes = {\n  onClose: PropTypes.func.isRequired,\n  onUse: PropTypes.func.isRequired,\n  template: PropTypes.object.isRequired,\n  visible: PropTypes.bool.isRequired,\n}\n\nfunction SelectTemplateButton({ onClick, template }) {\n  const templateLoading = template.status === TEMPLATE_LOADING\n  const templateUnavailable =\n    template.disabled || template.status === TEMPLATE_UNAVAILABLE\n  const label = templateUnavailable\n    ? 'This template is not available at the moment'\n    : templateLoading\n    ? 'Loading templateâ€¦'\n    : 'Use this template'\n\n  return (\n    <Button\n      disabled={templateLoading || templateUnavailable}\n      label={label}\n      mode=\"strong\"\n      onClick={onClick}\n      wide\n    />\n  )\n}\nSelectTemplateButton.propTypes = {\n  onClick: PropTypes.func.isRequired,\n  template: PropTypes.object.isRequired,\n}\n\nexport default TemplateDetails\n","import React, { useState, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU } from '@aragon/ui'\nimport Carousel from '../../components/Carousel/Carousel'\nimport Header from '../Header/Header'\nimport TemplateCard from './TemplateCard'\nimport TemplateDetails from './TemplateDetails'\n\nfunction Templates({ onUse, templates }) {\n  const [templateDetailsOpened, setTemplateDetailsOpened] = useState(false)\n  const [templateDetailsIndex, setTemplateDetailsIndex] = useState(0)\n\n  const handleOpen = useCallback(\n    id => {\n      setTemplateDetailsIndex(templates.findIndex(t => t.id === id))\n      setTemplateDetailsOpened(true)\n    },\n    [templates]\n  )\n\n  const handleDetailsClose = useCallback(() => {\n    setTemplateDetailsOpened(false)\n  }, [])\n\n  const handleDetailsUse = useCallback(\n    (id, optionalApps) => {\n      setTemplateDetailsIndex(0)\n      setTemplateDetailsOpened(false)\n      onUse(id, optionalApps)\n    },\n    [onUse]\n  )\n\n  const selectedTemplate = templates[templateDetailsIndex]\n\n  return (\n    <div\n      css={`\n        flex-grow: 1;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      `}\n    >\n      <Header\n        title=\"Select template\"\n        subtitle=\"Create your organization with our pre-configured templates\"\n        bottomSpacing={3 * GU}\n      />\n      <div\n        css={`\n          flex-grow: 1;\n          width: 100%;\n          display: flex;\n          align-items: center;\n          padding-bottom: ${3 * GU}px;\n        `}\n      >\n        {templates.length > 0 && (\n          <Carousel\n            itemWidth={38 * GU}\n            itemHeight={48 * GU}\n            itemSpacing={3 * GU}\n            items={templates.map(template => (\n              <TemplateCard\n                key={template.id}\n                onOpen={handleOpen}\n                template={template}\n              />\n            ))}\n          />\n        )}\n      </div>\n      <TemplateDetails\n        onClose={handleDetailsClose}\n        onUse={handleDetailsUse}\n        template={selectedTemplate}\n        visible={templateDetailsOpened}\n      />\n    </div>\n  )\n}\n\nTemplates.propTypes = {\n  onUse: PropTypes.func.isRequired,\n  templates: PropTypes.array.isRequired,\n}\n\nexport default Templates\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { useViewport, GU } from '@aragon/ui'\nimport ConfigureTemplateScreens from './ConfigureTemplateScreens'\nimport SetupStepsPanel from './SetupStepsPanel'\nimport * as CreateStatuses from '../Create/create-statuses'\nimport Templates from '../Templates/Templates'\nimport { OrgTemplateType } from '../../prop-types'\n\nexport const SETUP_MODE_SELECT = Symbol('SETUP_MODE_SELECT')\nexport const SETUP_MODE_CONFIGURE = Symbol('SETUP_MODE_CONFIGURE')\n\nfunction Setup({\n  TemplateScreen,\n  mode,\n  onNextTemplateScreen,\n  onPrevTemplateScreen,\n  onUseTemplate,\n  status,\n  stepIndex,\n  steps,\n  templateData,\n  templateScreenIndex,\n  screens,\n  templates,\n}) {\n  const { above } = useViewport()\n  return (\n    <React.Fragment>\n      {above('large') && (\n        <div\n          css={`\n            width: ${41 * GU}px;\n            flex-shrink: 0;\n            flex-grow: 0;\n          `}\n        >\n          <SetupStepsPanel step={stepIndex} steps={steps} />\n        </div>\n      )}\n      <section\n        css={`\n          display: flex;\n          flex-direction: column;\n          width: 100%;\n          flex-grow: 1;\n          flex-shrink: 1;\n        `}\n      >\n        <div\n          css={`\n            display: flex;\n            flex-direction: column;\n            flex-grow: 1;\n            position: relative;\n            overflow: hidden;\n          `}\n        >\n          {mode === SETUP_MODE_SELECT && (\n            <Templates onUse={onUseTemplate} templates={templates} />\n          )}\n          {mode === SETUP_MODE_CONFIGURE && (\n            <ConfigureTemplateScreens\n              TemplateScreen={TemplateScreen}\n              onNext={onNextTemplateScreen}\n              onPrev={onPrevTemplateScreen}\n              screenIndex={templateScreenIndex}\n              screens={screens}\n              templateData={templateData}\n            />\n          )}\n        </div>\n      </section>\n    </React.Fragment>\n  )\n}\n\nSetup.propTypes = {\n  TemplateScreen: PropTypes.func.isRequired,\n  mode: PropTypes.oneOf([SETUP_MODE_SELECT, SETUP_MODE_CONFIGURE]).isRequired,\n  onNextTemplateScreen: PropTypes.func.isRequired,\n  onPrevTemplateScreen: PropTypes.func.isRequired,\n  onUseTemplate: PropTypes.func.isRequired,\n  status: PropTypes.oneOf(Object.values(CreateStatuses)).isRequired,\n  stepIndex: PropTypes.number.isRequired,\n  steps: PropTypes.arrayOf(PropTypes.string).isRequired,\n  screens: PropTypes.array.isRequired,\n  templateData: PropTypes.object.isRequired,\n  templateScreenIndex: PropTypes.number.isRequired,\n  templates: PropTypes.arrayOf(OrgTemplateType).isRequired,\n}\n\nexport default Setup\n","// Only in onboarding (not in aragonUI)\nexport const TITLE_ONBOARDING = `\n  font-size: 40px;\n  font-weight: 600;\n  line-height: 1.5;\n`\n","import React, { useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { textStyle, GU, IconCheck, useTheme } from '@aragon/ui'\nimport { TransactionStatusType } from '../../prop-types'\nimport {\n  TRANSACTION_STATUS_PENDING,\n  TRANSACTION_STATUS_SUCCESS,\n  TRANSACTION_STATUS_UPCOMING,\n} from '../../symbols'\n\nfunction DeploymentStepsItem({ index, name, status }) {\n  const theme = useTheme()\n\n  const stepStyles = useMemo(() => {\n    if (status === TRANSACTION_STATUS_PENDING) {\n      return `\n        border: 2px solid ${theme.selected};\n      `\n    }\n    if (status === TRANSACTION_STATUS_SUCCESS) {\n      return `\n        border: 2px solid ${theme.positive};\n        color: ${theme.positive};\n      `\n    }\n    return `\n      padding-top: 2px;\n      background: #ECEFF4;\n      color: #9CA7B8;\n    `\n  }, [status, theme])\n\n  return (\n    <div\n      css={`\n        display: flex;\n        align-items: center;\n        height: ${5 * GU}px;\n        margin-top: ${3 * GU}px;\n      `}\n    >\n      <div\n        css={`\n          width: ${5 * GU}px;\n          height: ${5 * GU}px;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          border-radius: 50%;\n          font-size: 18px;\n          font-weight: 600;\n          ${stepStyles};\n          flex-shrink: 0;\n          flex-grow: 0;\n        `}\n      >\n        {status === TRANSACTION_STATUS_SUCCESS ? (\n          <IconCheck />\n        ) : (\n          status === TRANSACTION_STATUS_UPCOMING && index + 1\n        )}\n      </div>\n      <div\n        css={`\n          margin-left: ${3 * GU}px;\n          font-size: 18px;\n          font-weight: ${status === TRANSACTION_STATUS_PENDING ? '600' : '400'};\n          overflow: hidden;\n          text-overflow: ellipsis;\n        `}\n      >\n        <div>{name}</div>\n        {status === TRANSACTION_STATUS_SUCCESS && (\n          <div\n            css={`\n              ${textStyle('body3')};\n              color: ${theme.surfaceContentSecondary};\n            `}\n          >\n            Signature successful\n          </div>\n        )}\n      </div>\n    </div>\n  )\n}\n\nDeploymentStepsItem.propTypes = {\n  index: PropTypes.number.isRequired,\n  name: PropTypes.string.isRequired,\n  status: TransactionStatusType.isRequired,\n}\n\nexport default DeploymentStepsItem\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { textStyle, GU, Link, useTheme, ProgressBar, Info } from '@aragon/ui'\nimport { useWallet } from '../../contexts/wallet'\nimport DeploymentStepsItem from './DeploymentStepsItem'\nimport { TransactionStatusType } from '../../prop-types'\n\nfunction DeploymentStepsPanel({ transactionsStatus, pending, allSuccess }) {\n  const theme = useTheme()\n  const { providerInfo } = useWallet()\n\n  return (\n    <aside\n      css={`\n        display: flex;\n        flex-direction: column;\n        width: 100%;\n        min-height: 100%;\n        padding: ${16 * GU}px ${3 * GU}px ${2 * GU}px;\n        background: ${theme.surface};\n        border-right: 1px solid ${theme.border};\n      `}\n    >\n      <ProgressBar\n        value={Math.max(\n          0,\n          Math.min(\n            1,\n            allSuccess\n              ? 1\n              : transactionsStatus.length\n              ? pending / transactionsStatus.length\n              : 0\n          )\n        )}\n      />\n      <div\n        css={`\n          padding: ${3 * GU}px 0 ${3 * GU}px;\n          ${textStyle('body1')};\n          text-align: center;\n          color: ${theme.surfaceContentSecondary};\n        `}\n      >\n        Launching your organization\n      </div>\n\n      <div\n        css={`\n          flex-grow: 1;\n          padding-top: ${8 * GU}px;\n          padding-bottom: ${3 * GU}px;\n        `}\n      >\n        <h1\n          css={`\n            ${textStyle('label2')};\n            color: ${theme.surfaceContentSecondary};\n          `}\n        >\n          Signature process\n        </h1>\n\n        <div>\n          {transactionsStatus.map(({ name, status }, index) => (\n            <DeploymentStepsItem\n              key={index}\n              index={index}\n              name={name}\n              status={status}\n            />\n          ))}\n        </div>\n      </div>\n\n      {!allSuccess && (\n        <Info mode=\"warning\">\n          It might take some time before these transactions get processed.\n          Please be patient and <strong>do not close this window</strong> until\n          it finishes.{' '}\n          {providerInfo.id === 'metamask' && (\n            <>\n              Additionally, do not use the{' '}\n              <InlineLink href=\"https://metamask.zendesk.com/hc/en-us/articles/360015489251-How-to-Speed-Up-a-Transaction\">\n                \"Speed Up\"\n              </InlineLink>{' '}\n              MetaMask feature, otherwise you may not be able to finish creating\n              your organization.{' '}\n            </>\n          )}\n          For more details,{' '}\n          <InlineLink href=\"https://help.aragon.org/article/39-launch-taking-a-long-time-to-process\">\n            refer to the help desk.\n          </InlineLink>\n        </Info>\n      )}\n    </aside>\n  )\n}\n\nDeploymentStepsPanel.propTypes = {\n  allSuccess: PropTypes.bool.isRequired,\n  pending: PropTypes.number.isRequired,\n  transactionsStatus: PropTypes.arrayOf(\n    PropTypes.shape({\n      name: PropTypes.string.isRequired,\n      status: TransactionStatusType.isRequired,\n    })\n  ).isRequired,\n}\n\nconst InlineLink = ({ href, children }) => (\n  <Link href={href} css={'display: inline; white-space: normal'}>\n    {children}\n  </Link>\n)\n\nInlineLink.propTypes = {\n  href: PropTypes.string.isRequired,\n  children: PropTypes.node.isRequired,\n}\n\nexport default DeploymentStepsPanel\n","import React, { useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  Button,\n  GU,\n  ProgressBar,\n  RADIUS,\n  springs,\n  textStyle,\n  useTheme,\n  useViewport,\n} from '@aragon/ui'\nimport { Transition, animated } from 'react-spring'\nimport {\n  TRANSACTION_STATUS_PENDING,\n  TRANSACTION_STATUS_SUCCESS,\n} from '../../symbols'\nimport { TransactionStatusType } from '../../prop-types'\nimport { TITLE_ONBOARDING } from '../styles'\nimport DeploymentStepsPanel from './DeploymentStepsPanel'\n\nimport progressImgLarge from './assets/illustration-progress-large.svg'\nimport progressImgMedium from './assets/illustration-progress-medium.svg'\nimport allDoneImg from './assets/illustration-all-done.png'\n\nconst AnimDiv = animated.div\nconst AnimSection = animated.section\n\nfunction BoxBase({\n  children,\n  background,\n  boxTransform,\n  direction = 'column',\n  opacity,\n}) {\n  const theme = useTheme()\n  const { below } = useViewport()\n  const fullWidth = below('large')\n  return (\n    <AnimDiv\n      style={{ opacity }}\n      css={`\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        overflow: auto;\n        flex-grow: 1;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        padding: ${fullWidth ? 0 : 8 * GU}px;\n        background: ${background || theme.background};\n      `}\n    >\n      <AnimSection\n        style={{ transform: boxTransform }}\n        css={`\n          flex-grow: 1;\n          display: ${direction === 'column' ? 'grid' : 'flex'};\n          flex-direction: ${direction};\n          align-items: center;\n          justify-content: center;\n          max-width: ${fullWidth ? 'none' : `${128 * GU}px`};\n          height: ${fullWidth ? 'auto' : `${80 * GU}px`};\n          background: ${theme.surface};\n          border-radius: ${fullWidth ? 0 : RADIUS}px;\n          box-shadow: ${fullWidth ? 'none' : '0px 4px 6px rgba(0, 0, 0, 0.05)'};\n          position: ${fullWidth ? 'absolute' : 'static'};\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          overflow: ${fullWidth ? 'auto' : 'visible'};\n        `}\n      >\n        {children}\n      </AnimSection>\n    </AnimDiv>\n  )\n}\n\nBoxBase.propTypes = {\n  children: PropTypes.node.isRequired,\n  background: PropTypes.string,\n  boxTransform: PropTypes.object.isRequired,\n  direction: PropTypes.oneOf([\n    'column',\n    'column-reverse',\n    'row',\n    'row-reverse',\n  ]),\n  opacity: PropTypes.object.isRequired,\n}\n\nfunction BoxProgress({\n  allSuccess,\n  boxTransform,\n  opacity,\n  pending,\n  transactionsStatus,\n}) {\n  const theme = useTheme()\n  const { below } = useViewport()\n  const fullWidth = below('large')\n\n  const progress = Math.max(\n    0,\n    Math.min(1, allSuccess ? 1 : pending / transactionsStatus.length)\n  )\n\n  return (\n    <BoxBase\n      background=\"linear-gradient(\n        328deg,\n        #95bbce 0%,\n        #c5d0e6 46.04%,\n        #e7e4f6 100%\n      )\"\n      boxTransform={boxTransform}\n      direction={fullWidth ? 'column' : 'row-reverse'}\n      opacity={opacity}\n    >\n      <div\n        css={`\n          width: ${fullWidth ? 100 : 50}%;\n          height: ${fullWidth ? '430px' : '100%'};\n          background: #bbcbe1 50% 50% / cover no-repeat\n            url(${fullWidth ? progressImgMedium : progressImgLarge});\n        `}\n      />\n      <div\n        css={`\n          display: flex;\n          flex-direction: column;\n          justify-content: center;\n          width: ${fullWidth ? 100 : 50}%;\n          height: ${fullWidth ? 'auto' : '100%'};\n          padding: ${6 * GU}px;\n        `}\n      >\n        <h1\n          css={`\n              ${TITLE_ONBOARDING}\n              margin-bottom: ${2 * GU}px;\n            `}\n        >\n          Organizations\n          <br />\n          <span css=\"color: #8DB9D5\">of the future</span>\n        </h1>\n        <p\n          css={`\n            ${textStyle('body1')}\n            line-height: 2;\n            color: ${theme.surfaceContentSecondary};\n          `}\n        >\n          Aragon empowers you to freely organize and collaborate without borders\n          or intermediaries. Create global, bureaucracy-free organizations,\n          companies, and communities.\n        </p>\n\n        {fullWidth && (\n          <div\n            css={`\n              padding-top: ${2 * GU}px;\n            `}\n          >\n            <div\n              css={`\n                font-size: 13px;\n                font-weight: 800;\n                text-align: center;\n                padding-bottom: ${1 * GU}px;\n              `}\n            >\n              {Math.round(progress * 100)}%\n            </div>\n            <ProgressBar value={progress} />\n            <div\n              css={`\n                padding: ${3 * GU}px 0 ${3 * GU}px;\n                ${textStyle('body1')};\n                text-align: center;\n                color: ${theme.surfaceContentSecondary};\n              `}\n            >\n              Launching your organization\n            </div>\n          </div>\n        )}\n      </div>\n    </BoxBase>\n  )\n}\n\nBoxProgress.propTypes = {\n  allSuccess: PropTypes.bool.isRequired,\n  boxTransform: PropTypes.object.isRequired,\n  opacity: PropTypes.object.isRequired,\n  pending: PropTypes.number.isRequired,\n  transactionsStatus: PropTypes.arrayOf(\n    PropTypes.shape({\n      name: PropTypes.string.isRequired,\n      status: TransactionStatusType.isRequired,\n    })\n  ).isRequired,\n}\n\nfunction BoxReady({ onOpenOrg, opacity, boxTransform }) {\n  const { below } = useViewport()\n  const fullWidth = below('large')\n  const small = below('medium')\n\n  return (\n    <BoxBase opacity={opacity} boxTransform={boxTransform}>\n      <div\n        css={`\n          ${small ? textStyle('title1') : TITLE_ONBOARDING}\n          text-align: center;\n          padding: ${6 * GU}px ${small ? 6 * GU : 10 * GU}px;\n        `}\n      >\n        <img\n          src={allDoneImg}\n          alt=\"\"\n          width=\"253\"\n          height=\"206\"\n          css={`\n            width: ${fullWidth ? 230 : 253}px;\n            height: auto;\n          `}\n        />\n        <div\n          css={`\n            margin: ${6 * GU}px 0;\n          `}\n        >\n          <p>\n            <strong>All done!</strong>\n          </p>\n          <p css=\"font-weight: 400\">Your organization is ready</p>\n          <Button label=\"Get started\" mode=\"strong\" onClick={onOpenOrg} />\n        </div>\n      </div>\n    </BoxBase>\n  )\n}\n\nBoxReady.propTypes = {\n  onOpenOrg: PropTypes.func.isRequired,\n  opacity: PropTypes.object.isRequired,\n  boxTransform: PropTypes.object.isRequired,\n}\n\nconst Deployment = React.memo(function Deployment({\n  onOpenOrg,\n  ready,\n  transactionsStatus,\n}) {\n  // TODO: handle loading state for transactions\n  const { above } = useViewport()\n\n  // TODO: handle transaction error\n  const [pending, allSuccess] = useMemo(() => {\n    if (transactionsStatus.length === 0) {\n      return [0, false]\n    }\n    return [\n      transactionsStatus.findIndex(\n        ({ status }) => status === TRANSACTION_STATUS_PENDING\n      ),\n      transactionsStatus[transactionsStatus.length - 1].status ===\n        TRANSACTION_STATUS_SUCCESS,\n    ]\n  }, [transactionsStatus])\n\n  return (\n    <React.Fragment>\n      {above('large') && (\n        <div\n          css={`\n            width: ${41 * GU}px;\n            flex-shrink: 0;\n            flex-grow: 0;\n          `}\n        >\n          <DeploymentStepsPanel\n            allSuccess={allSuccess}\n            pending={pending}\n            transactionsStatus={transactionsStatus}\n          />\n        </div>\n      )}\n      <section\n        css={`\n          display: flex;\n          flex-direction: column;\n          width: 100%;\n          flex-grow: 1;\n          flex-shrink: 1;\n        `}\n      >\n        <div\n          css={`\n            display: flex;\n            flex-direction: column;\n            flex-grow: 1;\n            position: relative;\n            overflow: hidden;\n          `}\n        >\n          <Transition\n            native\n            reset\n            unique\n            items={ready}\n            from={{ opacity: 0, transform: `translate3d(10%, 0, 0)` }}\n            enter={{ opacity: 1, transform: `translate3d(0%, 0, 0)` }}\n            leave={{ opacity: 0, transform: `translate3d(-10%, 0, 0)` }}\n            config={springs.smooth}\n          >\n            {ready =>\n              /* eslint-disable react/prop-types */\n              ({ opacity, transform }) =>\n                ready ? (\n                  <BoxReady\n                    onOpenOrg={onOpenOrg}\n                    opacity={opacity}\n                    boxTransform={transform}\n                  />\n                ) : (\n                  <BoxProgress\n                    allSuccess={allSuccess}\n                    boxTransform={transform}\n                    opacity={opacity}\n                    pending={pending}\n                    transactionsStatus={transactionsStatus}\n                  />\n                )\n            /* eslint-enable react/prop-types */\n            }\n          </Transition>\n        </div>\n      </section>\n    </React.Fragment>\n  )\n})\n\nDeployment.propTypes = {\n  onOpenOrg: PropTypes.func.isRequired,\n  ready: PropTypes.bool.isRequired,\n  transactionsStatus: PropTypes.arrayOf(\n    PropTypes.shape({\n      name: PropTypes.string.isRequired,\n      status: TransactionStatusType.isRequired,\n    })\n  ).isRequired,\n}\n\nexport default Deployment\n","import React, { useCallback } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { GU, Modal, useTheme, useViewport, textStyle, Button } from '@aragon/ui'\nimport styled from 'styled-components'\n\nimport { getNetworkShortName, getNetworkFullName } from '../../../util/network'\nimport { networkConfigs } from '../../../network-config'\nimport { useWallet } from '../../../contexts/wallet'\n\nNetworkSwitchModal.propTypes = {\n  visible: PropTypes.bool.isRequired,\n  onClose: PropTypes.func.isRequired,\n}\n\nexport function NetworkSwitchModal({ onClose, visible }) {\n  const theme = useTheme()\n  const { below } = useViewport()\n  const smallMode = below('medium')\n  const { networkType } = useWallet()\n  const networkName = getNetworkFullName(networkType)\n\n  const modalWidth = useCallback(\n    ({ width }) => Math.min(72 * GU, width - 4 * GU),\n    []\n  )\n\n  return (\n    <Modal visible={visible} width={modalWidth} onClose={onClose}>\n      <Content smallMode={smallMode}>\n        <Header>\n          <Title>Select a Network</Title>\n          <Subtitle color={theme.contentSecondary}>\n            You are currently connected to the <b>{networkName}</b> network\n          </Subtitle>\n        </Header>\n        <Body>\n          <div>\n            <NetworkTitle>Mainnets</NetworkTitle>\n            <ButtonsRow\n              networkNames={Object.values(networkConfigs)\n                .filter(chain => !chain.settings.testnet && chain.isActive)\n                .map(chain => chain.settings.type)}\n              onClose={onClose}\n            />\n          </div>\n          <div>\n            <NetworkTitle>Testnets</NetworkTitle>\n            <ButtonsRow\n              networkNames={Object.values(networkConfigs)\n                .filter(chain => chain.settings.testnet && chain.isActive)\n                .map(chain => chain.settings.type)}\n              onClose={onClose}\n            />\n          </div>\n        </Body>\n      </Content>\n    </Modal>\n  )\n}\n\nButtonsRow.propTypes = {\n  networkNames: PropTypes.arrayOf(PropTypes.string).isRequired,\n  onClose: PropTypes.func.isRequired,\n}\n\nfunction ButtonsRow({ networkNames, onClose }) {\n  const { changeNetworkTypeDisconnected } = useWallet()\n\n  return (\n    <Row>\n      {networkNames.map(n => (\n        <FixWidthButton\n          key={n}\n          onClick={() => {\n            changeNetworkTypeDisconnected(n)\n            onClose()\n          }}\n        >\n          {getNetworkShortName(n)}\n        </FixWidthButton>\n      ))}\n    </Row>\n  )\n}\n\nconst Content = styled.section`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  padding: ${props => (props.smallMode ? 0 : 3 * GU)}px;\n  padding-top: ${props => (props.smallMode ? 5 * GU : 3 * GU)}px;\n  padding-bottom: ${props => (props.smallMode ? 0 : 2 * GU)}px;\n`\n\nconst Header = styled.header`\n  text-align: center;\n  padding-bottom: ${2 * GU}px;\n`\n\nconst Title = styled.h2`\n  max-width: ${35 * GU}px;\n  margin: 0 auto ${GU}px;\n  ${textStyle('title2')};\n`\n\nconst Subtitle = styled.p`\n  ${textStyle('body2')};\n  color: ${props => props.color};\n`\n\nconst Body = styled.div`\n  width: 100%;\n  padding-top: ${2 * GU}px;\n  padding-bottom: ${6 * GU}px;\n\n  & > div:not(:first-child) {\n    margin-top: ${6 * GU}px;\n  }\n`\n\nconst NetworkTitle = styled(Subtitle)`\n  max-width: unset;\n  font-weight: 700;\n  text-align: center;\n`\n\nconst Row = styled.div`\n  padding-top: ${GU}px;\n  justify-content: center;\n  display: flex;\n  flex-wrap: wrap;\n`\n\nconst FixWidthButton = styled(Button)`\n  width: ${18 * GU}px;\n  margin: ${1 * GU}px;\n`\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { useTheme, GU, IconCross, IconCheck } from '@aragon/ui'\n\nfunction CheckDisc({ mode, size }) {\n  const theme = useTheme()\n  const Icon = mode === 'error' ? IconCross : IconCheck\n  return (\n    <div\n      css={`\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: ${size}px;\n        height: ${size}px;\n        border-radius: 50%;\n        background: ${mode === 'error' ? theme.negative : theme.positive};\n        color: ${mode === 'error'\n          ? theme.negativeContent\n          : theme.positiveContent};\n      `}\n    >\n      <Icon width={size * 0.55} height={size * 0.55} />\n    </div>\n  )\n}\n\nCheckDisc.propTypes = {\n  mode: PropTypes.oneOf(['success', 'error']),\n  size: PropTypes.number,\n}\n\nCheckDisc.defaultProps = {\n  mode: 'success',\n  size: 3 * GU,\n}\n\nexport default CheckDisc\n","import React, { useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, Modal, textStyle, useTheme, useViewport } from '@aragon/ui'\nimport CheckDisc from '../../CheckDisc/CheckDisc'\n\nexport function ErrorModal({ action, content, header, onClose, visible }) {\n  const theme = useTheme()\n  const { below } = useViewport()\n  const smallMode = below('medium')\n\n  const modalWidth = useCallback(\n    ({ width }) => Math.min(55 * GU, width - 4 * GU),\n    []\n  )\n\n  return (\n    <Modal\n      visible={visible}\n      width={modalWidth}\n      onClose={onClose}\n      closeButton={Boolean(onClose)}\n    >\n      <section\n        css={`\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          padding: ${smallMode ? 0 : 3 * GU}px;\n          padding-top: ${smallMode ? 5 * GU : 8 * GU}px;\n          padding-bottom: ${smallMode ? 0 : 2 * GU}px;\n          text-align: center;\n        `}\n      >\n        <CheckDisc mode=\"error\" size={9 * GU} />\n        <h1\n          css={`\n            margin: ${5 * GU}px auto ${1 * GU}px;\n            ${textStyle('title2')};\n            font-weight: 600;\n          `}\n        >\n          {header}\n        </h1>\n        <div\n          css={`\n            margin-bottom: ${7 * GU}px;\n            ${textStyle('body1')};\n            color: ${theme.contentSecondary};\n          `}\n        >\n          {content}\n        </div>\n        {action}\n      </section>\n    </Modal>\n  )\n}\n\nErrorModal.propTypes = {\n  action: PropTypes.node,\n  content: PropTypes.node.isRequired,\n  header: PropTypes.node.isRequired,\n  onClose: PropTypes.func,\n  visible: PropTypes.bool.isRequired,\n}\n","import React, { useCallback, useEffect } from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  Button,\n  GU,\n  Link,\n  Modal,\n  textStyle,\n  useTheme,\n  useViewport,\n} from '@aragon/ui'\nimport providersImage from './assets/providers.png'\n\nexport function ConnectModal({ account, onClose, onConnect, visible }) {\n  const theme = useTheme()\n  const { below } = useViewport()\n  const smallMode = below('medium')\n\n  const modalWidth = useCallback(\n    ({ width }) => Math.min(55 * GU, width - 4 * GU),\n    []\n  )\n\n  useEffect(() => {\n    if (account) {\n      onConnect()\n    }\n  }, [account, onConnect])\n\n  return (\n    <Modal visible={visible} width={modalWidth} onClose={onClose}>\n      <section\n        css={`\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          padding: ${smallMode ? 0 : 3 * GU}px;\n          padding-top: ${smallMode ? 5 * GU : 3 * GU}px;\n          padding-bottom: ${smallMode ? 0 : 2 * GU}px;\n        `}\n      >\n        <header\n          css={`\n            text-align: center;\n          `}\n        >\n          <h1\n            css={`\n              max-width: ${35 * GU}px;\n              margin: 0 auto ${1 * GU}px;\n              ${textStyle('title1')};\n              font-weight: 600;\n            `}\n          >\n            Connect your account\n          </h1>\n          <p\n            css={`\n              max-width: ${35 * GU}px;\n              ${textStyle('body1')};\n              color: ${theme.contentSecondary};\n            `}\n          >\n            You need to connect your account to create an organization\n          </p>\n          <p\n            css={`\n              padding: ${3 * GU}px 0;\n              text-align: center;\n              color: ${theme.contentSecondary};\n            `}\n          >\n            <Link href=\"https://www.ethereum.org/use/#_3-what-is-a-wallet-and-which-one-should-i-use\">\n              What is a wallet?\n            </Link>\n          </p>\n        </header>\n        <div>\n          <img\n            width=\"296\"\n            height=\"80\"\n            src={providersImage}\n            alt=\"\"\n            css={`\n              display: block;\n              margin: 0 auto ${4 * GU}px;\n              width: ${smallMode ? 222 : 296}px;\n              height: auto;\n            `}\n          />\n        </div>\n        <Button label=\"Close\" mode=\"strong\" onClick={onClose} wide />\n      </section>\n    </Modal>\n  )\n}\n\nConnectModal.propTypes = {\n  visible: PropTypes.bool.isRequired,\n  onConnect: PropTypes.func.isRequired,\n  onClose: PropTypes.func.isRequired,\n  account: PropTypes.string,\n}\n","export { NetworkSwitchModal } from './NetworkSwitchModal/NetworkSwitchModal'\nexport { ErrorModal } from './ErrorModal/ErrorModal'\nexport { ConnectModal } from './ConnectModal/ConnectModal'\n","import { getWeb3Provider } from './util/web3'\n\nclass Web3Provider {\n  getProvider(networkType) {\n    if (networkType === this.networkType) {\n      return this.provider\n    }\n\n    if (this.provider && this.provider.connected) {\n      this.provider.disconnect()\n    }\n    this.networkType = networkType\n    this.provider = getWeb3Provider(networkType)\n    return this.provider\n  }\n}\n\nexport const web3Provider = new Web3Provider()\n","import React, { useContext, useMemo } from 'react'\nimport { useWallet } from '../contexts/wallet'\nimport { web3Provider } from '../Web3Provider'\n\nconst ClientWeb3Context = React.createContext()\n\nfunction ClientWeb3Provider(props) {\n  const { networkType } = useWallet()\n\n  const contextValue = useMemo(\n    () => ({\n      web3: web3Provider.getProvider(networkType),\n    }),\n    [networkType]\n  )\n\n  return <ClientWeb3Context.Provider value={contextValue} {...props} />\n}\n\nfunction useClientWeb3() {\n  return useContext(ClientWeb3Context)\n}\n\nexport { ClientWeb3Provider, useClientWeb3 }\n","import { useState, useEffect, useMemo } from 'react'\nimport { isEnsDomainAvailable } from './aragonjs-wrapper'\nimport { useClientWeb3 } from './contexts/ClientWeb3Context'\nimport { useWallet } from './contexts/wallet'\n\nconst DOMAIN_CHECK = Symbol('DOMAIN_CHECK')\nconst DOMAIN_LOADING = Symbol('DOMAIN_LOADING')\nconst DOMAIN_ERROR = Symbol('DOMAIN_ERROR')\nconst DOMAIN_NONE = Symbol('DOMAIN_NONE')\n\nfunction completeDomain(domain) {\n  return domain.endsWith('.eth') ? domain : `${domain}.aragonid.eth`\n}\n\nfunction useCheckDomain(domain, invertCheck = false) {\n  const [exists, setExists] = useState(false)\n  const [loading, setLoading] = useState(true)\n  const { networkType } = useWallet()\n  const { web3 } = useClientWeb3()\n\n  useEffect(() => {\n    setExists(false)\n    setLoading(true)\n\n    let cancelled = false\n\n    const check = async () => {\n      try {\n        const available = await isEnsDomainAvailable(\n          networkType,\n          web3,\n          completeDomain(domain)\n        )\n        if (!cancelled) {\n          setExists(available)\n          setLoading(false)\n        }\n      } catch (err) {\n        // retry every second\n        setTimeout(check, 1000)\n      }\n    }\n\n    // Only start checking after 300ms\n    setTimeout(() => {\n      if (!cancelled) {\n        check()\n      }\n    }, 300)\n\n    return () => {\n      cancelled = true\n    }\n  }, [domain, web3, networkType])\n\n  const domainStatus = useMemo(() => {\n    if (!domain) {\n      return DOMAIN_NONE\n    }\n    if (loading) {\n      return DOMAIN_LOADING\n    }\n    return invertCheck === exists ? DOMAIN_CHECK : DOMAIN_ERROR\n  }, [domain, exists, invertCheck, loading])\n\n  return domainStatus\n}\n\nexport {\n  DOMAIN_CHECK,\n  DOMAIN_ERROR,\n  DOMAIN_LOADING,\n  DOMAIN_NONE,\n  useCheckDomain,\n  completeDomain,\n}\n","import React, { useCallback, useEffect, useMemo, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport { Button } from '@aragon/ui'\nimport {\n  fetchApmArtifact,\n  getRecommendedGasLimit,\n} from '../../aragonjs-wrapper'\nimport { EthereumAddressType } from '../../prop-types'\nimport {\n  TRANSACTION_STATUS_ERROR,\n  TRANSACTION_STATUS_PENDING,\n  TRANSACTION_STATUS_SUCCESS,\n  TRANSACTION_STATUS_UPCOMING,\n} from '../../symbols'\nimport { log } from '../../util/utils'\nimport { getGasPrice } from '../../util/web3'\nimport {\n  loadTemplateState,\n  saveTemplateState,\n  prepareTransactionCreatorFromAbi,\n} from '../create-utils'\nimport Setup, { SETUP_MODE_CONFIGURE, SETUP_MODE_SELECT } from '../Setup/Setup'\nimport Deployment from '../Deployment/Deployment'\nimport { ErrorModal } from '../../components/Modals'\nimport {\n  STATUS_SELECT_TEMPLATE,\n  STATUS_TEMPLATE_SCREENS,\n  STATUS_DEPLOYMENT,\n} from './create-statuses'\nimport { useWallet } from '../../contexts/wallet'\nimport { getIpfsGateway } from '../../local-settings'\nimport { web3Provider } from '../../Web3Provider'\nimport { trackEvent, events } from '../../analytics'\nimport { completeDomain } from '../../check-domain'\n\nconst MAX_RETRY = 5\n\n// Used during the template selection phase, since we donâ€™t know yet what are\n// going to be the configuration steps.\nconst CONFIGURE_PLACEHOLDER_SCREENS = [\n  'Claim a name',\n  'Configure template',\n  'Review information',\n]\n\n// error messages\nconst ERROR_NETWORK = 'network'\nconst ERROR_TEMPLATE = 'template'\n\nconst ERRORS = Object.freeze({\n  [ERROR_NETWORK]: {\n    subject: 'Change of network detected',\n    details: 'Restart with the current network',\n  },\n  [ERROR_TEMPLATE]: { subject: 'Error getting template' },\n})\n\nfunction createError(type, details) {\n  const error = ERRORS[type]\n  error.details =\n    error.details === null || error.details === undefined\n      ? details\n      : error.details\n  return error\n}\n\nfunction getConfigureSteps(status, template, templateData) {\n  if (!template || status === STATUS_SELECT_TEMPLATE) {\n    return [\n      'Select template',\n      ...CONFIGURE_PLACEHOLDER_SCREENS,\n      'Launch organization',\n    ]\n  }\n  return [\n    template.name,\n    ...template.screens.map(([name]) =>\n      typeof name === 'function' ? name(templateData) : name\n    ),\n    'Launch organization',\n  ]\n}\n\nfunction getTemplateById(templates, templateId) {\n  return templates.find(template => template.id === templateId)\n}\n\n// Handle and store everything related to a template state.\nfunction useConfigureState(templates, onScreenUpdate, setError) {\n  const { networkType } = useWallet()\n\n  // The current template\n  const [template, setTemplate] = useState(null)\n\n  // The current screen in the template\n  const [templateScreenIndex, setTemplateScreenIndex] = useState(-1)\n\n  // The data stored by the configuration screens\n  const [templateData, setTemplateData] = useState({})\n\n  const updateTemplateScreen = useCallback(\n    (templateId, screenIndex = 0) => {\n      const template = getTemplateById(templates, templateId)\n      setTemplate(template)\n      setTemplateScreenIndex(screenIndex)\n      onScreenUpdate(screenIndex, template ? template.screens : [])\n    },\n    [templates, onScreenUpdate]\n  )\n\n  const selectTemplate = useCallback(\n    (templateId, optionalApps) => {\n      updateTemplateScreen(templateId, 0)\n      setTemplateData(data => ({\n        ...data,\n        optionalApps,\n      }))\n    },\n    [updateTemplateScreen]\n  )\n\n  useEffect(() => {\n    const {\n      networkType: templateNetworkType,\n      templateData,\n      templateId,\n      templateScreenIndex,\n    } = loadTemplateState()\n\n    if (templateNetworkType !== networkType) {\n      // If the network has changed in the middle of\n      // the creation workflow, we need to go back to the home\n      // page to re-validate account balance, ENS domain, etc again..\n      setError(createError(ERROR_NETWORK))\n    }\n\n    if (templateId) {\n      updateTemplateScreen(templateId, templateScreenIndex)\n      setTemplateData(templateData)\n    }\n  }, [updateTemplateScreen, setError, networkType])\n\n  // Save the template state\n  useEffect(() => {\n    if (template && template.id) {\n      saveTemplateState({\n        networkType,\n        templateData,\n        templateId: template.id,\n        templateScreenIndex,\n      })\n    }\n  }, [templateData, template, templateScreenIndex, networkType])\n\n  const relativeScreen = useCallback(\n    diff => {\n      const updatedScreenIndex = templateScreenIndex + diff\n\n      // Back to the templates selection\n      if (updatedScreenIndex < 0 || !template) {\n        setTemplateData({})\n        updateTemplateScreen(null, -1)\n        return\n      }\n\n      updateTemplateScreen(\n        template.id,\n        Math.min(template.screens.length, updatedScreenIndex)\n      )\n    },\n    [updateTemplateScreen, templateScreenIndex, template]\n  )\n\n  const prevScreen = useCallback(() => {\n    relativeScreen(-1)\n  }, [relativeScreen])\n\n  const nextScreen = useCallback(\n    (templateData = {}) => {\n      setTemplateData(templateData)\n      relativeScreen(1)\n    },\n    [relativeScreen]\n  )\n\n  const TemplateScreen = useMemo(() => {\n    return (\n      (template &&\n        template.screens[templateScreenIndex] &&\n        template.screens[templateScreenIndex][1]) ||\n      (() => null)\n    )\n  }, [template, templateScreenIndex])\n\n  return {\n    TemplateScreen,\n    nextScreen,\n    prevScreen,\n    selectTemplate,\n    setTemplateData,\n    template,\n    templateData,\n    templateScreenIndex,\n  }\n}\n\nfunction useTemplateRepoInformation(templateRepoAddress, setError) {\n  const [\n    fetchingTemplateInformation,\n    setFetchingTemplateInformation,\n  ] = useState(false)\n  const [templateAbi, setTemplateAbi] = useState(null)\n  const [templateAddress, setTemplateAddress] = useState(null)\n  const { networkType } = useWallet()\n\n  // Fetch latest information about the template from its aragonPM repository\n  useEffect(() => {\n    if (!templateRepoAddress) {\n      return\n    }\n\n    setFetchingTemplateInformation(true)\n\n    let timer\n    let cancelled = false\n    const fetchArtifact = (depth = 0) => {\n      const ipfsGateway = getIpfsGateway()\n      const web3 = web3Provider.getProvider(networkType)\n      fetchApmArtifact(web3, templateRepoAddress, ipfsGateway)\n        .then(templateInfo => {\n          if (!cancelled) {\n            log(`fetched template abi for ${templateRepoAddress}`)\n            setTemplateAddress(templateInfo.contractAddress)\n            setTemplateAbi(templateInfo.abi)\n            setFetchingTemplateInformation(false)\n          }\n          return null\n        })\n        .catch(err => {\n          // Continuously re-request until this component gets unmounted or the template changes\n          // add exponential backoff to avoid freezing up the site\n          if (!cancelled) {\n            if (depth > MAX_RETRY) {\n              setError(createError(ERROR_TEMPLATE, err.message))\n            } else {\n              const timeoutMs = 2 ** depth * 10\n              timer = setTimeout(() => fetchArtifact(depth + 1), timeoutMs)\n            }\n          }\n        })\n    }\n\n    fetchArtifact()\n\n    return () => {\n      cancelled = true\n      if (timer) {\n        clearTimeout(timer)\n      }\n    }\n  }, [networkType, setError, templateRepoAddress])\n\n  return {\n    fetchingTemplateInformation,\n    templateAbi,\n    templateAddress,\n  }\n}\n\nfunction useDeploymentState(\n  account,\n  applyEstimateGas,\n  attempts,\n  status,\n  template,\n  templateAbi,\n  templateAddress,\n  templateData,\n  walletWeb3\n) {\n  const { networkName } = useWallet()\n\n  const [transactionProgress, setTransactionProgress] = useState({\n    signing: 0,\n    error: -1,\n  })\n\n  const { networkType } = useWallet()\n\n  const deployTransactions = useMemo(\n    () =>\n      status === STATUS_DEPLOYMENT &&\n      templateAbi &&\n      templateAddress &&\n      walletWeb3\n        ? template.prepareTransactions(\n            prepareTransactionCreatorFromAbi(\n              walletWeb3,\n              templateAbi,\n              templateAddress\n            ),\n            templateData,\n            networkType\n          )\n        : null,\n    [\n      status,\n      templateAbi,\n      templateAddress,\n      template,\n      templateData,\n      walletWeb3,\n      networkType,\n    ]\n  )\n\n  // Call tx functions in the template, one after another.\n  useEffect(() => {\n    if (attempts === 0) {\n      setTransactionProgress({ signed: 0, errored: -1 })\n    } else {\n      setTransactionProgress(txProgress => ({ ...txProgress, errored: -1 }))\n    }\n\n    if (!deployTransactions) {\n      return\n    }\n\n    let cancelled = false\n    const createTransactions = async () => {\n      // Only process the next transaction after the previous one was successfully mined\n      deployTransactions\n        // If we're retrying, only retry from the last signed one\n        .slice(transactionProgress.signed)\n        .reduce(async (deployPromise, { transaction }) => {\n          // Wait for the previous promise; if component has unmounted, don't progress any further\n          await deployPromise\n\n          transaction = {\n            ...transaction,\n            from: account,\n          }\n          try {\n            transaction = await applyEstimateGas(transaction)\n          } catch (_) {}\n\n          if (!cancelled) {\n            try {\n              await walletWeb3.eth.sendTransaction(transaction)\n              if (!cancelled) {\n                // analytics\n                // we are only interested in the first tx of creating a DAO\n                if (\n                  transaction?.data ===\n                    deployTransactions[0]?.transaction?.data &&\n                  transactionProgress.signed === 0\n                ) {\n                  const daoEns = completeDomain(templateData.domain)\n\n                  trackEvent(events.DAO_CREATED, {\n                    network: networkName,\n                    template: template.name,\n                    dao_identifier: daoEns,\n                  })\n                }\n\n                setTransactionProgress(({ signed, errored }) => ({\n                  signed: signed + 1,\n                  errored,\n                }))\n              }\n            } catch (err) {\n              log('Failed onboarding transaction', err)\n\n              if (\n                transaction?.data ===\n                  deployTransactions[0]?.transaction?.data &&\n                transactionProgress.signed === 0\n              ) {\n                // analytics\n                trackEvent(events.DAO_CREATIONFAILED, {\n                  network: networkName,\n                  template: template.name,\n                  error: err.message || err.reason,\n                })\n              }\n\n              if (!cancelled) {\n                setTransactionProgress(({ signed, errored }) => ({\n                  errored: signed,\n                  signed,\n                }))\n              }\n\n              // Re-throw error to stop later transactions from being signed\n              throw err\n            }\n          }\n        }, Promise.resolve())\n    }\n    createTransactions()\n\n    return () => {\n      cancelled = true\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [walletWeb3, account, applyEstimateGas, deployTransactions, attempts])\n\n  const transactionsStatus = useMemo(() => {\n    if (!deployTransactions) {\n      return []\n    }\n\n    const { signed, errored } = transactionProgress\n    const status = index => {\n      if (errored !== -1 && index >= errored) {\n        return TRANSACTION_STATUS_ERROR\n      }\n      if (index === signed) {\n        return TRANSACTION_STATUS_PENDING\n      }\n      if (index < signed) {\n        return TRANSACTION_STATUS_SUCCESS\n      }\n      return TRANSACTION_STATUS_UPCOMING\n    }\n\n    return deployTransactions.map(({ name }, index) => ({\n      name,\n      status: status(index),\n    }))\n  }, [deployTransactions, transactionProgress])\n\n  return {\n    deployTransactions,\n    signedTransactions: transactionProgress.signed,\n    erroredTransactions: transactionProgress.errored,\n    transactionsStatus,\n  }\n}\n\nconst Create = React.memo(function Create({\n  account,\n  onOpenOrg,\n  goToHome,\n  templates,\n  walletWeb3,\n  web3,\n}) {\n  const [error, setError] = useState(null)\n  const [status, setStatus] = useState(STATUS_SELECT_TEMPLATE)\n  const { networkType } = useWallet()\n\n  const onScreenUpdate = useCallback((index, screens) => {\n    if (index > -1 && index < screens.length) {\n      setStatus(STATUS_TEMPLATE_SCREENS)\n      return\n    }\n    if (index === screens.length && screens.length > 0) {\n      setStatus(STATUS_DEPLOYMENT)\n      return\n    }\n    setStatus(STATUS_SELECT_TEMPLATE)\n  }, [])\n\n  const {\n    TemplateScreen,\n    nextScreen,\n    prevScreen,\n    selectTemplate,\n    template,\n    templateData,\n    templateScreenIndex,\n  } = useConfigureState(templates, onScreenUpdate, setError)\n\n  const configureSteps = getConfigureSteps(status, template, templateData)\n  const templateScreens = (template && template.screens) || []\n\n  // The current create step (includes the template selection\n  // and â€œlaunch organizationâ€).\n  const configureStepIndex = useMemo(() => {\n    if (status === STATUS_SELECT_TEMPLATE) {\n      return 0\n    }\n    if (status === STATUS_DEPLOYMENT) {\n      return configureSteps.length - 1\n    }\n    return templateScreenIndex + 1\n  }, [status, configureSteps.length, templateScreenIndex])\n\n  const {\n    fetchingTemplateInformation,\n    templateAbi,\n    templateAddress,\n  } = useTemplateRepoInformation(template && template.repoAddress, setError)\n\n  const applyEstimateGas = useCallback(\n    async transaction => {\n      const estimatedGas = await web3.eth.estimateGas(transaction)\n      const recommendedLimit = await getRecommendedGasLimit(\n        web3,\n        estimatedGas,\n        { gasFuzzFactor: 1.1 }\n      )\n      const recommendedPrice = await getGasPrice(networkType)\n      return {\n        ...transaction,\n        gas: recommendedLimit,\n        gasPrice: recommendedPrice,\n      }\n    },\n    [web3, networkType]\n  )\n\n  const [attempts, setAttempts] = useState(0)\n\n  const {\n    deployTransactions,\n    erroredTransactions,\n    signedTransactions,\n    transactionsStatus,\n  } = useDeploymentState(\n    account,\n    applyEstimateGas,\n    attempts,\n    status,\n    template,\n    templateAbi,\n    templateAddress,\n    templateData,\n    walletWeb3\n  )\n\n  const handleUseTemplate = useCallback(\n    (id, optionalApps) => {\n      selectTemplate(id, optionalApps)\n    },\n    [selectTemplate]\n  )\n\n  const handleTemplateNext = useCallback(\n    data => {\n      nextScreen(data)\n\n      // analytics\n      trackEvent(events.DAO_CREATION_NEXT_CLICKED, {\n        network: networkType,\n        wallet_address: account,\n        dao_identifier: data.domain,\n        step: configureSteps[configureStepIndex],\n        settings: data,\n      })\n    },\n    [nextScreen, configureStepIndex, configureSteps, networkType, account]\n  )\n  const handleTemplatePrev = useCallback(() => prevScreen(), [prevScreen])\n\n  const handleOpenNewOrg = useCallback(() => {\n    if (templateData && templateData.domain) {\n      onOpenOrg(templateData.domain)\n    }\n  }, [templateData, onOpenOrg])\n\n  return (\n    <div\n      css={`\n        display: flex;\n        width: 100%;\n        min-height: 100%;\n        flex-grow: 1;\n      `}\n    >\n      {status === STATUS_DEPLOYMENT ? (\n        <Deployment\n          loadingTransactions={fetchingTemplateInformation}\n          onOpenOrg={handleOpenNewOrg}\n          ready={\n            Array.isArray(deployTransactions) &&\n            deployTransactions.length > 0 &&\n            signedTransactions === deployTransactions.length\n          }\n          transactionsStatus={transactionsStatus}\n        />\n      ) : (\n        <Setup\n          mode={\n            status === STATUS_SELECT_TEMPLATE\n              ? SETUP_MODE_SELECT\n              : SETUP_MODE_CONFIGURE\n          }\n          TemplateScreen={TemplateScreen}\n          onNextTemplateScreen={handleTemplateNext}\n          onPrevTemplateScreen={handleTemplatePrev}\n          onUseTemplate={handleUseTemplate}\n          screens={templateScreens}\n          status={status}\n          stepIndex={configureStepIndex}\n          steps={configureSteps}\n          templateData={templateData}\n          templateScreenIndex={templateScreenIndex}\n          templates={templates}\n        />\n      )}\n      <ErrorModal\n        action={\n          <Button mode=\"strong\" onClick={() => setAttempts(a => a + 1)}>\n            OK, letâ€™s try again\n          </Button>\n        }\n        content={\n          <p>\n            An error has occurred during the signature process. Don't worry, you\n            can try to send the transaction again.\n          </p>\n        }\n        header=\"Something went wrong\"\n        visible={erroredTransactions > -1}\n      />\n      {error && (\n        <ErrorModal\n          action={\n            <Button mode=\"strong\" onClick={goToHome}>\n              Start over\n            </Button>\n          }\n          content={error.details}\n          header={error.subject}\n          visible\n        />\n      )}\n    </div>\n  )\n})\n\nCreate.propTypes = {\n  account: EthereumAddressType,\n  onOpenOrg: PropTypes.func.isRequired,\n  goToHome: PropTypes.func.isRequired,\n  templates: PropTypes.array.isRequired,\n  walletWeb3: PropTypes.object,\n  web3: PropTypes.object,\n}\n\nexport default Create\n","import React, { useContext } from 'react'\nimport PropTypes from 'prop-types'\nimport { Subject } from 'rxjs'\n\nconst identityEventTypes = {\n  IMPORT: 'IMPORT',\n  MODIFY: 'MODIFY',\n  REMOVE: 'REMOVE',\n}\n\n// An events subject\n// { type: '<string>', address: <string> }\nconst identityEvents$ = new Subject()\n\nconst IdentityContext = React.createContext({\n  resolve: () =>\n    Promise.reject(Error('Please set resolve using IdentityProvider')),\n})\n\nfunction IdentityProvider({ onResolve, children }) {\n  return (\n    <IdentityContext.Provider value={{ resolve: onResolve, identityEvents$ }}>\n      {children}\n    </IdentityContext.Provider>\n  )\n}\n\nIdentityProvider.propTypes = {\n  onResolve: PropTypes.func.isRequired,\n  children: PropTypes.node.isRequired,\n}\n\nconst IdentityConsumer = IdentityContext.Consumer\n\nconst useIdentity = () => useContext(IdentityContext)\n\nexport {\n  IdentityProvider,\n  IdentityConsumer,\n  IdentityContext,\n  identityEventTypes,\n  useIdentity,\n}\n","export default {\n  enter: 13,\n  esc: 27,\n  up: 38,\n  left: 37,\n  down: 40,\n  right: 39,\n}\n","import {\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useState,\n  useRef,\n  useContext,\n} from 'react'\nimport {\n  IdentityContext,\n  identityEventTypes,\n} from './components/IdentityManager/IdentityManager'\nimport keycodes from './keycodes'\nimport { log, removeStartingSlash } from './util/utils'\nimport { addressesEqual } from './util/web3'\n\n// Update `now` at a given interval.\nexport function useNow(updateEvery = 1000) {\n  const [now, setNow] = useState(new Date())\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setNow(new Date())\n    }, updateEvery)\n    return () => {\n      clearInterval(timer)\n    }\n  }, [updateEvery])\n  return now\n}\n\n// Handle arrow keys.\nexport function useArrows({ onUp, onLeft, onDown, onRight } = {}) {\n  useEffect(() => {\n    const actions = [\n      [keycodes.up, onUp],\n      [keycodes.left, onLeft],\n      [keycodes.down, onDown],\n      [keycodes.right, onRight],\n    ]\n    const onKeyDown = e => {\n      for (const [keyCode, cb] of actions) {\n        if (cb && e.keyCode === keyCode) {\n          e.preventDefault()\n          cb()\n          break\n        }\n      }\n    }\n    document.addEventListener('keydown', onKeyDown)\n    return () => {\n      document.removeEventListener('keydown', onKeyDown)\n    }\n  }, [onUp, onLeft, onDown, onRight])\n}\n\nfunction stepsReducer(state, { type, value, steps }) {\n  const { step } = state\n  const stepsCount = steps - 1\n\n  let newStep = null\n\n  if (type === 'set') {\n    newStep = value\n  }\n  if (type === 'next' && step < stepsCount) {\n    newStep = step + 1\n  }\n  if (type === 'prev' && step > 0) {\n    newStep = step - 1\n  }\n  if (type === 'adjustSize') {\n    newStep = step <= stepsCount ? step : stepsCount\n  }\n\n  if (newStep !== null && step !== newStep) {\n    return {\n      step: newStep,\n      direction: newStep > step ? 1 : -1,\n    }\n  }\n\n  return state\n}\n\n// Simple hook to manage a given number of steps.\nexport function useSteps(steps) {\n  const [{ step, direction }, updateStep] = useReducer(stepsReducer, {\n    step: 0,\n    direction: 0,\n  })\n\n  // If the number of steps change, we need to remember the current step\n  // or use the closest value available\n  useEffect(() => {\n    updateStep({ type: 'adjustSize', steps })\n  }, [steps])\n\n  const setStep = useCallback(\n    value => {\n      updateStep({ type: 'set', value, steps })\n    },\n    [steps]\n  )\n\n  const next = useCallback(() => {\n    updateStep({ type: 'next', steps })\n  }, [steps])\n\n  const prev = useCallback(() => {\n    updateStep({ type: 'prev', steps })\n  }, [steps])\n\n  return {\n    direction,\n    next,\n    prev,\n    setStep,\n    step,\n  }\n}\n\nexport function usePromise(fn, memoParams, defaultValue) {\n  const [result, setResult] = useState(defaultValue)\n  useEffect(() => {\n    let cancelled = false\n    fn()\n      .then(value => {\n        if (!cancelled) {\n          setResult(value)\n        }\n        return null\n      })\n      .catch(e => console.error('An error occured: ', e))\n    return () => {\n      cancelled = true\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [...memoParams, fn])\n  return result\n}\n\nexport function useRepoDetails(baseUrl, detailsUrl) {\n  const fetchDescription = async () => {\n    try {\n      const raw = await fetch(`${baseUrl}${removeStartingSlash(detailsUrl)}`)\n      return raw.text()\n    } catch (e) {\n      log('Error fetching decription: ', e)\n    }\n    return ''\n  }\n  return usePromise(fetchDescription, [detailsUrl], null)\n}\n\nexport function useEsc(cb) {\n  const handlekeyDown = useCallback(\n    e => {\n      if (e.keyCode === keycodes.esc) {\n        cb()\n      }\n    },\n    [cb]\n  )\n  useEffect(() => {\n    window.addEventListener('keydown', handlekeyDown)\n    return () => window.removeEventListener('keydown', handlekeyDown)\n  }, [handlekeyDown])\n}\n\nexport function useSelected(initial) {\n  const [selected, setSelected] = useState(initial)\n  const [allSelected, someSelected] = useMemo(\n    () => [\n      Array.from(selected.values()).every(Boolean),\n      Array.from(selected.values()).some(Boolean),\n    ],\n    [selected]\n  )\n  return { selected, setSelected, allSelected, someSelected }\n}\n\n/* eslint-disable react-hooks/rules-of-hooks */\nexport function useClickOutside(cb, ref = useRef()) {\n  /* eslint-enable react-hooks/rules-of-hooks */\n  const handleClick = useCallback(\n    e => {\n      if (!ref.current.contains(e.target)) {\n        cb()\n      }\n    },\n    [cb, ref]\n  )\n\n  useEffect(() => {\n    document.addEventListener('click', handleClick, true)\n    return () => {\n      document.removeEventListener('click', handleClick, true)\n    }\n  }, [handleClick])\n\n  return { ref }\n}\n\n/* eslint-disable react-hooks/rules-of-hooks */\nexport function useOnBlur(cb, ref = useRef()) {\n  /* eslint-enable react-hooks/rules-of-hooks */\n  const handleBlur = useCallback(\n    e => {\n      // when event is triggered by click relatedTarget is null\n      // when another element is gaining focus then it holds some value\n      if (e.relatedTarget && !ref.current.contains(e.relatedTarget)) {\n        cb()\n      }\n    },\n    [cb, ref]\n  )\n\n  return { ref, handleBlur }\n}\n\n/* eslint-disable react-hooks/rules-of-hooks */\nexport function useArrowKeysFocus(query, containerRef = useRef()) {\n  /* eslint-enable react-hooks/rules-of-hooks */\n  const [highlightedIndex, setHighlightedIndex] = useState(-1)\n\n  const reset = () => setHighlightedIndex(-1)\n  const cycleFocus = useCallback(\n    (e, change) => {\n      e.preventDefault()\n      const elements = document.querySelectorAll(query)\n      let next = highlightedIndex + change\n      if (next > elements.length - 1) {\n        next = 0\n      }\n      if (next < 0) {\n        next = elements.length - 1\n      }\n      if (!elements[next]) {\n        next = -1\n      }\n      setHighlightedIndex(next)\n    },\n    [highlightedIndex, query]\n  )\n  const handleKeyDown = useCallback(\n    e => {\n      const { keyCode } = e\n      if (keyCode === keycodes.up || keyCode === keycodes.down) {\n        cycleFocus(e, keyCode === keycodes.up ? -1 : 1)\n      }\n    },\n    [cycleFocus]\n  )\n\n  const { handleBlur: handleContainerBlur } = useOnBlur(reset, containerRef)\n  useEffect(() => {\n    if (highlightedIndex === -1) {\n      return\n    }\n    const elements = document.querySelectorAll(query)\n    if (!elements[highlightedIndex]) {\n      return\n    }\n    elements[highlightedIndex].focus()\n  }, [highlightedIndex, query])\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown)\n    return () => document.removeEventListener('keydown', handleKeyDown)\n  }, [handleKeyDown])\n\n  return { containerRef, handleContainerBlur }\n}\n\nexport function useLocalIdentity(entity) {\n  const { resolve, identityEvents$ } = useContext(IdentityContext)\n  const [name, setName] = useState(null)\n\n  // TODO: stop exporting this function as it is not cancellable from the outside.\n  const handleResolve = useCallback(async () => {\n    try {\n      const { name = null } = (await resolve(entity)) || {}\n      setName(name)\n    } catch (e) {\n      // address does not resolve to identity\n    }\n  }, [resolve, entity])\n\n  const handleRemove = useCallback(\n    addresses => {\n      if (addresses.some(address => addressesEqual(entity, address))) {\n        setName(null)\n      }\n    },\n    [entity]\n  )\n\n  useEffect(() => {\n    let cancelled = false\n\n    const updateEntityName = async () => {\n      try {\n        const resolved = await resolve(entity)\n        if (!cancelled) {\n          setName((resolved && resolved.name) || null)\n        }\n      } catch (err) {\n        if (!cancelled) {\n          setName(null)\n        }\n      }\n    }\n\n    const subscription = identityEvents$.subscribe(event => {\n      switch (event.type) {\n        case identityEventTypes.MODIFY:\n          if (addressesEqual(entity, event.address)) {\n            updateEntityName()\n          }\n          return\n        case identityEventTypes.IMPORT:\n          return updateEntityName()\n        case identityEventTypes.REMOVE:\n          return handleRemove(event.addresses)\n      }\n    })\n\n    updateEntityName()\n\n    return () => {\n      cancelled = true\n      subscription.unsubscribe()\n    }\n  }, [identityEvents$, resolve, entity, handleRemove])\n\n  return { name, handleResolve }\n}\n\nexport function useMatchMedia(query) {\n  const [matches, setMatches] = useState(false)\n\n  const mq = useMemo(() => window.matchMedia(query), [query])\n\n  useEffect(() => {\n    const fn = ({ matches }) => setMatches(matches)\n    mq.addListener(fn)\n    return () => mq.removeListener(fn)\n  }, [mq, query])\n\n  return matches\n}\n\nexport function usePrefersDarkMode() {\n  return useMatchMedia('(prefers-color-scheme: dark)')\n}\n","export const STATUS_CONNECTION_ERROR = Symbol('STATUS_CONNECTION_ERROR')\nexport const STATUS_CONNECTION_HEALTHY = Symbol('STATUS_CONNECTION_HEALTHY')\nexport const STATUS_CONNECTION_WARNING = Symbol('STATUS_CONNECTION_WARNING')\n\nexport const STATUS_WALLET_CONNECTION_DROPPED = Symbol(\n  'STATUS_WALLET_CONNECTION_DROPPED'\n)\nexport const STATUS_CLIENT_CONNECTION_DROPPED = Symbol(\n  'STATUS_CLIENT_CONNECTION_DROPPED'\n)\nexport const STATUS_NETWORK_SYNC_ISSUES = Symbol('STATUS_NETWORK_SYNC_ISSUES')\nexport const STATUS_MAJOR_NETWORK_SLOWDOWN = Symbol(\n  'STATUS_MAJOR_NETWORK_SLOWDOWN'\n)\nexport const STATUS_TOO_LITTLE_ETH = Symbol('STATUS_TOO_LITTLE_ETH')\nexport const STATUS_CONNECTION_OK = Symbol('STATUS_CONNECTION_OK')\n","import {\n  STATUS_CONNECTION_ERROR,\n  STATUS_CONNECTION_WARNING,\n} from './connection-statuses'\n\nexport const DROPPED_PROVIDER_SYNC_DELAY = 45\nexport const MAX_PROVIDER_SYNC_DELAY = 30\nexport const MILD_PROVIDER_SYNC_DELAY = 5\nexport const OK_PROVIDER_SYNC_DELAY = 3\n\nexport function getConnectionMessage(\n  connectionStatus,\n  listening,\n  online,\n  clientNetworkName\n) {\n  const connectionMessage =\n    connectionStatus === STATUS_CONNECTION_ERROR || !listening || !online\n      ? 'No connection'\n      : connectionStatus === STATUS_CONNECTION_WARNING\n      ? 'Syncing issues'\n      : `Connected to ${clientNetworkName}`\n  return connectionMessage\n}\n","import { useEffect, useState, useMemo } from 'react'\nimport { useTheme } from '@aragon/ui'\nimport BN from 'bn.js'\nimport {\n  STATUS_CLIENT_CONNECTION_DROPPED,\n  STATUS_CONNECTION_OK,\n  STATUS_CONNECTION_ERROR,\n  STATUS_CONNECTION_HEALTHY,\n  STATUS_CONNECTION_WARNING,\n  STATUS_MAJOR_NETWORK_SLOWDOWN,\n  STATUS_NETWORK_SYNC_ISSUES,\n  STATUS_TOO_LITTLE_ETH,\n  STATUS_WALLET_CONNECTION_DROPPED,\n} from './connection-statuses'\nimport {\n  MAX_PROVIDER_SYNC_DELAY,\n  MILD_PROVIDER_SYNC_DELAY,\n  OK_PROVIDER_SYNC_DELAY,\n} from './utils'\nimport { pollEvery } from '../../util/utils'\nimport {\n  useWallet,\n  ChainUnsupportedError,\n  WALLET_STATUS,\n} from '../../contexts/wallet'\nimport { getWeb3, getLatestBlockTimestamp } from '../../util/web3'\nimport {\n  getNetworkSettings,\n  normalizeNetworkName,\n  getNetworkFullName,\n} from '../../util/network'\nimport { useClientWeb3 } from '../../contexts/ClientWeb3Context'\n\nconst BLOCK_TIMESTAMP_POLL_INTERVAL = 60000\n\nexport function useNetworkConnectionData() {\n  const { networkType, status, error } = useWallet()\n\n  const isWrongNetwork = useMemo(() => {\n    return (\n      status === WALLET_STATUS.error && error instanceof ChainUnsupportedError\n    )\n  }, [status, error])\n\n  return {\n    walletNetworkName: normalizeNetworkName(networkType),\n    walletNetworkFullName: getNetworkFullName(networkType),\n    isWrongNetwork,\n  }\n}\n\nexport function useWalletConnectionDetails(\n  clientListening,\n  walletListening,\n  clientOnline,\n  walletOnline,\n  clientSyncDelay,\n  walletSyncDelay\n) {\n  const {\n    walletNetworkName,\n    walletNetworkFullName,\n    isWrongNetwork,\n  } = useNetworkConnectionData()\n\n  const theme = useTheme()\n  const { networkType } = useWallet()\n  const networkSettings = getNetworkSettings(networkType)\n\n  const isWalletAndClientSynced =\n    Math.abs(walletSyncDelay - clientSyncDelay) <= OK_PROVIDER_SYNC_DELAY\n  const networkSlowdown =\n    walletSyncDelay >= MILD_PROVIDER_SYNC_DELAY &&\n    clientSyncDelay >= MILD_PROVIDER_SYNC_DELAY &&\n    isWalletAndClientSynced\n\n  const defaultOkConnectionDetails = {\n    connectionMessage: `Connected to ${walletNetworkName}`,\n    connectionMessageLong: `Connected to ${walletNetworkFullName} Network`,\n    connectionColor: theme.positive,\n  }\n\n  if (clientListening && !networkSettings.live) {\n    return defaultOkConnectionDetails\n  }\n\n  if (\n    !clientListening ||\n    !walletListening ||\n    !clientOnline ||\n    !walletOnline ||\n    networkSlowdown ||\n    clientSyncDelay >= MAX_PROVIDER_SYNC_DELAY ||\n    walletSyncDelay >= MAX_PROVIDER_SYNC_DELAY\n  ) {\n    return {\n      connectionMessage: 'No connection',\n      connectionMessageLong: 'No connection',\n      connectionColor: theme.negative,\n    }\n  } else if (\n    walletSyncDelay >= OK_PROVIDER_SYNC_DELAY ||\n    clientSyncDelay >= OK_PROVIDER_SYNC_DELAY\n  ) {\n    return {\n      connectionMessage: 'Syncing issues',\n      connectionMessageLong: 'Syncing issues',\n      connectionColor: theme.warning,\n    }\n  } else if (isWrongNetwork) {\n    return {\n      connectionMessage: 'Wrong network',\n      connectionMessageLong: 'Wrong network',\n      connectionColor: theme.warning,\n    }\n  }\n\n  return defaultOkConnectionDetails\n}\n\nexport function useSyncInfo(wantedWeb3 = 'default') {\n  const wallet = useWallet()\n  const { web3: clientWeb3 } = useClientWeb3()\n  const walletWeb3 = wallet.web3\n  const selectedWeb3 =\n    wantedWeb3 === 'wallet' ? walletWeb3 : getWeb3(clientWeb3)\n  const [isListening, setIsListening] = useState(true)\n  const [isOnline, setIsOnline] = useState(window.navigator.onLine)\n  const [connectionStatus, setConnectionStatus] = useState(\n    STATUS_CONNECTION_HEALTHY\n  )\n  const [syncDelay, setSyncDelay] = useState(0)\n\n  // listen to web3 connection drop due to inactivity\n  useEffect(() => {\n    if (!selectedWeb3 || !selectedWeb3.currentProvider) {\n      return\n    }\n    let cancel = false\n    const handleWebsocketDrop = () => {\n      if (!cancel) {\n        setIsListening(false)\n        setConnectionStatus(STATUS_CONNECTION_ERROR)\n      }\n    }\n    if (selectedWeb3.currentProvider.on) {\n      selectedWeb3.currentProvider.on('error', handleWebsocketDrop)\n    }\n    return () => {\n      cancel = true\n      if (selectedWeb3.currentProvider.connection?.removeEventListener) {\n        selectedWeb3.currentProvider.connection.removeEventListener(\n          'error',\n          handleWebsocketDrop\n        )\n      }\n    }\n  }, [selectedWeb3])\n\n  // check for connection loss from the browser\n  useEffect(() => {\n    const goOnline = () => setIsOnline(true)\n    const goOffline = () => {\n      setIsOnline(false)\n      setConnectionStatus(STATUS_CONNECTION_ERROR)\n    }\n    window.addEventListener('online', goOnline)\n    window.addEventListener('offline', goOffline)\n\n    return () => {\n      window.removeEventListener('online', goOnline)\n      window.removeEventListener('offline', goOffline)\n    }\n  }, [])\n\n  // listen for connection status with block timestamps\n  useEffect(() => {\n    if (!selectedWeb3) {\n      return\n    }\n    let cancel = false\n    const pollBlockTimestamp = pollEvery(\n      () => ({\n        request: async () => {\n          if (!cancel) {\n            return getLatestBlockTimestamp(selectedWeb3).catch(err => {\n              if (!cancel) {\n                console.error('Get latest block timestamp', err)\n                setIsListening(false)\n                setConnectionStatus(STATUS_CONNECTION_ERROR)\n              }\n              return 0\n            })\n          }\n        },\n        onResult: timestamp => {\n          if (!cancel) {\n            const now = new Date()\n            const blockDiff = now - timestamp\n            const latestBlockDifference = Math.floor(blockDiff / 1000 / 60)\n            const connectionHealth =\n              latestBlockDifference >= 30\n                ? STATUS_CONNECTION_ERROR\n                : latestBlockDifference >= 3\n                ? STATUS_CONNECTION_WARNING\n                : STATUS_CONNECTION_HEALTHY\n            setConnectionStatus(connectionHealth)\n            setSyncDelay(latestBlockDifference)\n            if (connectionHealth === STATUS_CONNECTION_HEALTHY) {\n              setIsListening(true)\n            }\n          }\n        },\n      }),\n      BLOCK_TIMESTAMP_POLL_INTERVAL\n    )\n    const cleanUpTimestampPoll = pollBlockTimestamp()\n    return () => {\n      cancel = true\n      cleanUpTimestampPoll()\n    }\n  }, [selectedWeb3])\n  return {\n    connectionStatus,\n    isListening,\n    isOnline,\n    syncDelay,\n  }\n}\n\nexport function useSyncState(\n  clientListening,\n  walletListening,\n  clientOnline,\n  clientSyncDelay,\n  walletSyncDelay\n) {\n  const { balance, getBlockNumber, networkType } = useWallet()\n  const currentBlock = getBlockNumber()\n\n  const minimumTransactionBalance = new BN(0.005)\n\n  const defaultSyncedStatus = {\n    header: 'Synced',\n    info: currentBlock ? `: current block ${currentBlock}` : '',\n    status: STATUS_CONNECTION_OK,\n  }\n\n  const networkSettings = getNetworkSettings(networkType)\n\n  if (clientListening && !networkSettings.live) {\n    return defaultSyncedStatus\n  }\n\n  if (!clientOnline || !clientListening) {\n    return {\n      header: '',\n      info: '',\n      status: STATUS_CLIENT_CONNECTION_DROPPED,\n    }\n  }\n\n  if (!walletListening) {\n    return {\n      header: '',\n      info: '',\n      status: STATUS_WALLET_CONNECTION_DROPPED,\n    }\n  }\n\n  if (clientSyncDelay >= 30 && walletSyncDelay >= 30) {\n    return {\n      header: 'Last known state',\n      info: `: ${clientSyncDelay} min behind`,\n      status: STATUS_MAJOR_NETWORK_SLOWDOWN,\n    }\n  }\n\n  if (clientSyncDelay >= 3 || walletSyncDelay >= 3) {\n    return {\n      header: 'Out of sync',\n      info: `: ${clientSyncDelay} min behind`,\n      status: STATUS_NETWORK_SYNC_ISSUES,\n    }\n  }\n\n  if (balance.lt(minimumTransactionBalance) && balance.gtn(-1)) {\n    return {\n      header: 'Synced',\n      info: currentBlock ? `:current block ${currentBlock}` : '',\n      status: STATUS_TOO_LITTLE_ETH,\n    }\n  }\n\n  return defaultSyncedStatus\n}\n","import React, { useEffect, useState, useRef } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, Popover, springs, textStyle, useTheme } from '@aragon/ui'\nimport { Spring, Transition, animated } from 'react-spring'\n\nconst AnimatedDiv = animated.div\n\nfunction AccountModulePopover({\n  children,\n  direction,\n  heading,\n  onClose,\n  onOpen,\n  opener,\n  screenData,\n  screenId,\n  screenKey,\n  visible,\n}) {\n  const theme = useTheme()\n  const [animate, setAnimate] = useState(false)\n  const [height, setHeight] = useState(30 * GU)\n  const [measuredHeight, setMeasuredHeight] = useState(true)\n\n  // Prevents to lose the focus on the popover when a screen leaves while an\n  // element inside is focused (e.g. when clicking on the â€œdisconnectâ€ button).\n  const popoverFocusElement = useRef()\n  useEffect(() => {\n    if (popoverFocusElement.current) {\n      popoverFocusElement.current.focus()\n    }\n  }, [screenId])\n\n  // Donâ€™t animate the slider until the popover has opened\n  useEffect(() => {\n    let timer\n\n    setAnimate(false)\n\n    if (visible) {\n      timer = setTimeout(() => {\n        setAnimate(true)\n      }, 0)\n    }\n\n    return () => clearTimeout(timer)\n  }, [visible])\n\n  return (\n    <Popover\n      closeOnOpenerFocus\n      onClose={onClose}\n      opener={opener}\n      placement=\"bottom-end\"\n      visible={visible}\n      css={`\n        width: ${51 * GU}px;\n      `}\n    >\n      <section\n        css={`\n          display: flex;\n          flex-direction: column;\n          overflow: hidden;\n        `}\n      >\n        <h1\n          css={`\n            display: flex;\n            flex-grow: 0;\n            flex-shrink: 0;\n            align-items: center;\n            height: ${4 * GU}px;\n            padding-left: ${2 * GU}px;\n            border-bottom: 1px solid ${theme.border};\n            color: ${theme.contentSecondary};\n            ${textStyle('label2')};\n          `}\n        >\n          {heading}\n        </h1>\n        <Spring\n          config={springs.smooth}\n          from={{ height: 32 * GU }}\n          to={{ height }}\n          immediate={!animate}\n          native\n        >\n          {({ height }) => (\n            <AnimatedDiv\n              ref={popoverFocusElement}\n              tabIndex=\"0\"\n              style={{ height: measuredHeight ? height : 'auto' }}\n              css={`\n                position: relative;\n                flex-grow: 1;\n                width: 100%;\n                overflow: hidden;\n                outline: 0;\n              `}\n            >\n              <Transition\n                native\n                config={springs.smooth}\n                items={screenData}\n                keys={screenKey}\n                from={{\n                  opacity: 0,\n                  transform: `translate3d(${3 * GU * direction}px, 0, 0)`,\n                }}\n                enter={{ opacity: 1, transform: `translate3d(0, 0, 0)` }}\n                leave={{\n                  opacity: 0,\n                  transform: `translate3d(${3 * GU * -direction}px, 0, 0)`,\n                }}\n                immediate={!animate}\n                onRest={(_, status) => {\n                  if (status === 'update') {\n                    setMeasuredHeight(false)\n                  }\n                }}\n                onStart={(_, status) => {\n                  setMeasuredHeight(true)\n                }}\n              >\n                {screenData => /* eslint-disable react/prop-types */ ({\n                  opacity,\n                  transform,\n                }) => (\n                  <AnimatedDiv\n                    ref={elt => {\n                      if (elt) {\n                        setHeight(elt.clientHeight)\n                      }\n                    }}\n                    style={{ opacity, transform }}\n                    css={`\n                      position: ${measuredHeight ? 'absolute' : 'static'};\n                      top: 0;\n                      left: 0;\n                      right: 0;\n                    `}\n                  >\n                    {children(screenData)}\n                  </AnimatedDiv>\n                ) /* eslint-enable react/prop-types */}\n              </Transition>\n            </AnimatedDiv>\n          )}\n        </Spring>\n      </section>\n    </Popover>\n  )\n}\n\nAccountModulePopover.propTypes = {\n  children: PropTypes.func.isRequired,\n  direction: PropTypes.oneOf([-1, 1]).isRequired,\n  heading: PropTypes.node.isRequired,\n  onClose: PropTypes.func.isRequired,\n  onOpen: PropTypes.func.isRequired,\n  opener: PropTypes.any,\n  screenData: PropTypes.object.isRequired,\n  screenId: PropTypes.string.isRequired,\n  screenKey: PropTypes.func.isRequired,\n  visible: PropTypes.bool.isRequired,\n}\n\nexport default AccountModulePopover\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Button, GU, IconConnect, useViewport } from '@aragon/ui'\n\nconst ButtonConnect = React.forwardRef(function ButtonConnect(\n  { onClick },\n  ref\n) {\n  const { below } = useViewport()\n\n  return (\n    <Button\n      innerRef={ref}\n      display={below('medium') ? 'icon' : 'all'}\n      icon={<IconConnect />}\n      label=\"Connect account\"\n      onClick={onClick}\n      css={`\n        min-width: ${5 * GU}px;\n        margin: 0 ${2 * GU}px;\n      `}\n    />\n  )\n})\n\nButtonConnect.propTypes = {\n  onClick: PropTypes.func.isRequired,\n}\n\nexport default ButtonConnect\n","import React, { useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  ButtonBase,\n  EthIdenticon,\n  GU,\n  IconDown,\n  RADIUS,\n  textStyle,\n  useTheme,\n  useViewport,\n} from '@aragon/ui'\nimport { shortenAddress, getEmptyAddress } from '../../util/web3'\nimport { useWallet } from '../../contexts/wallet'\n\nconst ButtonAccount = React.forwardRef(function ButtonAccount(\n  { connectionColor, connectionMessage, isWrongNetwork, label, onClick },\n  ref\n) {\n  const theme = useTheme()\n  const wallet = useWallet()\n  const { above } = useViewport()\n\n  const walletAccount = useMemo(() => {\n    return wallet.account || getEmptyAddress()\n  }, [wallet.account])\n\n  return (\n    <ButtonBase\n      ref={ref}\n      onClick={onClick}\n      css={`\n        display: flex;\n        align-items: center;\n        height: 100%;\n        padding: 0 ${1 * GU}px;\n        &:active {\n          background: ${theme.surfacePressed};\n        }\n      `}\n    >\n      <div\n        css={`\n          display: flex;\n          align-items: center;\n          text-align: left;\n          padding: 0 ${1 * GU}px 0 ${2 * GU}px;\n        `}\n      >\n        <div css=\"position: relative\">\n          <EthIdenticon address={walletAccount} radius={RADIUS} />\n          <div\n            css={`\n              position: absolute;\n              bottom: -3px;\n              right: -3px;\n              width: 10px;\n              height: 10px;\n              background: ${connectionColor};\n              border: 2px solid ${theme.surface};\n              border-radius: 50%;\n            `}\n          />\n        </div>\n        {above('medium') && (\n          <React.Fragment>\n            <div\n              css={`\n                padding-left: ${1 * GU}px;\n                padding-right: ${0.5 * GU}px;\n              `}\n            >\n              <div\n                css={`\n                  margin-bottom: -5px;\n                  ${textStyle('body2')}\n                `}\n              >\n                {label ? (\n                  <div\n                    css={`\n                      overflow: hidden;\n                      max-width: ${16 * GU}px;\n                      text-overflow: ellipsis;\n                      white-space: nowrap;\n                    `}\n                  >\n                    {label}\n                  </div>\n                ) : (\n                  <div>{shortenAddress(walletAccount)}</div>\n                )}\n              </div>\n              <div\n                css={`\n                  font-size: 11px; /* doesnâ€™t exist in aragonUI */\n                  color: ${connectionColor};\n                `}\n              >\n                {isWrongNetwork ? 'Wrong network' : connectionMessage}\n              </div>\n            </div>\n\n            <IconDown\n              size=\"small\"\n              css={`\n                color: ${theme.surfaceIcon};\n              `}\n            />\n          </React.Fragment>\n        )}\n      </div>\n    </ButtonBase>\n  )\n})\nButtonAccount.propTypes = {\n  connectionColor: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.instanceOf(String),\n  ]).isRequired,\n  connectionMessage: PropTypes.string.isRequired,\n  isWrongNetwork: PropTypes.bool.isRequired,\n  label: PropTypes.string,\n  onClick: PropTypes.func.isRequired,\n}\n\nexport default ButtonAccount\n","import React, { useCallback, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { ButtonBase, GU, Link, RADIUS, useTheme, textStyle } from '@aragon/ui'\nimport { getProviderFromUseWalletId } from 'use-wallet'\nimport { connectors } from '../../ethereum-providers/connectors'\n\nfunction ProviderButton({ id, provider, onActivate }) {\n  const theme = useTheme()\n\n  const handleClick = useCallback(() => {\n    onActivate(id)\n  }, [onActivate, id])\n\n  return (\n    <ButtonBase\n      key={id}\n      onClick={handleClick}\n      css={`\n        position: relative;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        width: 100%;\n        height: ${12 * GU}px;\n        background: ${theme.surface};\n        box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.15);\n        border-radius: ${RADIUS}px;\n        &:active {\n          top: 1px;\n          box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1);\n        }\n      `}\n    >\n      <img src={provider.image} alt=\"\" height={5.25 * GU} />\n      <div\n        css={`\n          margin-top: ${1 * GU}px;\n          ${textStyle('body1')};\n        `}\n      >\n        {provider.name}\n      </div>\n    </ButtonBase>\n  )\n}\nProviderButton.propTypes = {\n  id: PropTypes.string.isRequired,\n  onActivate: PropTypes.func.isRequired,\n  provider: PropTypes.shape({\n    image: PropTypes.string.isRequired,\n    name: PropTypes.string.isRequired,\n  }).isRequired,\n}\n\nfunction AccountModuleProvidersScreen({ onActivate }) {\n  const providersInfo = useMemo(() => {\n    return connectors.map(provider => [\n      provider.id,\n      getProviderFromUseWalletId(provider.id),\n    ])\n  }, [])\n\n  return (\n    <div>\n      <div\n        css={`\n          display: grid;\n          grid-gap: ${1.5 * GU}px;\n          grid-auto-flow: row;\n          grid-template-columns: repeat(2, 1fr);\n          padding: ${2 * GU}px;\n        `}\n      >\n        {providersInfo.map(([id, provider]) => (\n          <ProviderButton\n            key={id}\n            id={id}\n            provider={provider}\n            onActivate={onActivate}\n          />\n        ))}\n      </div>\n      <div\n        css={`\n          display: flex;\n          justify-content: center;\n          padding: 0 ${2 * GU}px ${1 * GU}px;\n        `}\n      >\n        <Link href=\"https://ethereum.org/wallets/\" css=\"text-decoration: none\">\n          Donâ€™t have an account?\n        </Link>\n      </div>\n    </div>\n  )\n}\nAccountModuleProvidersScreen.propTypes = {\n  onActivate: PropTypes.func.isRequired,\n}\n\nexport default AccountModuleProvidersScreen\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { keyframes } from 'styled-components'\nimport { GU, useTheme, textStyle, Link } from '@aragon/ui'\nimport { useWallet } from '../../contexts/wallet'\n\nimport loadingRing from './assets/loading-ring.svg'\n\nconst spin = keyframes`\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n`\n\nfunction AccountModuleConnectingScreen({ onCancel, providerId }) {\n  const theme = useTheme()\n  const { providerInfo } = useWallet()\n\n  return (\n    <section\n      css={`\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        padding: ${2 * GU}px;\n        height: 100%;\n      `}\n    >\n      <div\n        css={`\n          flex-grow: 1;\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          justify-content: center;\n          text-align: center;\n        `}\n      >\n        <div\n          css={`\n            position: relative;\n            width: ${10.5 * GU}px;\n            height: ${10.5 * GU}px;\n          `}\n        >\n          <div\n            css={`\n              position: absolute;\n              top: 0;\n              left: 0;\n              right: 0;\n              bottom: 0;\n              background: url(${loadingRing}) no-repeat 0 0;\n              animation-duration: 1s;\n              animation-iteration-count: infinite;\n              animation-timing-function: linear;\n              animation-name: ${spin};\n              // prevents flickering on Firefox\n              backface-visibility: hidden;\n            `}\n          />\n          <div\n            css={`\n              position: absolute;\n              top: 0;\n              left: 0;\n              right: 0;\n              bottom: 0;\n              background: 50% 50% / auto ${5 * GU}px no-repeat\n                url(${providerInfo?.image});\n            `}\n          />\n        </div>\n        <h1\n          css={`\n            padding-top: ${2 * GU}px;\n            ${textStyle('body1')};\n            font-weight: 600;\n          `}\n        >\n          Connecting to {providerInfo?.name || 'Unknown'}\n        </h1>\n        <p\n          css={`\n            width: ${36 * GU}px;\n            color: ${theme.surfaceContentSecondary};\n          `}\n        >\n          Log into {providerInfo?.name || 'Unknown'}. You may be temporarily\n          redirected to a new screen.\n        </p>\n      </div>\n      <div\n        css={`\n          flex-grow: 0;\n        `}\n      >\n        <Link onClick={onCancel}>Cancel</Link>\n      </div>\n    </section>\n  )\n}\n\nAccountModuleConnectingScreen.propTypes = {\n  providerId: PropTypes.string,\n  onCancel: PropTypes.func.isRequired,\n}\n\nexport default AccountModuleConnectingScreen\n","import {DT, suppressDTWarnings} from \"./DT\";\n\n// Debug log strings should be short, since they are compiled into the production build.\n// TODO: Compile debug logging code out of production builds?\n// tslint:disable-next-line: no-empty\nlet debugLog: (s: string) => void = (s: string) => {};\nlet showWarnings = true;\n// Workaround for:\n// - IE9 (can't bind console functions directly), and\n// - Edge Issue #14495220 (referencing `console` without F12 Developer Tools can cause an exception)\nfunction warnOrLog() {\n  // tslint:disable-next-line: no-console\n  (console.warn || console.log).apply(console, arguments);\n}\nconst warn = warnOrLog.bind(\"[clipboard-polyfill]\");\n\nconst TEXT_PLAIN = \"text/plain\";\n\nexport {DT};\n\nexport function setDebugLog(f: (s: string) => void): void {\n  debugLog = f;\n}\n\nexport function suppressWarnings() {\n  showWarnings = false;\n  suppressDTWarnings();\n}\n\nexport async function write(data: DT): Promise<void> {\n  if (showWarnings && !data.getData(TEXT_PLAIN)) {\n    warn(\"clipboard.write() was called without a \" +\n      \"`text/plain` data type. On some platforms, this may result in an \" +\n      \"empty clipboard. Call clipboard.suppressWarnings() \" +\n      \"to suppress this warning.\");\n  }\n\n  // Internet Explorer\n  if (seemToBeInIE()) {\n    if (writeIE(data)) {\n      return;\n    } else {\n      throw new Error(\"Copying failed, possibly because the user rejected it.\");\n    }\n  }\n\n  if (execCopy(data)) {\n    debugLog(\"regular execCopy worked\");\n    return;\n  }\n\n  // Success detection on Edge is not possible, due to bugs in all 4\n  // detection mechanisms we could try to use. Assume success.\n  if (navigator.userAgent.indexOf(\"Edge\") > -1) {\n    debugLog(\"UA \\\"Edge\\\" => assuming success\");\n    return;\n  }\n\n  // Fallback 1 for desktop Safari.\n  if (copyUsingTempSelection(document.body, data)) {\n    debugLog(\"copyUsingTempSelection worked\");\n    return;\n  }\n\n  // Fallback 2 for desktop Safari.\n  if (copyUsingTempElem(data)) {\n    debugLog(\"copyUsingTempElem worked\");\n    return;\n  }\n\n  // Fallback for iOS Safari.\n  const text = data.getData(TEXT_PLAIN);\n  if (text !== undefined && copyTextUsingDOM(text)) {\n    debugLog(\"copyTextUsingDOM worked\");\n    return;\n  }\n\n  throw new Error(\"Copy command failed.\");\n}\n\nexport async function writeText(s: string): Promise<void> {\n  if (navigator.clipboard && navigator.clipboard.writeText) {\n    debugLog(\"Using `navigator.clipboard.writeText()`.\");\n    return navigator.clipboard.writeText(s);\n  }\n  return write(DTFromText(s));\n}\n\nexport async function read(): Promise<DT> {\n  return DTFromText(await readText());\n}\n\nexport async function readText(): Promise<string> {\n  if (navigator.clipboard && navigator.clipboard.readText) {\n    debugLog(\"Using `navigator.clipboard.readText()`.\");\n    return navigator.clipboard.readText();\n  }\n  if (seemToBeInIE()) {\n    debugLog(\"Reading text using IE strategy.\");\n    return readIE();\n  }\n  throw new Error(\"Read is not supported in your browser.\");\n}\n\nlet useStarShown = false;\nfunction useStar(): void {\n  if (useStarShown) {\n    return;\n  }\n  if (showWarnings) {\n    warn(\"The deprecated default object of `clipboard-polyfill` was called. Please switch to `import * as clipboard from \\\"clipboard-polyfill\\\"` and see https://github.com/lgarron/clipboard-polyfill/issues/101 for more info.\");\n  }\n  useStarShown = true;\n}\n\nconst ClipboardPolyfillDefault = {\n  DT,\n  setDebugLog(f: (s: string) => void): void {\n    useStar();\n    return setDebugLog(f);\n  },\n  suppressWarnings() {\n    useStar();\n    return suppressWarnings();\n  },\n  async write(data: DT): Promise<void> {\n    useStar();\n    return write(data);\n  },\n  async writeText(s: string): Promise<void> {\n    useStar();\n    return writeText(s);\n  },\n  async read(): Promise<DT> {\n    useStar();\n    return read();\n  },\n  async readText(): Promise<string> {\n    useStar();\n    return readText();\n  },\n};\n\nexport default ClipboardPolyfillDefault;\n\n/******** Implementations ********/\n\nclass FallbackTracker {\n  public success: boolean = false;\n}\n\nfunction copyListener(tracker: FallbackTracker, data: DT, e: ClipboardEvent): void {\n  debugLog(\"listener called\");\n  tracker.success = true;\n  data.forEach((value: string, key: string) => {\n    const clipboardData = e.clipboardData!;\n    clipboardData.setData(key, value);\n    if (key === TEXT_PLAIN && clipboardData.getData(key) !== value) {\n      debugLog(\"setting text/plain failed\");\n      tracker.success = false;\n    }\n  });\n  e.preventDefault();\n}\n\nfunction execCopy(data: DT): boolean {\n  const tracker = new FallbackTracker();\n  const listener = copyListener.bind(this, tracker, data);\n\n  document.addEventListener(\"copy\", listener);\n  try {\n    // We ignore the return value, since FallbackTracker tells us whether the\n    // listener was called. It seems that checking the return value here gives\n    // us no extra information in any browser.\n    document.execCommand(\"copy\");\n  } finally {\n    document.removeEventListener(\"copy\", listener);\n  }\n  return tracker.success;\n}\n\n// Temporarily select a DOM element, so that `execCommand()` is not rejected.\nfunction copyUsingTempSelection(e: HTMLElement, data: DT): boolean {\n  selectionSet(e);\n  const success = execCopy(data);\n  selectionClear();\n  return success;\n}\n\n// Create a temporary DOM element to select, so that `execCommand()` is not\n// rejected.\nfunction copyUsingTempElem(data: DT): boolean {\n  const tempElem = document.createElement(\"div\");\n  // Setting an individual property does not support `!important`, so we set the\n  // whole style instead of just the `-webkit-user-select` property.\n  tempElem.setAttribute(\"style\", \"-webkit-user-select: text !important\");\n  // Place some text in the elem so that Safari has something to select.\n  tempElem.textContent = \"temporary element\";\n  document.body.appendChild(tempElem);\n\n  const success = copyUsingTempSelection(tempElem, data);\n\n  document.body.removeChild(tempElem);\n  return success;\n}\n\n// Uses shadow DOM.\nfunction copyTextUsingDOM(str: string): boolean {\n  debugLog(\"copyTextUsingDOM\");\n\n  const tempElem = document.createElement(\"div\");\n  // Setting an individual property does not support `!important`, so we set the\n  // whole style instead of just the `-webkit-user-select` property.\n  tempElem.setAttribute(\"style\", \"-webkit-user-select: text !important\");\n  // Use shadow DOM if available.\n  let spanParent: Node = tempElem;\n  if (tempElem.attachShadow) {\n    debugLog(\"Using shadow DOM.\");\n    spanParent = tempElem.attachShadow({mode: \"open\"});\n  }\n\n  const span = document.createElement(\"span\");\n  span.innerText = str;\n\n  spanParent.appendChild(span);\n  document.body.appendChild(tempElem);\n  selectionSet(span);\n\n  const result = document.execCommand(\"copy\");\n\n  selectionClear();\n  document.body.removeChild(tempElem);\n\n  return result;\n}\n\n/******** Selection ********/\n\nfunction selectionSet(elem: Element): void {\n  const sel = document.getSelection();\n  if (sel) {\n    const range = document.createRange();\n    range.selectNodeContents(elem);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n}\n\nfunction selectionClear(): void {\n  const sel = document.getSelection();\n  if (sel) {\n    sel.removeAllRanges();\n  }\n}\n\n/******** Convenience ********/\n\nfunction DTFromText(s: string): DT {\n  const dt = new DT();\n  dt.setData(TEXT_PLAIN, s);\n  return dt;\n}\n\n/******** Internet Explorer ********/\n\ninterface IEWindow extends Window {\n  clipboardData: {\n    setData: (key: string, value: string) => boolean;\n    // Always results in a string: https://msdn.microsoft.com/en-us/library/ms536436(v=vs.85).aspx\n    getData: (key: string) => string;\n  };\n}\n\nfunction seemToBeInIE(): boolean {\n  return typeof ClipboardEvent === \"undefined\" &&\n         typeof (window as IEWindow).clipboardData !== \"undefined\" &&\n         typeof (window as IEWindow).clipboardData.setData !== \"undefined\";\n}\n\nfunction writeIE(data: DT): boolean {\n  // IE supports text or URL, but not HTML: https://msdn.microsoft.com/en-us/library/ms536744(v=vs.85).aspx\n  // TODO: Write URLs to `text/uri-list`? https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Recommended_drag_types\n  const text = data.getData(TEXT_PLAIN);\n  if (text !== undefined) {\n    return (window as IEWindow).clipboardData.setData(\"Text\", text);\n  }\n\n  throw new Error((\"No `text/plain` value was specified.\"));\n}\n\n// Returns \"\" if the read failed, e.g. because the user rejected the permission.\nasync function readIE(): Promise<string> {\n  const text = (window as IEWindow).clipboardData.getData(\"Text\");\n  if (text === \"\") {\n    throw new Error(\"Empty clipboard or could not read plain text from clipboard\");\n  }\n  return text;\n}\n","const dataTypes = [\n  \"text/plain\",\n  \"text/html\",\n];\n\n// TODO: Dedup with main file?\nfunction warnOrLog() {\n  // tslint:disable-next-line: no-console\n  (console.warn || console.log).call(arguments);\n} // IE9 workaround (can't bind console functions).\nconst warn = warnOrLog.bind(console, \"[clipboard-polyfill]\");\nlet showWarnings = true;\nexport function suppressDTWarnings() {\n  showWarnings = false;\n}\n\nexport class DT {\n  private m: {[key: string]: string} = {};\n\n  public setData(type: string, value: string): void {\n    if (showWarnings && dataTypes.indexOf(type) === -1) {\n      warn(\"Unknown data type: \" + type, \"Call clipboard.suppressWarnings() \" +\n        \"to suppress this warning.\");\n    }\n\n    this.m[type] = value;\n  }\n\n  public getData(type: string): string | undefined {\n    return this.m[type];\n  }\n\n  // TODO: Provide an iterator consistent with DataTransfer.\n  public forEach(f: (value: string, key: string) => void): void {\n    // tslint:disable-next-line: forin\n    for (const k in this.m) {\n      f(this.m[k], k);\n    }\n  }\n}\n","import { useToast } from '@aragon/ui'\nimport * as clipboard from 'clipboard-polyfill'\n\nexport function useCopyToClipboard(payload, toastText) {\n  const toast = useToast()\n  return () => {\n    clipboard.writeText(payload)\n    toastText && toast(toastText)\n  }\n}\n","import React, { useCallback, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, Link } from '@aragon/ui'\nimport { useRouting } from '../../routing'\nimport {\n  STATUS_CLIENT_CONNECTION_DROPPED,\n  STATUS_CONNECTION_OK,\n  STATUS_MAJOR_NETWORK_SLOWDOWN,\n  STATUS_NETWORK_SYNC_ISSUES,\n  STATUS_TOO_LITTLE_ETH,\n  STATUS_WALLET_CONNECTION_DROPPED,\n} from './connection-statuses'\nimport { useWallet } from '../../contexts/wallet'\nimport { getNetworkFullName, isOnEthMainnet } from '../../util/network'\n\nfunction WalletSyncedInfo({ header, info, status }) {\n  return (\n    <React.Fragment>\n      {header && (\n        <div\n          css={`\n            margin-top: ${1 * GU}px;\n          `}\n        >\n          <span\n            css={`\n              padding-right: ${1 * GU}px;\n              opacity: 0.8;\n            `}\n          >\n            {header}\n          </span>\n          <span>{info}</span>\n        </div>\n      )}\n      {status !== STATUS_CONNECTION_OK && (\n        <div\n          css={`\n            margin: ${1 * GU}px 0;\n          `}\n        >\n          <ConnectionInfoMessage connectionStatus={status} />\n        </div>\n      )}\n    </React.Fragment>\n  )\n}\n\nWalletSyncedInfo.propTypes = {\n  header: PropTypes.string,\n  info: PropTypes.string,\n  status: PropTypes.oneOf([\n    STATUS_CLIENT_CONNECTION_DROPPED,\n    STATUS_CONNECTION_OK,\n    STATUS_MAJOR_NETWORK_SLOWDOWN,\n    STATUS_NETWORK_SYNC_ISSUES,\n    STATUS_TOO_LITTLE_ETH,\n    STATUS_WALLET_CONNECTION_DROPPED,\n  ]),\n}\n\nfunction ConnectionInfoMessage({ connectionStatus }) {\n  const routing = useRouting()\n  const { networkType } = useWallet()\n  const networkName = useMemo(() => getNetworkFullName(networkType), [\n    networkType,\n  ])\n\n  const handleNetworkSettingsClick = useCallback(() => {\n    routing.update(locator => ({\n      ...locator,\n      preferences: { section: 'network' },\n    }))\n  }, [routing])\n\n  if (connectionStatus === STATUS_WALLET_CONNECTION_DROPPED) {\n    return (\n      <span>\n        We were unable to fetch network information from your wallet. You may\n        not be able to send transactions. Please contact your wallet for support\n        if this issue persists.\n      </span>\n    )\n  }\n\n  if (\n    isOnEthMainnet(networkType) &&\n    connectionStatus === STATUS_CLIENT_CONNECTION_DROPPED\n  ) {\n    return (\n      <span>\n        We cannot connect to the wallet's Ethereum node. You can change the node\n        settings in\n        <Link onClick={handleNetworkSettingsClick}>Network Settings.</Link>\n        You can also refresh the client.\n      </span>\n    )\n  }\n\n  if (connectionStatus === STATUS_NETWORK_SYNC_ISSUES) {\n    return (\n      <span>\n        Your wallet may not accurately reflect the current state of{' '}\n        {networkName}. Please contact your wallet for support if this issue\n        persists.\n      </span>\n    )\n  }\n\n  if (connectionStatus === STATUS_MAJOR_NETWORK_SLOWDOWN) {\n    return (\n      <span>\n        The {networkName} may be experiencing a global slowdown. Please avoid\n        signing any transactions until this error is resolved.\n      </span>\n    )\n  }\n\n  if (connectionStatus === STATUS_TOO_LITTLE_ETH) {\n    return (\n      <span>\n        You may not have enough ETH in your account to send any transactions.\n      </span>\n    )\n  }\n\n  return null\n}\n\nConnectionInfoMessage.propTypes = {\n  connectionStatus: PropTypes.oneOf([\n    STATUS_CLIENT_CONNECTION_DROPPED,\n    STATUS_CONNECTION_OK,\n    STATUS_MAJOR_NETWORK_SLOWDOWN,\n    STATUS_NETWORK_SYNC_ISSUES,\n    STATUS_TOO_LITTLE_ETH,\n    STATUS_WALLET_CONNECTION_DROPPED,\n  ]),\n}\n\nexport default WalletSyncedInfo\n","import React, { useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\nimport {\n  Button,\n  ButtonBase,\n  GU,\n  IconCheck,\n  IconCopy,\n  IconCross,\n  IdentityBadge,\n  RADIUS,\n  textStyle,\n  useTheme,\n} from '@aragon/ui'\nimport { EthereumAddressType, EthereumProviderType } from '../../prop-types'\nimport { useCopyToClipboard } from '../../copy-to-clipboard'\nimport { useWallet } from '../../contexts/wallet'\nimport {\n  useNetworkConnectionData,\n  useSyncState,\n  useWalletConnectionDetails,\n} from './connection-hooks'\nimport WalletSyncedInfo from './WalletSyncedInfo'\nimport { trackEvent, events } from '../../analytics'\n\nfunction AccountModuleConnectedScreen({\n  account,\n  clientListening,\n  clientOnline,\n  clientSyncDelay,\n  providerInfo,\n  walletListening,\n  walletOnline,\n  walletSyncDelay,\n}) {\n  const wallet = useWallet()\n  const theme = useTheme()\n\n  const {\n    walletNetworkName,\n    walletNetworkFullName,\n    isWrongNetwork,\n  } = useNetworkConnectionData()\n\n  const copyAddress = useCopyToClipboard(account, 'Address copied')\n\n  const { header, info, status } = useSyncState(\n    clientListening,\n    walletListening,\n    clientOnline,\n    clientSyncDelay,\n    walletSyncDelay\n  )\n  const { connectionMessage, connectionColor } = useWalletConnectionDetails(\n    clientListening,\n    walletListening,\n    clientOnline,\n    walletOnline,\n    clientSyncDelay,\n    walletSyncDelay,\n    walletNetworkName\n  )\n\n  const handleDisconnect = useCallback(() => {\n    // analytics test\n    trackEvent(events.WALLET_DISCONNECTED, {\n      wallet_address: wallet.account,\n      wallet_provider: wallet.providerInfo.name,\n      network: wallet.networkType,\n    })\n\n    wallet.reset()\n  }, [wallet])\n\n  const Icon = connectionColor !== theme.positive ? IconCross : IconCheck\n\n  const formattedConnectionMessage = connectionMessage.includes('Connected')\n    ? `Connected to ${walletNetworkFullName} Network`\n    : connectionMessage\n\n  return (\n    <div\n      css={`\n        padding: ${2 * GU}px;\n      `}\n    >\n      <FlexWrapper\n        css={`\n          width: 100%;\n        `}\n      >\n        <FlexWrapper\n          css={`\n            margin-right: ${3 * GU}px;\n          `}\n        >\n          <img\n            src={providerInfo.image}\n            alt=\"\"\n            css={`\n              width: ${2.5 * GU}px;\n              height: ${2.5 * GU}px;\n              margin-right: ${0.5 * GU}px;\n              transform: translateY(-2px);\n            `}\n          />\n          <span>{providerInfo.name}</span>\n        </FlexWrapper>\n        <FlexWrapper\n          css={`\n            width: 100%;\n            justify-content: flex-end;\n          `}\n        >\n          <ButtonBase\n            onClick={copyAddress}\n            focusRingRadius={RADIUS}\n            css={`\n              display: flex;\n              align-items: center;\n              justify-self: flex-end;\n              padding: ${0.5 * GU}px;\n              &:active {\n                background: ${theme.surfacePressed};\n              }\n            `}\n          >\n            <IdentityBadge\n              entity={account}\n              compact\n              badgeOnly\n              css=\"cursor: pointer\"\n            />\n            <IconCopy\n              css={`\n                color: ${theme.hint};\n              `}\n            />\n          </ButtonBase>\n        </FlexWrapper>\n      </FlexWrapper>\n      <FlexWrapper\n        css={`\n          display: flex;\n          margin-top: ${1 * GU}px;\n          color: ${connectionColor};\n          ${textStyle('label2')};\n        `}\n      >\n        <Icon size=\"small\" />\n        {walletNetworkName && (\n          <span\n            css={`\n              margin-left: ${0.5 * GU}px;\n            `}\n          >\n            {formattedConnectionMessage}\n          </span>\n        )}\n      </FlexWrapper>\n\n      {isWrongNetwork ? (\n        <div\n          css={`\n            margin-top: ${1 * GU}px;\n          `}\n        >\n          Network error, please contact Aragon.\n        </div>\n      ) : (\n        <WalletSyncedInfo header={header} info={info} status={status} />\n      )}\n\n      <Button\n        onClick={handleDisconnect}\n        wide\n        css={`\n          margin-top: ${1 * GU}px;\n        `}\n      >\n        Disconnect wallet\n      </Button>\n    </div>\n  )\n}\n\nAccountModuleConnectedScreen.propTypes = {\n  account: EthereumAddressType,\n  clientListening: PropTypes.bool,\n  clientOnline: PropTypes.bool,\n  clientSyncDelay: PropTypes.number,\n  providerInfo: EthereumProviderType,\n  walletListening: PropTypes.bool,\n  walletOnline: PropTypes.bool,\n  walletSyncDelay: PropTypes.number,\n}\n\nconst FlexWrapper = styled.div`\n  display: inline-flex;\n  align-items: center;\n`\n\nexport default AccountModuleConnectedScreen\n","import React, { useMemo, useRef } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, Link, textStyle, useTheme } from '@aragon/ui'\nimport { ChainUnsupportedError } from '../../contexts/wallet'\nimport { useNetworkConfig } from '../../network-config'\nimport connectionError from './assets/connection-error.png'\n\nfunction AccountModuleErrorScreen({ error, onBack }) {\n  const theme = useTheme()\n  const elementRef = useRef()\n  const { settings: network } = useNetworkConfig()\n\n  const [title, secondary] = useMemo(() => {\n    if (error instanceof ChainUnsupportedError) {\n      return [\n        'Wrong network',\n        `Please select the ${network.shortName} network in your wallet and try again.`,\n      ]\n    }\n    return ['Failed to enable your account', 'You can try another wallet.']\n  }, [error, network])\n\n  return (\n    <section\n      ref={elementRef}\n      css={`\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        padding: ${2 * GU}px;\n        height: 100%;\n      `}\n    >\n      <div\n        css={`\n          flex-grow: 1;\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          justify-content: center;\n          text-align: center;\n        `}\n      >\n        <div\n          css={`\n            position: relative;\n            width: 281px;\n            height: 188px;\n            background: 50% 50% / 100% 100% no-repeat url(${connectionError});\n          `}\n        />\n        <h1\n          css={`\n            padding-top: ${2 * GU}px;\n            ${textStyle('body1')};\n            font-weight: 600;\n          `}\n        >\n          {title}\n        </h1>\n        <p\n          css={`\n            width: ${36 * GU}px;\n            color: ${theme.surfaceContentSecondary};\n          `}\n        >\n          {secondary}\n        </p>\n      </div>\n      <div\n        css={`\n          flex-grow: 0;\n        `}\n      >\n        <Link onClick={onBack}>OK, try again</Link>\n      </div>\n    </section>\n  )\n}\n\nAccountModuleErrorScreen.propTypes = {\n  onBack: PropTypes.func.isRequired,\n  error: PropTypes.instanceOf(Error),\n}\n\nexport default AccountModuleErrorScreen\n","import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { useWallet, WALLET_STATUS } from '../../contexts/wallet'\nimport { useLocalIdentity } from '../../hooks'\nimport {\n  useNetworkConnectionData,\n  useSyncInfo,\n  useWalletConnectionDetails,\n} from './connection-hooks'\nimport AccountModulePopover from './AccountModulePopover'\nimport ButtonConnect from './ButtonConnect'\nimport ButtonAccount from './ButtonAccount'\n\nimport ProvidersScreen from './AccountModuleProvidersScreen'\nimport ConnectingScreen from './AccountModuleConnectingScreen'\nimport ConnectedScreen from './AccountModuleConnectedScreen'\nimport ErrorScreen from './AccountModuleErrorScreen'\n\nconst SCREEN_ID = Object.freeze({\n  providers: WALLET_STATUS.providers,\n  connecting: WALLET_STATUS.connecting,\n  connected: WALLET_STATUS.connected,\n  error: WALLET_STATUS.error,\n})\n\nconst SCREENS = [\n  { id: SCREEN_ID.providers, title: 'Use account from' },\n  { id: SCREEN_ID.connecting, title: 'Use account from' },\n  { id: SCREEN_ID.connected, title: 'Active account' },\n  { id: SCREEN_ID.error, title: 'Connection error' },\n]\n\nfunction AccountModule() {\n  const [opened, setOpened] = useState(false)\n  const [activatingDelayed, setActivatingDelayed] = useState(null)\n  const buttonRef = useRef()\n  const wallet = useWallet()\n\n  const { account, error, status, providerInfo } = wallet\n\n  const open = useCallback(() => setOpened(true), [])\n  const toggle = useCallback(() => setOpened(opened => !opened), [])\n\n  const handleResetConnection = useCallback(() => {\n    wallet.reset()\n  }, [wallet])\n\n  const handleActivate = useCallback(providerId => wallet.connect(providerId), [\n    wallet,\n  ])\n\n  const {\n    clientConnectionStatus,\n    clientListening,\n    clientOnline,\n    clientSyncDelay,\n    connectionColor,\n    connectionMessage,\n    isWrongNetwork,\n    label,\n    walletConnectionStatus,\n    walletListening,\n    walletSyncDelay,\n  } = useConnectionInfo()\n\n  // Always show the â€œconnectingâ€¦â€ screen, even if there are no delay\n  useEffect(() => {\n    let timer\n\n    if (status === WALLET_STATUS.error) {\n      setActivatingDelayed(null)\n    }\n\n    if (status === WALLET_STATUS.connecting) {\n      setActivatingDelayed(providerInfo.id)\n      timer = setTimeout(() => {\n        setActivatingDelayed(null)\n      }, 400)\n    }\n\n    return () => clearTimeout(timer)\n  }, [providerInfo, status])\n\n  const previousScreenIndex = useRef(-1)\n\n  const { screenIndex, direction } = useMemo(() => {\n    const screenId =\n      status === WALLET_STATUS.disconnected ? SCREEN_ID.providers : status\n\n    const screenIndex = SCREENS.findIndex(screen => screen.id === screenId)\n    const direction = previousScreenIndex.current > screenIndex ? -1 : 1\n\n    previousScreenIndex.current = screenIndex\n\n    return { direction, screenIndex }\n  }, [status])\n\n  const screen = SCREENS[screenIndex]\n  const screenId = screen.id\n\n  const handlePopoverClose = useCallback(() => {\n    if (screenId === SCREEN_ID.connecting || screenId === SCREEN_ID.error) {\n      // reject closing the popover\n      return false\n    }\n    setOpened(false)\n  }, [screenId])\n\n  return (\n    <div\n      ref={buttonRef}\n      css={`\n        display: flex;\n        align-items: center;\n        height: 100%;\n      `}\n    >\n      {screenId === SCREEN_ID.connected || isWrongNetwork ? (\n        <ButtonAccount\n          connectionColor={connectionColor}\n          connectionMessage={connectionMessage}\n          isWrongNetwork={isWrongNetwork}\n          label={label}\n          onClick={toggle}\n        />\n      ) : (\n        <ButtonConnect onClick={toggle} />\n      )}\n      <AccountModulePopover\n        direction={direction}\n        heading={screen.title}\n        keys={({ screenId }) => screenId + providerInfo.id + error.name}\n        onClose={handlePopoverClose}\n        onOpen={open}\n        opener={buttonRef.current}\n        screenId={screenId}\n        screenData={{\n          account,\n          activating: activatingDelayed,\n          activationError: error,\n          providerInfo,\n          screenId,\n        }}\n        screenKey={({\n          account,\n          activating,\n          activationError,\n          providerInfo,\n          screenId,\n        }) =>\n          (activationError ? activationError.name : '') +\n          account +\n          activating +\n          providerInfo.id +\n          screenId\n        }\n        visible={opened}\n      >\n        {({ account, screenId, activating, activationError, providerInfo }) => {\n          if (screenId === SCREEN_ID.connecting) {\n            return (\n              <ConnectingScreen\n                providerId={activating}\n                onCancel={handleResetConnection}\n              />\n            )\n          }\n          if (screenId === SCREEN_ID.connected) {\n            return (\n              <ConnectedScreen\n                account={account}\n                clientConnectionStatus={clientConnectionStatus}\n                clientListening={clientListening}\n                clientOnline={clientOnline}\n                clientSyncDelay={clientSyncDelay}\n                providerInfo={providerInfo}\n                walletConnectionStatus={walletConnectionStatus}\n                walletListening={walletListening}\n                walletOnline={walletListening}\n                walletSyncDelay={walletSyncDelay}\n              />\n            )\n          }\n          if (screenId === SCREEN_ID.error) {\n            return (\n              <ErrorScreen\n                error={activationError}\n                onBack={handleResetConnection}\n              />\n            )\n          }\n          return <ProvidersScreen onActivate={handleActivate} />\n        }}\n      </AccountModulePopover>\n    </div>\n  )\n}\n\nfunction useConnectionInfo() {\n  const wallet = useWallet()\n  const { name: label } = useLocalIdentity(wallet.account || '')\n\n  const {\n    isListening: walletListening,\n    isOnline: walletOnline,\n    connectionStatus: walletConnectionStatus,\n    syncDelay: walletSyncDelay,\n  } = useSyncInfo('wallet')\n\n  const {\n    isListening: clientListening,\n    isOnline: clientOnline,\n    connectionStatus: clientConnectionStatus,\n    syncDelay: clientSyncDelay,\n  } = useSyncInfo()\n\n  const { walletNetworkName, isWrongNetwork } = useNetworkConnectionData()\n\n  const { connectionMessage, connectionColor } = useWalletConnectionDetails(\n    clientListening,\n    walletListening,\n    clientOnline,\n    walletOnline,\n    clientSyncDelay,\n    walletSyncDelay,\n    walletNetworkName\n  )\n\n  return {\n    clientConnectionStatus,\n    clientListening,\n    clientOnline,\n    clientSyncDelay,\n    connectionColor,\n    connectionMessage,\n    isWrongNetwork,\n    label,\n    walletConnectionStatus,\n    walletListening,\n    walletNetworkName,\n    walletOnline,\n    walletSyncDelay,\n  }\n}\n\nexport default AccountModule\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { ButtonBase, GU, RADIUS, useTheme } from '@aragon/ui'\n\nimport logo from '../../assets/logo.png'\n\nfunction HomeButton({ onClick, ...props }) {\n  const theme = useTheme()\n  return (\n    <ButtonBase\n      onClick={onClick}\n      focusRingRadius={RADIUS}\n      title=\"Back to home\"\n      {...props}\n      css={`\n        position: absolute;\n        top: ${1 * GU}px;\n        left: ${1 * GU}px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        padding: ${1 * GU}px;\n        border-radius: ${RADIUS}px;\n        &:active {\n          background: ${theme.surfacePressed};\n        }\n      `}\n    >\n      <img src={logo} width={4.5 * GU} alt=\"\" />\n    </ButtonBase>\n  )\n}\n\nHomeButton.propTypes = {\n  onClick: PropTypes.func,\n}\n\nHomeButton.defaultProps = {\n  onClick: () => {\n    window.location.hash = '/'\n  },\n}\n\nexport default HomeButton\n","import React from 'react'\nimport { useWallet } from '../../contexts/wallet'\nimport { Info, ButtonBase, GU } from '@aragon/ui'\nimport { isMainnet, isTestnet, getNetworkShortName } from '../../util/network'\nimport PropTypes from 'prop-types'\n\nimport styled from 'styled-components'\n\nNetworkIndicator.propTypes = {\n  clickHandler: PropTypes.func.isRequired,\n}\n// TODO try adding Modal from here\nexport function NetworkIndicator({ clickHandler }) {\n  const { networkType, status } = useWallet()\n  const networkName = getNetworkShortName(networkType)\n\n  if (status === 'connected') {\n    return null\n  }\n\n  return (\n    <DisplacedDiv>\n      <ButtonBase onClick={clickHandler}>\n        {isMainnet(networkType) && <StyledInfo>{networkName}</StyledInfo>}\n        {isTestnet(networkType) && (\n          <StyledInfo mode=\"warning\">{networkName}</StyledInfo>\n        )}\n      </ButtonBase>\n    </DisplacedDiv>\n  )\n}\n\nconst DisplacedDiv = styled.div`\n  margin-right: -${3 * GU}px;\n`\n\nconst StyledInfo = styled(Info)`\n  height: 40px;\n  display: flex;\n  align-items: center;\n  padding-right: ${3 * GU}px;\n`\n","import React, { useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { Button, GU, IconSettings, useTheme } from '@aragon/ui'\nimport AccountModule from '../../components/AccountModule/AccountModule'\nimport HomeButton from '../../components/HomeButton/HomeButton'\nimport { useWallet } from '../../contexts/wallet'\nimport { isOnEthMainnet } from '../../util/network'\nimport styled from 'styled-components'\nimport { NetworkIndicator } from '../../components/NetworkIndicator/NetworkIndicator'\nimport { trackEvent, events } from '../../analytics'\n\nfunction OnboardingTopBar({ status, solid, modalOpener }) {\n  const theme = useTheme()\n  const { networkType } = useWallet()\n  const isMainnet = isOnEthMainnet(networkType)\n\n  const handleSettingsClick = useCallback(() => {\n    let path = '/'\n    if (status === 'open') {\n      path = '/open'\n    }\n    if (status === 'create') {\n      path = '/create'\n    }\n    window.location.hash = path + '?preferences=/network'\n\n    // analytics\n    trackEvent(events.USER_SETTINGS_CLICKED, {\n      network: networkType,\n    })\n  }, [status, networkType])\n\n  return (\n    <React.Fragment>\n      <TopBarDiv surface={theme.surface.alpha(solid ? 0.8 : 0)}>\n        <BlueLine color={theme.accent} />\n        <HomeButton />\n        <ButtonContainer>\n          <NetworkIndicator clickHandler={modalOpener} />\n          <AccountModule />\n          {isMainnet && (\n            <Button\n              display=\"icon\"\n              icon={<IconSettings />}\n              label=\"Settings\"\n              size=\"medium\"\n              onClick={handleSettingsClick}\n            />\n          )}\n        </ButtonContainer>\n      </TopBarDiv>\n    </React.Fragment>\n  )\n}\n\nconst BlueLine = styled.div`\n  position: absolute;\n  top: 0;\n  z-index: 1;\n  width: 100%;\n  border-top: 2px solid ${props => props.color};\n`\n\nconst ButtonContainer = styled.div`\n  display: flex;\n  align-items: center;\n  position: absolute;\n  top: 0;\n  right: ${2 * GU}px;\n  height: 100%;\n`\n\nconst TopBarDiv = styled.div`\n  position: absolute;\n  z-index: 2;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: ${7.5 * GU}px;\n  background: ${props => props.surfaceColor};\n  transition: background 150ms ease-in-out;\n  backdrop-filter: blur(6px);\n`\n\nOnboardingTopBar.propTypes = {\n  status: PropTypes.string.isRequired,\n  solid: PropTypes.bool,\n  modalOpener: PropTypes.func.isRequired,\n}\n\nexport default OnboardingTopBar\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array ? array.length : 0;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\n/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a cache value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {boolean} [bitmask] The bitmask of comparison flags.\n *  The bitmask may be composed of the following flags:\n *     1 - Unordered comparison\n *     2 - Partial comparison\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = getTag(object);\n    objTag = objTag == argsTag ? objectTag : objTag;\n  }\n  if (!othIsArr) {\n    othTag = getTag(other);\n    othTag = othTag == argsTag ? objectTag : othTag;\n  }\n  var objIsObj = objTag == objectTag && !isHostObject(object),\n      othIsObj = othTag == objectTag && !isHostObject(other),\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n  }\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!seen.has(othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, customizer, bitmask, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= UNORDERED_COMPARE_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var result,\n      index = -1,\n      length = path.length;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result) {\n    return result;\n  }\n  var length = object ? object.length : 0;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length)\n    ? baseUniq(array, baseIteratee(iteratee, 2))\n    : [];\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get€€