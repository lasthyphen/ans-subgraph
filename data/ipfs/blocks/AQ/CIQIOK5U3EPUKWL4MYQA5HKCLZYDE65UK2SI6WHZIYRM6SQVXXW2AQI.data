
Š€€€t: CONTEXT_MODEL\n};\nvar TRANSACTION_MODEL = {\n  name: true,\n  parent_id: true,\n  type: [KEYWORD_LIMIT, true],\n  id: [KEYWORD_LIMIT, true],\n  trace_id: [KEYWORD_LIMIT, true],\n  span_count: {\n    started: [KEYWORD_LIMIT, true]\n  },\n  context: CONTEXT_MODEL\n};\nvar ERROR_MODEL = {\n  id: [KEYWORD_LIMIT, true],\n  trace_id: true,\n  transaction_id: true,\n  parent_id: true,\n  culprit: true,\n  exception: {\n    type: true\n  },\n  transaction: {\n    type: true\n  },\n  context: CONTEXT_MODEL\n};\n\nfunction truncate(value, limit, required, placeholder) {\n  if (limit === void 0) {\n    limit = KEYWORD_LIMIT;\n  }\n\n  if (required === void 0) {\n    required = false;\n  }\n\n  if (placeholder === void 0) {\n    placeholder = 'N/A';\n  }\n\n  if (required && isEmpty(value)) {\n    value = placeholder;\n  }\n\n  if (typeof value === 'string') {\n    return value.substring(0, limit);\n  }\n\n  return value;\n}\n\nfunction isEmpty(value) {\n  return value == null || value === '' || typeof value === 'undefined';\n}\n\nfunction replaceValue(target, key, currModel) {\n  var value = truncate(target[key], currModel[0], currModel[1]);\n\n  if (isEmpty(value)) {\n    delete target[key];\n    return;\n  }\n\n  target[key] = value;\n}\n\nfunction truncateModel(model, target, childTarget) {\n  if (model === void 0) {\n    model = {};\n  }\n\n  if (childTarget === void 0) {\n    childTarget = target;\n  }\n\n  var keys = Object.keys(model);\n  var emptyArr = [];\n\n  var _loop = function _loop(i) {\n    var currKey = keys[i];\n    var currModel = model[currKey] === true ? emptyArr : model[currKey];\n\n    if (!Array.isArray(currModel)) {\n      truncateModel(currModel, target, childTarget[currKey]);\n    } else {\n      if (currKey === '*') {\n        Object.keys(childTarget).forEach(function (key) {\n          return replaceValue(childTarget, key, currModel);\n        });\n      } else {\n        replaceValue(childTarget, currKey, currModel);\n      }\n    }\n  };\n\n  for (var i = 0; i < keys.length; i++) {\n    _loop(i);\n  }\n\n  return target;\n}\n\nexport { truncate, truncateModel, SPAN_MODEL, TRANSACTION_MODEL, ERROR_MODEL, METADATA_MODEL, RESPONSE_MODEL };","var _excluded = [\"tags\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { createStackTraces, filterInvalidFrames } from './stack-trace';\nimport { generateRandomId, merge, extend } from '../common/utils';\nimport { getPageContext } from '../common/context';\nimport { truncateModel, ERROR_MODEL } from '../common/truncate';\nvar IGNORE_KEYS = ['stack', 'message'];\n\nfunction getErrorProperties(error) {\n  var propertyFound = false;\n  var properties = {};\n  Object.keys(error).forEach(function (key) {\n    if (IGNORE_KEYS.indexOf(key) >= 0) {\n      return;\n    }\n\n    var val = error[key];\n\n    if (val == null || typeof val === 'function') {\n      return;\n    }\n\n    if (typeof val === 'object') {\n      if (typeof val.toISOString !== 'function') return;\n      val = val.toISOString();\n    }\n\n    properties[key] = val;\n    propertyFound = true;\n  });\n\n  if (propertyFound) {\n    return properties;\n  }\n}\n\nvar ErrorLogging = function () {\n  function ErrorLogging(apmServer, configService, transactionService) {\n    this._apmServer = apmServer;\n    this._configService = configService;\n    this._transactionService = transactionService;\n  }\n\n  var _proto = ErrorLogging.prototype;\n\n  _proto.createErrorDataModel = function createErrorDataModel(errorEvent) {\n    var frames = createStackTraces(errorEvent);\n    var filteredFrames = filterInvalidFrames(frames);\n    var culprit = '(inline script)';\n    var lastFrame = filteredFrames[filteredFrames.length - 1];\n\n    if (lastFrame && lastFrame.filename) {\n      culprit = lastFrame.filename;\n    }\n\n    var message = errorEvent.message,\n        error = errorEvent.error;\n    var errorMessage = message;\n    var errorType = '';\n    var errorContext = {};\n\n    if (error && typeof error === 'object') {\n      errorMessage = errorMessage || error.message;\n      errorType = error.name;\n      var customProperties = getErrorProperties(error);\n\n      if (customProperties) {\n        errorContext.custom = customProperties;\n      }\n    }\n\n    if (!errorType) {\n      if (errorMessage && errorMessage.indexOf(':') > -1) {\n        errorType = errorMessage.split(':')[0];\n      }\n    }\n\n    var currentTransaction = this._transactionService.getCurrentTransaction();\n\n    var transactionContext = currentTransaction ? currentTransaction.context : {};\n\n    var _this$_configService$ = this._configService.get('context'),\n        tags = _this$_configService$.tags,\n        configContext = _objectWithoutPropertiesLoose(_this$_configService$, _excluded);\n\n    var pageContext = getPageContext();\n    var context = merge({}, pageContext, transactionContext, configContext, errorContext);\n    var errorObject = {\n      id: generateRandomId(),\n      culprit: culprit,\n      exception: {\n        message: errorMessage,\n        stacktrace: filteredFrames,\n        type: errorType\n      },\n      context: context\n    };\n\n    if (currentTransaction) {\n      errorObject = extend(errorObject, {\n        trace_id: currentTransaction.traceId,\n        parent_id: currentTransaction.id,\n        transaction_id: currentTransaction.id,\n        transaction: {\n          type: currentTransaction.type,\n          sampled: currentTransaction.sampled\n        }\n      });\n    }\n\n    return truncateModel(ERROR_MODEL, errorObject);\n  };\n\n  _proto.logErrorEvent = function logErrorEvent(errorEvent) {\n    if (typeof errorEvent === 'undefined') {\n      return;\n    }\n\n    var errorObject = this.createErrorDataModel(errorEvent);\n\n    if (typeof errorObject.exception.message === 'undefined') {\n      return;\n    }\n\n    this._apmServer.addError(errorObject);\n  };\n\n  _proto.registerListeners = function registerListeners() {\n    var _this = this;\n\n    window.addEventListener('error', function (errorEvent) {\n      return _this.logErrorEvent(errorEvent);\n    });\n    window.addEventListener('unhandledrejection', function (promiseRejectionEvent) {\n      return _this.logPromiseEvent(promiseRejectionEvent);\n    });\n  };\n\n  _proto.logPromiseEvent = function logPromiseEvent(promiseRejectionEvent) {\n    var prefix = 'Unhandled promise rejection: ';\n    var reason = promiseRejectionEvent.reason;\n\n    if (reason == null) {\n      reason = '<no reason specified>';\n    }\n\n    var errorEvent;\n\n    if (typeof reason.message === 'string') {\n      var name = reason.name ? reason.name + ': ' : '';\n      errorEvent = {\n        error: reason,\n        message: prefix + name + reason.message\n      };\n    } else {\n      reason = typeof reason === 'object' ? '<object>' : typeof reason === 'function' ? '<function>' : reason;\n      errorEvent = {\n        message: prefix + reason\n      };\n    }\n\n    this.logErrorEvent(errorEvent);\n  };\n\n  _proto.logError = function logError(messageOrError) {\n    var errorEvent = {};\n\n    if (typeof messageOrError === 'string') {\n      errorEvent.message = messageOrError;\n    } else {\n      errorEvent.error = messageOrError;\n    }\n\n    return this.logErrorEvent(errorEvent);\n  };\n\n  return ErrorLogging;\n}();\n\nexport default ErrorLogging;","var Queue = function () {\n  function Queue(onFlush, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    this.onFlush = onFlush;\n    this.items = [];\n    this.queueLimit = opts.queueLimit || -1;\n    this.flushInterval = opts.flushInterval || 0;\n    this.timeoutId = undefined;\n  }\n\n  var _proto = Queue.prototype;\n\n  _proto._setTimer = function _setTimer() {\n    var _this = this;\n\n    this.timeoutId = setTimeout(function () {\n      return _this.flush();\n    }, this.flushInterval);\n  };\n\n  _proto._clear = function _clear() {\n    if (typeof this.timeoutId !== 'undefined') {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = undefined;\n    }\n\n    this.items = [];\n  };\n\n  _proto.flush = function flush() {\n    this.onFlush(this.items);\n\n    this._clear();\n  };\n\n  _proto.add = function add(item) {\n    this.items.push(item);\n\n    if (this.queueLimit !== -1 && this.items.length >= this.queueLimit) {\n      this.flush();\n    } else {\n      if (typeof this.timeoutId === 'undefined') {\n        this._setTimer();\n      }\n    }\n  };\n\n  return Queue;\n}();\n\nexport default Queue;","export default function throttle(fn, onThrottle, opts) {\n  var context = this;\n  var limit = opts.limit;\n  var interval = opts.interval;\n  var counter = 0;\n  var timeoutId;\n  return function () {\n    counter++;\n\n    if (typeof timeoutId === 'undefined') {\n      timeoutId = setTimeout(function () {\n        counter = 0;\n        timeoutId = undefined;\n      }, interval);\n    }\n\n    if (counter > limit && typeof onThrottle === 'function') {\n      return onThrottle.apply(context, arguments);\n    } else {\n      return fn.apply(context, arguments);\n    }\n  };\n}","var NDJSON = function () {\n  function NDJSON() {}\n\n  NDJSON.stringify = function stringify(object) {\n    return JSON.stringify(object) + '\\n';\n  };\n\n  return NDJSON;\n}();\n\nexport default NDJSON;","export var globalState = {\n  fetchInProgress: false\n};\nexport function apmSymbol(name) {\n  return '__apm_symbol__' + name;\n}\n\nfunction isPropertyWritable(propertyDesc) {\n  if (!propertyDesc) {\n    return true;\n  }\n\n  if (propertyDesc.writable === false) {\n    return false;\n  }\n\n  return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');\n}\n\nfunction attachOriginToPatched(patched, original) {\n  patched[apmSymbol('OriginalDelegate')] = original;\n}\n\nexport function patchMethod(target, name, patchFn) {\n  var proto = target;\n\n  while (proto && !proto.hasOwnProperty(name)) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  if (!proto && target[name]) {\n    proto = target;\n  }\n\n  var delegateName = apmSymbol(name);\n  var delegate;\n\n  if (proto && !(delegate = proto[delegateName])) {\n    delegate = proto[delegateName] = proto[name];\n    var desc = proto && Object.getOwnPropertyDescriptor(proto, name);\n\n    if (isPropertyWritable(desc)) {\n      var patchDelegate = patchFn(delegate, delegateName, name);\n\n      proto[name] = function () {\n        return patchDelegate(this, arguments);\n      };\n\n      attachOriginToPatched(proto[name], delegate);\n    }\n  }\n\n  return delegate;\n}\nexport var XHR_IGNORE = apmSymbol('xhrIgnore');\nexport var XHR_SYNC = apmSymbol('xhrSync');\nexport var XHR_URL = apmSymbol('xhrURL');\nexport var XHR_METHOD = apmSymbol('xhrMethod');","import { generateRandomId, setLabel, merge, getDuration, getTime } from '../common/utils';\nimport { NAME_UNKNOWN, TYPE_CUSTOM } from '../common/constants';\n\nvar SpanBase = function () {\n  function SpanBase(name, type, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (!name) {\n      name = NAME_UNKNOWN;\n    }\n\n    if (!type) {\n      type = TYPE_CUSTOM;\n    }\n\n    this.name = name;\n    this.type = type;\n    this.options = options;\n    this.id = options.id || generateRandomId(16);\n    this.traceId = options.traceId;\n    this.sampled = options.sampled;\n    this.sampleRate = options.sampleRate;\n    this.timestamp = options.timestamp;\n    this._start = getTime(options.startTime);\n    this._end = undefined;\n    this.ended = false;\n    this.outcome = undefined;\n    this.onEnd = options.onEnd;\n  }\n\n  var _proto = SpanBase.prototype;\n\n  _proto.ensureContext = function ensureContext() {\n    if (!this.context) {\n      this.context = {};\n    }\n  };\n\n  _proto.addLabels = function addLabels(tags) {\n    this.ensureContext();\n    var ctx = this.context;\n\n    if (!ctx.tags) {\n      ctx.tags = {};\n    }\n\n    var keys = Object.keys(tags);\n    keys.forEach(function (k) {\n      return setLabel(k, tags[k], ctx.tags);\n    });\n  };\n\n  _proto.addContext = function addContext() {\n    for (var _len = arguments.length, context = new Array(_len), _key = 0; _key < _len; _key++) {\n      context[_key] = arguments[_key];\n    }\n\n    if (context.length === 0) return;\n    this.ensureContext();\n    merge.apply(void 0, [this.context].concat(context));\n  };\n\n  _proto.end = function end(endTime) {\n    if (this.ended) {\n      return;\n    }\n\n    this.ended = true;\n    this._end = getTime(endTime);\n    this.callOnEnd();\n  };\n\n  _proto.callOnEnd = function callOnEnd() {\n    if (typeof this.onEnd === 'function') {\n      this.onEnd(this);\n    }\n  };\n\n  _proto.duration = function duration() {\n    return getDuration(this._start, this._end);\n  };\n\n  return SpanBase;\n}();\n\nexport default SpanBase;","function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport SpanBase from './span-base';\nimport { addSpanContext } from '../common/context';\n\nvar Span = function (_SpanBase) {\n  _inheritsLoose(Span, _SpanBase);\n\n  function Span(name, type, options) {\n    var _this;\n\n    _this = _SpanBase.call(this, name, type, options) || this;\n    _this.parentId = _this.options.parentId;\n    _this.subtype = undefined;\n    _this.action = undefined;\n\n    if (_this.type.indexOf('.') !== -1) {\n      var fields = _this.type.split('.', 3);\n\n      _this.type = fields[0];\n      _this.subtype = fields[1];\n      _this.action = fields[2];\n    }\n\n    _this.sync = _this.options.sync;\n    return _this;\n  }\n\n  var _proto = Span.prototype;\n\n  _proto.end = function end(endTime, data) {\n    _SpanBase.prototype.end.call(this, endTime);\n\n    addSpanContext(this, data);\n  };\n\n  return Span;\n}(SpanBase);\n\nexport default Span;","var __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar state = {\n  bootstrapTime: null,\n  lastHiddenStart: Number.MIN_SAFE_INTEGER\n};\nexport { __DEV__, state };","import Span from './span';\nimport { RESOURCE_INITIATOR_TYPES, MAX_SPAN_DURATION, USER_TIMING_THRESHOLD, PAGE_LOAD, RESOURCE, MEASURE } from '../common/constants';\nimport { stripQueryStringFromUrl, PERF, isPerfTimelineSupported } from '../common/utils';\nimport { state } from '../state';\nvar eventPairs = [['domainLookupStart', 'domainLookupEnd', 'Domain lookup'], ['connectStart', 'connectEnd', 'Making a connection to the server'], ['requestStart', 'responseEnd', 'Requesting and receiving the document'], ['domLoading', 'domInteractive', 'Parsing the document, executing sync. scripts'], ['domContentLoadedEventStart', 'domContentLoadedEventEnd', 'Fire \"DOMContentLoaded\" event'], ['loadEventStart', 'loadEventEnd', 'Fire \"load\" event']];\n\nfunction shouldCreateSpan(start, end, trStart, trEnd, baseTime) {\n  if (baseTime === void 0) {\n    baseTime = 0;\n  }\n\n  return typeof start === 'number' && typeof end === 'number' && start >= baseTime && end > start && start - baseTime >= trStart && end - baseTime <= trEnd && end - start < MAX_SPAN_DURATION && start - baseTime < MAX_SPAN_DURATION && end - baseTime < MAX_SPAN_DURATION;\n}\n\nfunction createNavigationTimingSpans(timings, baseTime, trStart, trEnd) {\n  var spans = [];\n\n  for (var i = 0; i < eventPairs.length; i++) {\n    var start = timings[eventPairs[i][0]];\n    var end = timings[eventPairs[i][1]];\n\n    if (!shouldCreateSpan(start, end, trStart, trEnd, baseTime)) {\n      continue;\n    }\n\n    var span = new Span(eventPairs[i][2], 'hard-navigation.browser-timing');\n    var data = null;\n\n    if (eventPairs[i][0] === 'requestStart') {\n      span.pageResponse = true;\n      data = {\n        url: location.origin\n      };\n    }\n\n    span._start = start - baseTime;\n    span.end(end - baseTime, data);\n    spans.push(span);\n  }\n\n  return spans;\n}\n\nfunction createResourceTimingSpan(resourceTimingEntry) {\n  var name = resourceTimingEntry.name,\n      initiatorType = resourceTimingEntry.initiatorType,\n      startTime = resourceTimingEntry.startTime,\n      responseEnd = resourceTimingEntry.responseEnd;\n  var kind = 'resource';\n\n  if (initiatorType) {\n    kind += '.' + initiatorType;\n  }\n\n  var spanName = stripQueryStringFromUrl(name);\n  var span = new Span(spanName, kind);\n  span._start = startTime;\n  span.end(responseEnd, {\n    url: name,\n    entry: resourceTimingEntry\n  });\n  return span;\n}\n\nfunction isCapturedByPatching(resourceStartTime, requestPatchTime) {\n  return requestPatchTime != null && resourceStartTime > requestPatchTime;\n}\n\nfunction isIntakeAPIEndpoint(url) {\n  return /intake\\/v\\d+\\/rum\\/events/.test(url);\n}\n\nfunction createResourceTimingSpans(entries, requestPatchTime, trStart, trEnd) {\n  var spans = [];\n\n  for (var i = 0; i < entries.length; i++) {\n    var _entries$i = entries[i],\n        initiatorType = _entries$i.initiatorType,\n        name = _entries$i.name,\n        startTime = _entries$i.startTime,\n        responseEnd = _entries$i.responseEnd;\n\n    if (RESOURCE_INITIATOR_TYPES.indexOf(initiatorType) === -1 || name == null) {\n      continue;\n    }\n\n    if ((initiatorType === 'xmlhttprequest' || initiatorType === 'fetch') && (isIntakeAPIEndpoint(name) || isCapturedByPatching(startTime, requestPatchTime))) {\n      continue;\n    }\n\n    if (shouldCreateSpan(startTime, responseEnd, trStart, trEnd)) {\n      spans.push(createResourceTimingSpan(entries[i]));\n    }\n  }\n\n  return spans;\n}\n\nfunction createUserTimingSpans(entries, trStart, trEnd) {\n  var userTimingSpans = [];\n\n  for (var i = 0; i < entries.length; i++) {\n    var _entries$i2 = entries[i],\n        name = _entries$i2.name,\n        startTime = _entries$i2.startTime,\n        duration = _entries$i2.duration;\n    var end = startTime + duration;\n\n    if (duration <= USER_TIMING_THRESHOLD || !shouldCreateSpan(startTime, end, trStart, trEnd)) {\n      continue;\n    }\n\n    var kind = 'app';\n    var span = new Span(name, kind);\n    span._start = startTime;\n    span.end(end);\n    userTimingSpans.push(span);\n  }\n\n  return userTimingSpans;\n}\n\nvar NAVIGATION_TIMING_MARKS = ['fetchStart', 'domainLookupStart', 'domainLookupEnd', 'connectStart', 'connectEnd', 'requestStart', 'responseStart', 'responseEnd', 'domLoading', 'domInteractive', 'domContentLoadedEventStart', 'domContentLoadedEventEnd', 'domComplete', 'loadEventStart', 'loadEventEnd'];\nvar COMPRESSED_NAV_TIMING_MARKS = ['fs', 'ls', 'le', 'cs', 'ce', 'qs', 'rs', 're', 'dl', 'di', 'ds', 'de', 'dc', 'es', 'ee'];\n\nfunction getNavigationTimingMarks(timing) {\n  var fetchStart = timing.fetchStart,\n      navigationStart = timing.navigationStart,\n      responseStart = timing.responseStart,\n      responseEnd = timing.responseEnd;\n\n  if (fetchStart >= navigationStart && responseStart >= fetchStart && responseEnd >= responseStart) {\n    var marks = {};\n    NAVIGATION_TIMING_MARKS.forEach(function (timingKey) {\n      var m = timing[timingKey];\n\n      if (m && m >= fetchStart) {\n        marks[timingKey] = parseInt(m - fetchStart);\n      }\n    });\n    return marks;\n  }\n\n  return null;\n}\n\nfunction getPageLoadMarks(timing) {\n  var marks = getNavigationTimingMarks(timing);\n\n  if (marks == null) {\n    return null;\n  }\n\n  return {\n    navigationTiming: marks,\n    agent: {\n      timeToFirstByte: marks.responseStart,\n      domInteractive: marks.domInteractive,\n      domComplete: marks.domComplete\n    }\n  };\n}\n\nfunction captureNavigation(transaction) {\n  if (!transaction.captureTimings) {\n    return;\n  }\n\n  var trEnd = transaction._end;\n\n  if (transaction.type === PAGE_LOAD) {\n    if (transaction.marks && transaction.marks.custom) {\n      var customMarks = transaction.marks.custom;\n      Object.keys(customMarks).forEach(function (key) {\n        customMarks[key] += transaction._start;\n      });\n    }\n\n    var trStart = 0;\n    transaction._start = trStart;\n    var timings = PERF.timing;\n    createNavigationTimingSpans(timings, timings.fetchStart, trStart, trEnd).forEach(function (span) {\n      span.traceId = transaction.traceId;\n      span.sampled = transaction.sampled;\n\n      if (span.pageResponse && transaction.options.pageLoadSpanId) {\n        span.id = transaction.options.pageLoadSpanId;\n      }\n\n      transaction.spans.push(span);\n    });\n    transaction.addMarks(getPageLoadMarks(timings));\n  }\n\n  if (isPerfTimelineSupported()) {\n    var _trStart = transaction._start;\n    var resourceEntries = PERF.getEntriesByType(RESOURCE);\n    createResourceTimingSpans(resourceEntries, state.bootstrapTime, _trStart, trEnd).forEach(function (span) {\n      return transaction.spans.push(span);\n    });\n    var userEntries = PERF.getEntriesByType(MEASURE);\n    createUserTimingSpans(userEntries, _trStart, trEnd).forEach(function (span) {\n      return transaction.spans.push(span);\n    });\n  }\n}\n\nexport { getPageLoadMarks, captureNavigation, createNavigationTimingSpans, createResourceTimingSpans, createUserTimingSpans, NAVIGATION_TIMING_MARKS, COMPRESSED_NAV_TIMING_MARKS };","import { Promise } from './polyfills';\nimport { NAVIGATION_TIMING_MARKS, COMPRESSED_NAV_TIMING_MARKS } from '../performance-monitoring/capture-navigation';\n\nfunction compressStackFrames(frames) {\n  return frames.map(function (frame) {\n    return {\n      ap: frame.abs_path,\n      f: frame.filename,\n      fn: frame.function,\n      li: frame.lineno,\n      co: frame.colno\n    };\n  });\n}\n\nfunction compressResponse(response) {\n  return {\n    ts: response.transfer_size,\n    ebs: response.encoded_body_size,\n    dbs: response.decoded_body_size\n  };\n}\n\nfunction compressHTTP(http) {\n  var compressed = {};\n  var method = http.method,\n      status_code = http.status_code,\n      url = http.url,\n      response = http.response;\n  compressed.url = url;\n\n  if (method) {\n    compressed.mt = method;\n  }\n\n  if (status_code) {\n    compressed.sc = status_code;\n  }\n\n  if (response) {\n    compressed.r = compressResponse(response);\n  }\n\n  return compressed;\n}\n\nfunction compressContext(context) {\n  if (!context) {\n    return null;\n  }\n\n  var compressed = {};\n  var page = context.page,\n      http = context.http,\n      response = context.response,\n      destination = context.destination,\n      user = context.user,\n      custom = context.custom;\n\n  if (page) {\n    compressed.p = {\n      rf: page.referer,\n      url: page.url\n    };\n  }\n\n  if (http) {\n    compressed.h = compressHTTP(http);\n  }\n\n  if (response) {\n    compressed.r = compressResponse(response);\n  }\n\n  if (destination) {\n    var service = destination.service;\n    compressed.dt = {\n      se: {\n        n: service.name,\n        t: service.type,\n        rc: service.resource\n      },\n      ad: destination.address,\n      po: destination.port\n    };\n  }\n\n  if (user) {\n    compressed.u = {\n      id: user.id,\n      un: user.username,\n      em: user.email\n    };\n  }\n\n  if (custom) {\n    compressed.cu = custom;\n  }\n\n  return compressed;\n}\n\nfunction compressMarks(marks) {\n  if (!marks) {\n    return null;\n  }\n\n  var navigationTiming = marks.navigationTiming,\n      agent = marks.agent;\n  var compressed = {\n    nt: {}\n  };\n  COMPRESSED_NAV_TIMING_MARKS.forEach(function (mark, index) {\n    var mapping = NAVIGATION_TIMING_MARKS[index];\n    compressed.nt[mark] = navigationTiming[mapping];\n  });\n  compressed.a = {\n    fb: compressed.nt.rs,\n    di: compressed.nt.di,\n    dc: compressed.nt.dc\n  };\n  var fp = agent.firstContentfulPaint;\n  var lp = agent.largestContentfulPaint;\n\n  if (fp) {\n    compressed.a.fp = fp;\n  }\n\n  if (lp) {\n    compressed.a.lp = lp;\n  }\n\n  return compressed;\n}\n\nexport function compressMetadata(metadata) {\n  var service = metadata.service,\n      labels = metadata.labels;\n  var agent = service.agent,\n      language = service.language;\n  return {\n    se: {\n      n: service.name,\n      ve: service.version,\n      a: {\n        n: agent.name,\n        ve: agent.version\n      },\n      la: {\n        n: language.name\n      },\n      en: service.environment\n    },\n    l: labels\n  };\n}\nexport function compressTransaction(transaction) {\n  var spans = transaction.spans.map(function (span) {\n    var spanData = {\n      id: span.id,\n      n: span.name,\n      t: span.type,\n      s: span.start,\n      d: span.duration,\n      c: compressContext(span.context),\n      o: span.outcome,\n      sr: span.sample_rate\n    };\n\n    if (span.parent_id !== transaction.id) {\n      spanData.pid = span.parent_id;\n    }\n\n    if (span.sync === true) {\n      spanData.sy = true;\n    }\n\n    if (span.subtype) {\n      spanData.su = span.subtype;\n    }\n\n    if (span.action) {\n      spanData.ac = span.action;\n    }\n\n    return spanData;\n  });\n  var tr = {\n    id: transaction.id,\n    tid: transaction.trace_id,\n    n: transaction.name,\n    t: transaction.type,\n    d: transaction.duration,\n    c: compressContext(transaction.context),\n    k: compressMarks(transaction.marks),\n    me: compressMetricsets(transaction.breakdown),\n    y: spans,\n    yc: {\n      sd: spans.length\n    },\n    sm: transaction.sampled,\n    sr: transaction.sample_rate,\n    o: transaction.outcome\n  };\n\n  if (transaction.experience) {\n    var _transaction$experien = transaction.experience,\n        cls = _transaction$experien.cls,\n        fid = _transaction$experien.fid,\n        tbt = _transaction$experien.tbt,\n        longtask = _transaction$experien.longtask;\n    tr.exp = {\n      cls: cls,\n      fid: fid,\n      tbt: tbt,\n      lt: longtask\n    };\n  }\n\n  if (transaction.session) {\n    var _transaction$session = transaction.session,\n        id = _transaction$session.id,\n        sequence = _transaction$session.sequence;\n    tr.ses = {\n      id: id,\n      seq: sequence\n    };\n  }\n\n  return tr;\n}\nexport function compressError(error) {\n  var exception = error.exception;\n  var compressed = {\n    id: error.id,\n    cl: error.culprit,\n    ex: {\n      mg: exception.message,\n      st: compressStackFrames(exception.stacktrace),\n      t: error.type\n    },\n    c: compressContext(error.context)\n  };\n  var transaction = error.transaction;\n\n  if (transaction) {\n    compressed.tid = error.trace_id;\n    compressed.pid = error.parent_id;\n    compressed.xid = error.transaction_id;\n    compressed.x = {\n      t: transaction.type,\n      sm: transaction.sampled\n    };\n  }\n\n  return compressed;\n}\nexport function compressMetricsets(breakdowns) {\n  return breakdowns.map(function (_ref) {\n    var span = _ref.span,\n        samples = _ref.samples;\n    var isSpan = span != null;\n\n    if (isSpan) {\n      return {\n        y: {\n          t: span.type\n        },\n        sa: {\n          ysc: {\n            v: samples['span.self_time.count'].value\n          },\n          yss: {\n            v: samples['span.self_time.sum.us'].value\n          }\n        }\n      };\n    }\n\n    return {\n      sa: {\n        xdc: {\n          v: samples['transaction.duration.count'].value\n        },\n        xds: {\n          v: samples['transaction.duration.sum.us'].value\n        },\n        xbc: {\n          v: samples['transaction.breakdown.count'].value\n        }\n      }\n    };\n  });\n}\nexport function compressPayload(params, type) {\n  if (type === void 0) {\n    type = 'gzip';\n  }\n\n  var isCompressionStreamSupported = typeof CompressionStream === 'function';\n  return new Promise(function (resolve) {\n    if (!isCompressionStreamSupported) {\n      return resolve(params);\n    }\n\n    var payload = params.payload,\n        headers = params.headers,\n        beforeSend = params.beforeSend;\n    var payloadStream = new Blob([payload]).stream();\n    var compressedStream = payloadStream.pipeThrough(new CompressionStream(type));\n    return new Response(compressedStream).blob().then(function (payload) {\n      headers['Content-Encoding'] = type;\n      return resolve({\n        payload: payload,\n        headers: headers,\n        beforeSend: beforeSend\n      });\n    });\n  });\n}","import Queue from './queue';\nimport throttle from './throttle';\nimport NDJSON from './ndjson';\nimport { XHR_IGNORE } from './patching/patch-utils';\nimport { truncateModel, METADATA_MODEL } from './truncate';\nimport { ERRORS, TRANSACTIONS } from './constants';\nimport { noop } from './utils';\nimport { Promise } from './polyfills';\nimport { compressMetadata, compressTransaction, compressError, compressPayload } from './compress';\nimport { __DEV__ } from '../state';\nvar THROTTLE_INTERVAL = 60000;\n\nvar ApmServer = function () {\n  function ApmServer(configService, loggingService) {\n    this._configService = configService;\n    this._loggingService = loggingService;\n    this.queue = undefined;\n    this.throttleEvents = noop;\n  }\n\n  var _proto = ApmServer.prototype;\n\n  _proto.init = function init() {\n    var _this = this;\n\n    var queueLimit = this._configService.get('queueLimit');\n\n    var flushInterval = this._configService.get('flushInterval');\n\n    var limit = this._configService.get('eventsLimit');\n\n    var onFlush = function onFlush(events) {\n      var promise = _this.sendEvents(events);\n\n      if (promise) {\n        promise.catch(function (reason) {\n          _this._loggingService.warn('Failed sending events!', _this._constructError(reason));\n        });\n      }\n    };\n\n    this.queue = new Queue(onFlush, {\n      queueLimit: queueLimit,\n      flushInterval: flushInterval\n    });\n    this.throttleEvents = throttle(this.queue.add.bind(this.queue), function () {\n      return _this._loggingService.warn('Dropped events due to throttling!');\n    }, {\n      limit: limit,\n      interval: THROTTLE_INTERVAL\n    });\n  };\n\n  _proto._postJson = function _postJson(endPoint, payload) {\n    var _this2 = this;\n\n    var headers = {\n      'Content-Type': 'application/x-ndjson'\n    };\n\n    var apmRequest = this._configService.get('apmRequest');\n\n    var params = {\n      payload: payload,\n      headers: headers,\n      beforeSend: apmRequest\n    };\n    return compressPayload(params).catch(function (error) {\n      if (__DEV__) {\n        _this2._loggingService.debug('Compressing the payload using CompressionStream API failed', error.message);\n      }\n\n      return params;\n    }).then(function (result) {\n      return _this2._makeHttpRequest('POST', endPoint, result);\n    }).then(function (_ref) {\n      var responseText = _ref.responseText;\n      return responseText;\n    });\n  };\n\n  _proto._constructError = function _constructError(reason) {\n    var url = reason.url,\n        status = reason.status,\n        responseText = reason.responseText;\n\n    if (typeof status == 'undefined') {\n      return reason;\n    }\n\n    var message = url + ' HTTP status: ' + status;\n\n    if (__DEV__ && responseText) {\n      try {\n        var serverErrors = [];\n        var response = JSON.parse(responseText);\n\n        if (response.errors && response.errors.length > 0) {\n          response.errors.forEach(function (err) {\n            return serverErrors.push(err.message);\n          });\n          message += ' ' + serverErrors.join(',');\n        }\n      } catch (e) {\n        this._loggingService.debug('Error parsing response from APM server', e);\n      }\n    }\n\n    return new Error(message);\n  };\n\n  _proto._makeHttpRequest = function _makeHttpRequest(method, url, _temp) {\n    var _ref2 = _temp === void 0 ? {} : _temp,\n        _ref2$timeout = _ref2.timeout,\n        timeout = _ref2$timeout === void 0 ? 10000 : _ref2$timeout,\n        payload = _ref2.payload,\n        headers = _ref2.headers,\n        beforeSend = _ref2.beforeSend;\n\n    return new Promise(function (resolve, reject) {\n      var xhr = new window.XMLHttpRequest();\n      xhr[XHR_IGNORE] = true;\n      xhr.open(method, url, true);\n      xhr.timeout = timeout;\n\n      if (headers) {\n        for (var header in headers) {\n          if (headers.hasOwnProperty(header)) {\n            xhr.setRequestHeader(header, headers[header]);\n          }\n        }\n      }\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n          var status = xhr.status,\n              responseText = xhr.responseText;\n\n          if (status === 0 || status > 399 && status < 600) {\n            reject({\n              url: url,\n              status: status,\n              responseText: responseText\n            });\n          } else {\n            resolve(xhr);\n          }\n        }\n      };\n\n      xhr.onerror = function () {\n        var status = xhr.status,\n            responseText = xhr.responseText;\n        reject({\n          url: url,\n          status: status,\n          responseText: responseText\n        });\n      };\n\n      var canSend = true;\n\n      if (typeof beforeSend === 'function') {\n        canSend = beforeSend({\n          url: url,\n          method: method,\n          headers: headers,\n          payload: payload,\n          xhr: xhr\n        });\n      }\n\n      if (canSend) {\n        xhr.send(payload);\n      } else {\n        reject({\n          url: url,\n          status: 0,\n          responseText: 'Request rejected by user configuration.'\n        });\n      }\n    });\n  };\n\n  _proto.fetchConfig = function fetchConfig(serviceName, environment) {\n    var _this3 = this;\n\n    var serverUrl = this._configService.get('serverUrl');\n\n    var configEndpoint = serverUrl + \"/config/v1/rum/agents\";\n\n    if (!serviceName) {\n      return Promise.reject('serviceName is required for fetching central config.');\n    }\n\n    configEndpoint += \"?service.name=\" + serviceName;\n\n    if (environment) {\n      configEndpoint += \"&service.environment=\" + environment;\n    }\n\n    var localConfig = this._configService.getLocalConfig();\n\n    if (localConfig) {\n      configEndpoint += \"&ifnonematch=\" + localConfig.etag;\n    }\n\n    var apmRequest = this._configService.get('apmRequest');\n\n    return this._makeHttpRequest('GET', configEndpoint, {\n      timeout: 5000,\n      beforeSend: apmRequest\n    }).then(function (xhr) {\n      var status = xhr.status,\n          responseText = xhr.responseText;\n\n      if (status === 304) {\n        return localConfig;\n      } else {\n        var remoteConfig = JSON.parse(responseText);\n        var etag = xhr.getResponseHeader('etag');\n\n        if (etag) {\n          remoteConfig.etag = etag.replace(/[\"]/g, '');\n\n          _this3._configService.setLocalConfig(remoteConfig, true);\n        }\n\n        return remoteConfig;\n      }\n    }).catch(function (reason) {\n      var error = _this3._constructError(reason);\n\n      return Promise.reject(error);\n    });\n  };\n\n  _proto.createMetaData = function createMetaData() {\n    var cfg = this._configService;\n    var metadata = {\n      service: {\n        name: cfg.get('serviceName'),\n        version: cfg.get('serviceVersion'),\n        agent: {\n          name: 'rum-js',\n          version: cfg.version\n        },\n        language: {\n          name: 'javascript'\n        },\n        environment: cfg.get('environment')\n      },\n      labels: cfg.get('context.tags')\n    };\n    return truncateModel(METADATA_MODEL, metadata);\n  };\n\n  _proto.addError = function addError(error) {\n    var _this$throttleEvents;\n\n    this.throttleEvents((_this$throttleEvents = {}, _this$throttleEvents[ERRORS] = error, _this$throttleEvents));\n  };\n\n  _proto.addTransaction = function addTransaction(transaction) {\n    var _this$throttleEvents2;\n\n    this.throttleEvents((_this$throttleEvents2 = {}, _this$throttleEvents2[TRANSACTIONS] = transaction, _this$throttleEvents2));\n  };\n\n  _proto.ndjsonErrors = function ndjsonErrors(errors, compress) {\n    var key = compress ? 'e' : 'error';\n    return errors.map(function (error) {\n      var _NDJSON$stringify;\n\n      return NDJSON.stringify((_NDJSON$stringify = {}, _NDJSON$stringify[key] = compress ? compressError(error) : error, _NDJSON$stringify));\n    });\n  };\n\n  _proto.ndjsonMetricsets = function ndjsonMetricsets(metricsets) {\n    return metricsets.map(function (metricset) {\n      return NDJSON.stringify({\n        metricset: metricset\n      });\n    }).join('');\n  };\n\n  _proto.ndjsonTransactions = function ndjsonTransactions(transactions, compress) {\n    var _this4 = this;\n\n    var key = compress ? 'x' : 'transaction';\n    return transactions.map(function (tr) {\n      var _NDJSON$stringify2;\n\n      var spans = '',\n          breakdowns = '';\n\n      if (!compress) {\n        if (tr.spans) {\n          spans = tr.spans.map(function (span) {\n            return NDJSON.stringify({\n              span: span\n            });\n          }).join('');\n          delete tr.spans;\n        }\n\n        if (tr.breakdown) {\n          breakdowns = _this4.ndjsonMetricsets(tr.breakdown);\n          delete tr.breakdown;\n        }\n      }\n\n      return NDJSON.stringify((_NDJSON$stringify2 = {}, _NDJSON$stringify2[key] = compress ? compressTransaction(tr) : tr, _NDJSON$stringify2)) + spans + breakdowns;\n    });\n  };\n\n  _proto.sendEvents = function sendEvents(events) {\n    var _payload, _NDJSON$stringify3;\n\n    if (events.length === 0) {\n      return;\n    }\n\n    var transactions = [];\n    var errors = [];\n\n    for (var i = 0; i < events.length; i++) {\n      var event = events[i];\n\n      if (event[TRANSACTIONS]) {\n        transactions.push(event[TRANSACTIONS]);\n      }\n\n      if (event[ERRORS]) {\n        errors.push(event[ERRORS]);\n      }\n    }\n\n    if (transactions.length === 0 && errors.length === 0) {\n      return;\n    }\n\n    var cfg = this._configService;\n    var payload = (_payload = {}, _payload[TRANSACTIONS] = transactions, _payload[ERRORS] = errors, _payload);\n    var filteredPayload = cfg.applyFilters(payload);\n\n    if (!filteredPayload) {\n      this._loggingService.warn('Dropped payload due to filtering!');\n\n      return;\n    }\n\n    var apiVersion = cfg.get('apiVersion');\n    var compress = apiVersion > 2;\n    var ndjson = [];\n    var metadata = this.createMetaData();\n    var metadataKey = compress ? 'm' : 'metadata';\n    ndjson.push(NDJSON.stringify((_NDJSON$stringify3 = {}, _NDJSON$stringify3[metadataKey] = compress ? compressMetadata(metadata) : metadata, _NDJSON$stringify3)));\n    ndjson = ndjson.concat(this.ndjsonErrors(filteredPayload[ERRORS], compress), this.ndjsonTransactions(filteredPayload[TRANSACTIONS], compress));\n    var ndjsonPayload = ndjson.join('');\n    var endPoint = cfg.get('serverUrl') + (\"/intake/v\" + apiVersion + \"/rum/events\");\n    return this._postJson(endPoint, ndjsonPayload);\n  };\n\n  return ApmServer;\n}();\n\nexport default ApmServer;","import { BEFORE_EVENT, AFTER_EVENT } from './constants';\n\nvar EventHandler = function () {\n  function EventHandler() {\n    this.observers = {};\n  }\n\n  var _proto = EventHandler.prototype;\n\n  _proto.observe = function observe(name, fn) {\n    var _this = this;\n\n    if (typeof fn === 'function') {\n      if (!this.observers[name]) {\n        this.observers[name] = [];\n      }\n\n      this.observers[name].push(fn);\n      return function () {\n        var index = _this.observers[name].indexOf(fn);\n\n        if (index > -1) {\n          _this.observers[name].splice(index, 1);\n        }\n      };\n    }\n  };\n\n  _proto.sendOnly = function sendOnly(name, args) {\n    var obs = this.observers[name];\n\n    if (obs) {\n      obs.forEach(function (fn) {\n        try {\n          fn.apply(undefined, args);\n        } catch (error) {\n          console.log(error, error.stack);\n        }\n      });\n    }\n  };\n\n  _proto.send = function send(name, args) {\n    this.sendOnly(name + BEFORE_EVENT, args);\n    this.sendOnly(name, args);\n    this.sendOnly(name + AFTER_EVENT, args);\n  };\n\n  return EventHandler;\n}();\n\nexport default EventHandler;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { getCurrentScript, setLabel, merge, extend, isUndefined } from './utils';\nimport EventHandler from './event-handler';\nimport { CONFIG_CHANGE, LOCAL_CONFIG_KEY } from './constants';\n\nfunction getConfigFromScript() {\n  var script = getCurrentScript();\n  var config = getDataAttributesFromNode(script);\n  return config;\n}\n\nfunction getDataAttributesFromNode(node) {\n  if (!node) {\n    return {};\n  }\n\n  var dataAttrs = {};\n  var dataRegex = /^data-([\\w-]+)$/;\n  var attrs = node.attributes;\n\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n\n    if (dataRegex.test(attr.nodeName)) {\n      var key = attr.nodeName.match(dataRegex)[1];\n      var camelCasedkey = key.split('-').map(function (value, index) {\n        return index > 0 ? value.charAt(0).toUpperCase() + value.substring(1) : value;\n      }).join('');\n      dataAttrs[camelCasedkey] = attr.value || attr.nodeValue;\n    }\n  }\n\n  return dataAttrs;\n}\n\nvar Config = function () {\n  function Config() {\n    this.config = {\n      serviceName: '',\n      serviceVersion: '',\n      environment: '',\n      serverUrl: 'http://localhost:8200',\n      active: true,\n      instrument: true,\n      disableInstrumentations: [],\n      logLevel: 'warn',\n      breakdownMetrics: false,\n      ignoreTransactions: [],\n      eventsLimit: 80,\n      queueLimit: -1,\n      flushInterval: 500,\n      distributedTracing: true,\n      distributedTracingOrigins: [],\n      distributedTracingHeaderName: 'traceparent',\n      pageLoadTraceId: '',\n      pageLoadSpanId: '',\n      pageLoadSampled: false,\n      pageLoadTransactionName: '',\n      propagateTracestate: false,\n      transactionSampleRate: 1.0,\n      centralConfig: false,\n      monitorLongtasks: true,\n      apiVersion: 2,\n      context: {},\n      session: false,\n      apmRequest: null\n    };\n    this.events = new EventHandler();\n    this.filters = [];\n    this.version = '';\n  }\n\n  var _proto = Config.prototype;\n\n  _proto.init = function init() {\n    var scriptData = getConfigFromScript();\n    this.setConfig(scriptData);\n  };\n\n  _proto.setVersion = function setVersion(version) {\n    this.version = version;\n  };\n\n  _proto.addFilter = function addFilter(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('Argument to must be function');\n    }\n\n    this.filters.push(cb);\n  };\n\n  _proto.applyFilters = function applyFilters(data) {\n    for (var i = 0; i < this.filters.length; i++) {\n      data = this.filters[i](data);\n\n      if (!data) {\n        return;\n      }\n    }\n\n    return data;\n  };\n\n  _proto.get = function get(key) {\n    return key.split('.').reduce(function (obj, objKey) {\n      return obj && obj[objKey];\n    }, this.config);\n  };\n\n  _proto.setUserContext = function setUserContext(userContext) {\n    if (userContext === void 0) {\n      userContext = {};\n    }\n\n    var context = {};\n    var _userContext = userContext,\n        id = _userContext.id,\n        username = _userContext.username,\n        email = _userContext.email;\n\n    if (typeof id === 'number' || typeof id === 'string') {\n      context.id = id;\n    }\n\n    if (typeof username === 'string') {\n      context.username = username;\n    }\n\n    if (typeof email === 'string') {\n      context.email = email;\n    }\n\n    this.config.context.user = extend(this.config.context.user || {}, context);\n  };\n\n  _proto.setCustomContext = function setCustomContext(customContext) {\n    if (customContext === void 0) {\n      customContext = {};\n    }\n\n    this.config.context.custom = extend(this.config.context.custom || {}, customContext);\n  };\n\n  _proto.addLabels = function addLabels(tags) {\n    var _this = this;\n\n    if (!this.config.context.tags) {\n      this.config.context.tags = {};\n    }\n\n    var keys = Object.keys(tags);\n    keys.forEach(function (k) {\n      return setLabel(k, tags[k], _this.config.context.tags);\n    });\n  };\n\n  _proto.setConfig = function setConfig(properties) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    var _properties = properties,\n        transactionSampleRate = _properties.transactionSampleRate,\n        serverUrl = _properties.serverUrl;\n\n    if (serverUrl) {\n      properties.serverUrl = serverUrl.replace(/\\/+$/, '');\n    }\n\n    if (!isUndefined(transactionSampleRate)) {\n      if (transactionSampleRate < 0.0001 && transactionSampleRate > 0) {\n        transactionSampleRate = 0.0001;\n      }\n\n      properties.transactionSampleRate = Math.round(transactionSampleRate * 10000) / 10000;\n    }\n\n    merge(this.config, properties);\n    this.events.send(CONFIG_CHANGE, [this.config]);\n  };\n\n  _proto.validate = function validate(properties) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    var requiredKeys = ['serviceName', 'serverUrl'];\n    var errors = {\n      missing: [],\n      invalid: []\n    };\n    Object.keys(properties).forEach(function (key) {\n      if (requiredKeys.indexOf(key) !== -1 && !properties[key]) {\n        errors.missing.push(key);\n      }\n    });\n\n    if (properties.serviceName && !/^[a-zA-Z0-9 _-]+$/.test(properties.serviceName)) {\n      errors.invalid.push({\n        key: 'serviceName',\n        value: properties.serviceName,\n        allowed: 'a-z, A-Z, 0-9, _, -, <space>'\n      });\n    }\n\n    var sampleRate = properties.transactionSampleRate;\n\n    if (typeof sampleRate !== 'undefined' && (typeof sampleRate !== 'number' || isNaN(sampleRate) || sampleRate < 0 || sampleRate > 1)) {\n      errors.invalid.push({\n        key: 'transactionSampleRate',\n        value: sampleRate,\n        allowed: 'Number between 0 and 1'\n      });\n    }\n\n    return errors;\n  };\n\n  _proto.getLocalConfig = function getLocalConfig() {\n    var storage = sessionStorage;\n\n    if (this.config.session) {\n      storage = localStorage;\n    }\n\n    var config = storage.getItem(LOCAL_CONFIG_KEY);\n\n    if (config) {\n      return JSON.parse(config);\n    }\n  };\n\n  _proto.setLocalConfig = function setLocalConfig(config, merge) {\n    if (config) {\n      if (merge) {\n        var prevConfig = this.getLocalConfig();\n        config = _extends({}, prevConfig, config);\n      }\n\n      var storage = sessionStorage;\n\n      if (this.config.session) {\n        storage = localStorage;\n      }\n\n      storage.setItem(LOCAL_CONFIG_KEY, JSON.stringify(config));\n    }\n  };\n\n  return Config;\n}();\n\nexport default Config;","import { noop } from './utils';\n\nvar LoggingService = function () {\n  function LoggingService(spec) {\n    if (spec === void 0) {\n      spec = {};\n    }\n\n    this.levels = ['trace', 'debug', 'info', 'warn', 'error'];\n    this.level = spec.level || 'warn';\n    this.prefix = spec.prefix || '';\n    this.resetLogMethods();\n  }\n\n  var _proto = LoggingService.prototype;\n\n  _proto.shouldLog = function shouldLog(level) {\n    return this.levels.indexOf(level) >= this.levels.indexOf(this.level);\n  };\n\n  _proto.setLevel = function setLevel(level) {\n    if (level === this.level) {\n      return;\n    }\n\n    this.level = level;\n    this.resetLogMethods();\n  };\n\n  _proto.resetLogMethods = function resetLogMethods() {\n    var _this = this;\n\n    this.levels.forEach(function (level) {\n      _this[level] = _this.shouldLog(level) ? log : noop;\n\n      function log() {\n        var normalizedLevel = level;\n\n        if (level === 'trace' || level === 'debug') {\n          normalizedLevel = 'info';\n        }\n\n        var args = arguments;\n        args[0] = this.prefix + args[0];\n\n        if (console) {\n          var realMethod = console[normalizedLevel] || console.log;\n\n          if (typeof realMethod === 'function') {\n            realMethod.apply(console, args);\n          }\n        }\n      }\n    });\n  };\n\n  return LoggingService;\n}();\n\nexport default LoggingService;","var _serviceCreators;\n\nimport ApmServer from './apm-server';\nimport ConfigService from './config-service';\nimport LoggingService from './logging-service';\nimport { CONFIG_CHANGE, CONFIG_SERVICE, LOGGING_SERVICE, APM_SERVER } from './constants';\nimport { __DEV__ } from '../state';\nvar serviceCreators = (_serviceCreators = {}, _serviceCreators[CONFIG_SERVICE] = function () {\n  return new ConfigService();\n}, _serviceCreators[LOGGING_SERVICE] = function () {\n  return new LoggingService({\n    prefix: '[Elastic APM] '\n  });\n}, _serviceCreators[APM_SERVER] = function (factory) {\n  var _factory$getService = factory.getService([CONFIG_SERVICE, LOGGING_SERVICE]),\n      configService = _factory$getService[0],\n      loggingService = _factory$getService[1];\n\n  return new ApmServer(configService, loggingService);\n}, _serviceCreators);\n\nvar ServiceFactory = function () {\n  function ServiceFactory() {\n    this.instances = {};\n    this.initialized = false;\n  }\n\n  var _proto = ServiceFactory.prototype;\n\n  _proto.init = function init() {\n    if (this.initialized) {\n      return;\n    }\n\n    this.initialized = true;\n    var configService = this.getService(CONFIG_SERVICE);\n    configService.init();\n\n    var _this$getService = this.getService([LOGGING_SERVICE, APM_SERVER]),\n        loggingService = _this$getService[0],\n        apmServer = _this$getService[1];\n\n    configService.events.observe(CONFIG_CHANGE, function () {\n      var logLevel = configService.get('logLevel');\n      loggingService.setLevel(logLevel);\n    });\n    apmServer.init();\n  };\n\n  _proto.getService = function getService(name) {\n    var _this = this;\n\n    if (typeof name === 'string') {\n      if (!this.instances[name]) {\n        if (typeof serviceCreators[name] === 'function') {\n          this.instances[name] = serviceCreators[name](this);\n        } else if (__DEV__) {\n          console.log('Cannot get service, No creator for: ' + name);\n        }\n      }\n\n      return this.instances[name];\n    } else if (Array.isArray(name)) {\n      return name.map(function (n) {\n        return _this.getService(n);\n      });\n    }\n  };\n\n  return ServiceFactory;\n}();\n\nexport { serviceCreators, ServiceFactory };","import ErrorLogging from './error-logging';\nimport { CONFIG_SERVICE, APM_SERVER } from '../common/constants';\nimport { serviceCreators } from '../common/service-factory';\n\nfunction registerServices() {\n  serviceCreators['ErrorLogging'] = function (serviceFactory) {\n    var _serviceFactory$getSe = serviceFactory.getService([APM_SERVER, CONFIG_SERVICE, 'TransactionService']),\n        apmServer = _serviceFactory$getSe[0],\n        configService = _serviceFactory$getSe[1],\n        transactionService = _serviceFactory$getSe[2];\n\n    return new ErrorLogging(apmServer, configService, transactionService);\n  };\n}\n\nexport { registerServices };","import { patchMethod, XHR_SYNC, XHR_URL, XHR_METHOD, XHR_IGNORE } from './patch-utils';\nimport { SCHEDULE, INVOKE, XMLHTTPREQUEST, ADD_EVENT_LISTENER_STR } from '../constants';\nexport function patchXMLHttpRequest(callback) {\n  var XMLHttpRequestPrototype = XMLHttpRequest.prototype;\n\n  if (!XMLHttpRequestPrototype || !XMLHttpRequestPrototype[ADD_EVENT_LISTENER_STR]) {\n    return;\n  }\n\n  var READY_STATE_CHANGE = 'readystatechange';\n  var LOAD = 'load';\n  var ERROR = 'error';\n  var TIMEOUT = 'timeout';\n  var ABORT = 'abort';\n\n  function invokeTask(task, status) {\n    if (task.state !== INVOKE) {\n      task.state = INVOKE;\n      task.data.status = status;\n      callback(INVOKE, task);\n    }\n  }\n\n  function scheduleTask(task) {\n    if (task.state === SCHEDULE) {\n      return;\n    }\n\n    task.state = SCHEDULE;\n    callback(SCHEDULE, task);\n    var target = task.data.target;\n\n    function addListener(name) {\n      target[ADD_EVENT_LISTENER_STR](name, function (_ref) {\n        var type = _ref.type;\n\n        if (type === READY_STATE_CHANGE) {\n          if (target.readyState === 4 && target.status !== 0) {\n            invokeTask(task, 'success');\n          }\n        } else {\n          var status = type === LOAD ? 'success' : type;\n          invokeTask(task, status);\n        }\n      });\n    }\n\n    addListener(READY_STATE_CHANGE);\n    addListener(LOAD);\n    addListener(TIMEOUT);\n    addListener(ERROR);\n    addListener(ABORT);\n  }\n\n  var openNative = patchMethod(XMLHttpRequestPrototype, 'open', function () {\n    return function (self, args) {\n      if (!self[XHR_IGNORE]) {\n        self[XHR_METHOD] = args[0];\n        self[XHR_URL] = args[1];\n        self[XHR_SYNC] = args[2] === false;\n      }\n\n      return openNative.apply(self, args);\n    };\n  });\n  var sendNative = patchMethod(XMLHttpRequestPrototype, 'send', function () {\n    return function (self, args) {\n      if (self[XHR_IGNORE]) {\n        return sendNative.apply(self, args);\n      }\n\n      var task = {\n        source: XMLHTTPREQUEST,\n        state: '',\n        type: 'macroTask',\n        data: {\n          target: self,\n          method: self[XHR_METHOD],\n          sync: self[XHR_SYNC],\n          url: self[XHR_URL],\n          status: ''\n        }\n      };\n\n      try {\n        scheduleTask(task);\n        return sendNative.apply(self, args);\n      } catch (e) {\n        invokeTask(task, ERROR);\n        throw e;\n      }\n    };\n  });\n}","import { Promise } from '../polyfills';\nimport { globalState } from './patch-utils';\nimport { SCHEDULE, INVOKE, FETCH } from '../constants';\nimport { scheduleMicroTask } from '../utils';\nexport function patchFetch(callback) {\n  if (!window.fetch || !window.Request) {\n    return;\n  }\n\n  function scheduleTask(task) {\n    task.state = SCHEDULE;\n    callback(SCHEDULE, task);\n  }\n\n  function invokeTask(task) {\n    task.state = INVOKE;\n    callback(INVOKE, task);\n  }\n\n  var nativeFetch = window.fetch;\n\n  window.fetch = function (input, init) {\n    var fetchSelf = this;\n    var args = arguments;\n    var request, url;\n\n    if (typeof input === 'string') {\n      request = new Request(input, init);\n      url = input;\n    } else if (input) {\n      request = input;\n      url = request.url;\n    } else {\n      return nativeFetch.apply(fetchSelf, args);\n    }\n\n    var task = {\n      source: FETCH,\n      state: '',\n      type: 'macroTask',\n      data: {\n        target: request,\n        method: request.method,\n        url: url,\n        aborted: false\n      }\n    };\n    return new Promise(function (resolve, reject) {\n      globalState.fetchInProgress = true;\n      scheduleTask(task);\n      var promise;\n\n      try {\n        promise = nativeFetch.apply(fetchSelf, [request]);\n      } catch (error) {\n        reject(error);\n        task.data.error = error;\n        invokeTask(task);\n        globalState.fetchInProgress = false;\n        return;\n      }\n\n      promise.then(function (response) {\n        resolve(response);\n        scheduleMicroTask(function () {\n          task.data.response = response;\n          invokeTask(task);\n        });\n      }, function (error) {\n        reject(error);\n        scheduleMicroTask(function () {\n          task.data.error = error;\n          invokeTask(task);\n        });\n      });\n      globalState.fetchInProgress = false;\n    });\n  };\n}","import { INVOKE, HISTORY } from '../constants';\nexport function patchHistory(callback) {\n  if (!window.history) {\n    return;\n  }\n\n  var nativePushState = history.pushState;\n\n  if (typeof nativePushState === 'function') {\n    history.pushState = function (state, title, url) {\n      var task = {\n        source: HISTORY,\n        data: {\n          state: state,\n          title: title,\n          url: url\n        }\n      };\n      callback(INVOKE, task);\n      nativePushState.apply(this, arguments);\n    };\n  }\n}","import { SCHEDULE, INVOKE, ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, EVENT_TARGET } from '../constants';\nimport { apmSymbol } from './patch-utils';\nvar eventTypes = ['click'];\nvar eventTypeSymbols = {};\n\nfor (var i = 0; i < eventTypes.length; i++) {\n  var et = eventTypes[i];\n  eventTypeSymbols[et] = apmSymbol(et);\n}\n\nfunction shouldInstrumentEvent(target, eventType, listenerFn) {\n  return target instanceof Element && eventTypes.indexOf(eventType) >= 0 && typeof listenerFn === 'function';\n}\n\nexport function patchEventTarget(callback) {\n  if (!window.EventTarget) {\n    return;\n  }\n\n  var proto = window.EventTarget.prototype;\n  var nativeAddEventListener = proto[ADD_EVENT_LISTENER_STR];\n  var nativeRemoveEventListener = proto[REMOVE_EVENT_LISTENER_STR];\n\n  function findTaskIndex(existingTasks, eventType, listenerFn, capture) {\n    for (var _i = 0; _i < existingTasks.length; _i++) {\n      var task = existingTasks[_i];\n\n      if (task.eventType === eventType && task.listenerFn === listenerFn && task.capture === capture) {\n        return _i;\n      }\n    }\n\n    return -1;\n  }\n\n  function isCapture(options) {\n    var capture;\n\n    if (typeof options === 'boolean') {\n      capture = options;\n    } else {\n      capture = options ? !!options.capture : false;\n    }\n\n    return capture;\n  }\n\n  function createListenerWrapper(target, eventType, listenerFn, options) {\n    var eventSymbol = eventTypeSymbols[eventType];\n    if (!eventSymbol) return listenerFn;\n    var existingTasks = target[eventSymbol];\n    var capture = isCapture(options);\n\n    if (existingTasks) {\n      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);\n\n      if (taskIndex !== -1) {\n        var _task = existingTasks[taskIndex];\n        return _task.wrappingFn;\n      }\n    } else {\n      existingTasks = target[eventSymbol] = [];\n    }\n\n    var task = {\n      source: EVENT_TARGET,\n      target: target,\n      eventType: eventType,\n      listenerFn: listenerFn,\n      capture: capture,\n      wrappingFn: wrappingFn\n    };\n    existingTasks.push(task);\n\n    function wrappingFn() {\n      callback(SCHEDULE, task);\n      var result;\n\n      try {\n        result = listenerFn.apply(this, arguments);\n      } finally {\n        callback(INVOKE, task);\n      }\n\n      return result;\n    }\n\n    return wrappingFn;\n  }\n\n  function getWrappingFn(target, eventType, listenerFn, options) {\n    var eventSymbol = eventTypeSymbols[eventType];\n    var existingTasks = target[eventSymbol];\n\n    if (existingTasks) {\n      var capture = isCapture(options);\n      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);\n\n      if (taskIndex !== -1) {\n        var task = existingTasks[taskIndex];\n        existingTasks.splice(taskIndex, 1);\n\n        if (existingTasks.length === 0) {\n          target[eventSymbol] = undefined;\n        }\n\n        return task.wrappingFn;\n      }\n    }\n\n    return listenerFn;\n  }\n\n  proto[ADD_EVENT_LISTENER_STR] = function (eventType, listenerFn, optionsOrCapture) {\n    var target = this;\n\n    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {\n      return nativeAddEventListener.apply(target, arguments);\n    }\n\n    var wrappingListenerFn = createListenerWrapper(target, eventType, listenerFn, optionsOrCapture);\n    var args = Array.prototype.slice.call(arguments);\n    args[1] = wrappingListenerFn;\n    return nativeAddEventListener.apply(target, args);\n  };\n\n  proto[REMOVE_EVENT_LISTENER_STR] = function (eventType, listenerFn, optionsOrCapture) {\n    var target = this;\n\n    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {\n      return nativeRemoveEventListener.apply(target, arguments);\n    }\n\n    var wrappingFn = getWrappingFn(target, eventType, listenerFn, optionsOrCapture);\n    var args = Array.prototype.slice.call(arguments);\n    args[1] = wrappingFn;\n    return nativeRemoveEventListener.apply(target, args);\n  };\n}","import { patchXMLHttpRequest } from './xhr-patch';\nimport { patchFetch } from './fetch-patch';\nimport { patchHistory } from './history-patch';\nimport { patchEventTarget } from './event-target-patch';\nimport EventHandler from '../event-handler';\nimport { HISTORY, FETCH, XMLHTTPREQUEST, EVENT_TARGET } from '../constants';\nvar patchEventHandler = new EventHandler();\nvar alreadyPatched = false;\n\nfunction patchAll() {\n  if (!alreadyPatched) {\n    alreadyPatched = true;\n    patchXMLHttpRequest(function (event, task) {\n      patchEventHandler.send(XMLHTTPREQUEST, [event, task]);\n    });\n    patchFetch(function (event, task) {\n      patchEventHandler.send(FETCH, [event, task]);\n    });\n    patchHistory(function (event, task) {\n      patchEventHandler.send(HISTORY, [event, task]);\n    });\n    patchEventTarget(function (event, task) {\n      patchEventHandler.send(EVENT_TARGET, [event, task]);\n    });\n  }\n\n  return patchEventHandler;\n}\n\nexport { patchAll, patchEventHandler };","import { checkSameOrigin, isDtHeaderValid, parseDtHeaderValue, getDtHeaderValue, getTSHeaderValue, stripQueryStringFromUrl, setRequestHeader } from '../common/utils';\nimport { Url } from '../common/url';\nimport { patchEventHandler } from '../common/patching';\nimport { globalState } from '../common/patching/patch-utils';\nimport { SCHEDULE, INVOKE, TRANSACTION_END, AFTER_EVENT, FETCH, HISTORY, XMLHTTPREQUEST, EVENT_TARGET, HTTP_REQUEST_TYPE, USER_INTERACTION, OUTCOME_FAILURE, OUTCOME_SUCCESS } from '../common/constants';\nimport { truncateModel, SPAN_MODEL, TRANSACTION_MODEL } from '../common/truncate';\nimport { __DEV__ } from '../state';\nvar SIMILAR_SPAN_TO_TRANSACTION_RATIO = 0.05;\nvar TRANSACTION_DURATION_THRESHOLD = 60000;\nexport function groupSmallContinuouslySimilarSpans(originalSpans, transDuration, threshold) {\n  originalSpans.sort(function (spanA, spanB) {\n    return spanA._start - spanB._start;\n  });\n  var spans = [];\n  var lastCount = 1;\n  originalSpans.forEach(function (span, index) {\n    if (spans.length === 0) {\n      spans.push(span);\n    } else {\n      var lastSpan = spans[spans.length - 1];\n      var isContinuouslySimilar = lastSpan.type === span.type && lastSpan.subtype === span.subtype && lastSpan.action === span.action && lastSpan.name === span.name && span.duration() / transDuration < threshold && (span._start - lastSpan._end) / transDuration < threshold;\n      var isLastSpan = originalSpans.length === index + 1;\n\n      if (isContinuouslySimilar) {\n        lastCount++;\n        lastSpan._end = span._end;\n      }\n\n      if (lastCount > 1 && (!isContinuouslySimilar || isLastSpan)) {\n        lastSpan.name = lastCount + 'x ' + lastSpan.name;\n        lastCount = 1;\n      }\n\n      if (!isContinuouslySimilar) {\n        spans.push(span);\n      }\n    }\n  });\n  return spans;\n}\nexport function adjustTransaction(transaction) {\n  if (transaction.sampled) {\n    var filterdSpans = transaction.spans.filter(function (span) {\n      return span.duration() > 0 && span._start >= transaction._start && span._end <= transaction._end;\n    });\n\n    if (transaction.isManaged()) {\n      var duration = transaction.duration();\n      var similarSpans = groupSmallContinuouslySimilarSpans(filterdSpans, duration, SIMILAR_SPAN_TO_TRANSACTION_RATIO);\n      transaction.spans = similarSpans;\n    } else {\n      transaction.spans = filterdSpans;\n    }\n  } else {\n    transaction.resetFields();\n  }\n\n  return transaction;\n}\n\nvar PerformanceMonitoring = function () {\n  function PerformanceMonitoring(apmServer, configService, loggingService, transactionService) {\n    this._apmServer = apmServer;\n    this._configService = configService;\n    this._logginService = loggingService;\n    this._transactionService = transactionService;\n  }\n\n  var _proto = PerformanceMonitoring.prototype;\n\n  _proto.init = function init(flags) {\n    var _this = this;\n\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    this._configService.events.observe(TRANSACTION_END + AFTER_EVENT, function (tr) {\n      var payload = _this.createTransactionPayload(tr);\n\n      if (payload) {\n        _this._apmServer.addTransaction(payload);\n      }\n    });\n\n    if (flags[HISTORY]) {\n      patchEventHandler.observe(HISTORY, this.getHistorySub());\n    }\n\n    if (flags[XMLHTTPREQUEST]) {\n      patchEventHandler.observe(XMLHTTPREQUEST, this.getXHRSub());\n    }\n\n    if (flags[FETCH]) {\n      patchEventHandler.observe(FETCH, this.getFetchSub());\n    }\n\n    if (flags[EVENT_TARGET]) {\n      patchEventHandler.observe(EVENT_TARGET, this.getEventTargetSub());\n    }\n  };\n\n  _proto.getEventTargetSub = function getEventTargetSub() {\n    var transactionService = this._transactionService;\n    return function (event, task) {\n      if (event === SCHEDULE && task.source === EVENT_TARGET && task.eventType === 'click') {\n        var target = task.target;\n        var name = target.getAttribute('name');\n        var additionalInfo = '';\n\n        if (name) {\n          additionalInfo = \"[\\\"\" + name + \"\\\"]\";\n        }\n\n        var tagName = target.tagName.toLowerCase();\n        var tr = transactionService.startTransaction(\"Click - \" + tagName + additionalInfo, USER_INTERACTION, {\n          managed: true,\n          canReuse: true,\n          reuseThreshold: 300\n        });\n\n        if (tr) {\n          var classes = target.getAttribute('class');\n\n          if (classes) {\n            tr.addContext({\n              custom: {\n                classes: classes\n              }\n            });\n          }\n        }\n      }\n    };\n  };\n\n  _proto.getHistorySub = function getHistorySub() {\n    var transactionService = this._transactionService;\n    return function (event, task) {\n      if (task.source === HISTORY && event === INVOKE) {\n        transactionService.startTransaction(task.data.title, 'route-change', {\n          managed: true,\n          canReuse: true\n        });\n      }\n    };\n  };\n\n  _proto.getXHRSub = function getXHRSub() {\n    var _this2 = this;\n\n    return function (event, task) {\n      if (task.source === XMLHTTPREQUEST && !globalState.fetchInProgress) {\n        _this2.processAPICalls(event, task);\n      }\n    };\n  };\n\n  _proto.getFetchSub = function getFetchSub() {\n    var _this3 = this;\n\n    return function (event, task) {\n      if (task.source === FETCH) {\n        _this3.processAPICalls(event, task);\n      }\n    };\n  };\n\n  _proto.processAPICalls = function processAPICalls(event, task) {\n    var configService = this._configService;\n    var transactionService = this._transactionService;\n\n    if (event === SCHEDULE && task.data) {\n      var data = task.data;\n      var requestUrl = new Url(data.url);\n      var spanName = data.method + ' ' + (requestUrl.relative ? requestUrl.path : stripQueryStringFromUrl(requestUrl.href));\n\n      if (!transactionService.getCurrentTransaction()) {\n        transactionService.startTransaction(spanName, HTTP_REQUEST_TYPE, {\n          managed: true\n        });\n      }\n\n      var span = transactionService.startSpan(spanName, 'external.http', {\n        blocking: true\n      });\n\n      if (!span) {\n        return;\n      }\n\n      var isDtEnabled = configService.get('distributedTracing');\n      var dtOrigins = configService.get('distributedTracingOrigins');\n      var currentUrl = new Url(window.location.href);\n      var isSameOrigin = checkSameOrigin(requestUrl.origin, currentUrl.origin) || checkSameOrigin(requestUrl.origin, dtOrigins);\n      var target = data.target;\n\n      if (isDtEnabled && isSameOrigin && target) {\n        this.injectDtHeader(span, target);\n        var propagateTracestate = configService.get('propagateTracestate');\n\n        if (propagateTracestate) {\n          this.injectTSHeader(span, target);\n        }\n      } else if (__DEV__) {\n        this._logginService.debug(\"Could not inject distributed tracing header to the request origin ('\" + requestUrl.origin + \"') from the current origin ('\" + currentUrl.origin + \"')\");\n      }\n\n      if (data.sync) {\n        span.sync = data.sync;\n      }\n\n      data.span = span;\n    } else if (event === INVOKE) {\n      var _data = task.data;\n\n      if (_data && _data.span) {\n        var _span = _data.span,\n            response = _data.response,\n            _target = _data.target;\n        var status;\n\n        if (response) {\n          status = response.status;\n        } else {\n          status = _target.status;\n        }\n\n        var outcome;\n\n        if (_data.status != 'abort') {\n          if (status >= 400 || status == 0) {\n            outcome = OUTCOME_FAILURE;\n          } else {\n            outcome = OUTCOME_SUCCESS;\n          }\n        }\n\n        _span.outcome = outcome;\n        var tr = transactionService.getCurrentTransaction();\n\n        if (tr && tr.type === HTTP_REQUEST_TYPE) {\n          tr.outcome = outcome;\n        }\n\n        transactionService.endSpan(_span, _data);\n      }\n    }\n  };\n\n  _proto.injectDtHeader = function injectDtHeader(span, target) {\n    var headerName = this._configService.get('distributedTracingHeaderName');\n\n    var headerValue = getDtHeaderValue(span);\n    var isHeaderValid = isDtHeaderValid(headerValue);\n\n    if (isHeaderValid && headerValue && headerName) {\n      setRequestHeader(target, headerName, headerValue);\n    }\n  };\n\n  _proto.injectTSHeader = function injectTSHeader(span, target) {\n    var headerValue = getTSHeaderValue(span);\n\n    if (headerValue) {\n      setRequestHeader(target, 'tracestate', headerValue);\n    }\n  };\n\n  _proto.extractDtHeader = function extractDtHeader(target) {\n    var configService = this._configService;\n    var headerName = configService.get('distributedTracingHeaderName');\n\n    if (target) {\n      return parseDtHeaderValue(target[headerName]);\n    }\n  };\n\n  _proto.filterTransaction = function filterTransaction(tr) {\n    var duration = tr.duration();\n\n    if (!duration) {\n      if (__DEV__) {\n        var message = \"transaction(\" + tr.id + \", \" + tr.name + \") was discarded! \";\n\n        if (duration === 0) {\n          message += \"Transaction duration is 0\";\n        } else {\n          message += \"Transaction wasn't ended\";\n        }\n\n        this._logginService.debug(message);\n      }\n\n      return false;\n    }\n\n    if (tr.isManaged()) {\n      if (duration > TRANSACTION_DURATION_THRESHOLD) {\n        if (__DEV__) {\n          this._logginService.debug(\"transaction(\" + tr.id + \", \" + tr.name + \") was discarded! Transaction duration (\" + duration + \") is greater than managed transaction threshold (\" + TRANSACTION_DURATION_THRESHOLD + \")\");\n        }\n\n        return false;\n      }\n\n      if (tr.sampled && tr.spans.length === 0) {\n        if (__DEV__) {\n          this._logginService.debug(\"transaction(\" + tr.id + \", \" + tr.name + \") was discarded! Transaction does not have any spans\");\n        }\n\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  _proto.createTransactionDataModel = function createTransactionDataModel(transaction) {\n    var transactionStart = transaction._start;\n    var spans = transaction.spans.map(function (span) {\n      var spanData = {\n        id: span.id,\n        transaction_id: transaction.id,\n        parent_id: span.parentId || transaction.id,\n        trace_id: transaction.traceId,\n        name: span.name,\n        type: span.type,\n        subtype: span.subtype,\n        action: span.action,\n        sync: span.sync,\n        start: parseInt(span._start - transactionStart),\n        duration: span.duration(),\n        context: span.context,\n        outcome: span.outcome,\n        sample_rate: span.sampleRate\n      };\n      return truncateModel(SPAN_MODEL, spanData);\n    });\n    var transactionData = {\n      id: transaction.id,\n      trace_id: transaction.traceId,\n      session: transaction.session,\n      name: transaction.name,\n      type: transaction.type,\n      duration: transaction.duration(),\n      spans: spans,\n      context: transaction.context,\n      marks: transaction.marks,\n      breakdown: transaction.breakdownTimings,\n      span_count: {\n        started: spans.length\n      },\n      sampled: transaction.sampled,\n      sample_rate: transaction.sampleRate,\n      experience: transaction.experience,\n      outcome: transaction.outcome\n    };\n    return truncateModel(TRANSACTION_MODEL, transactionData);\n  };\n\n  _proto.createTransactionPayload = function createTransactionPayload(transaction) {\n    var adjustedTransaction = adjustTransaction(transaction);\n    var filtered = this.filterTransaction(adjustedTransaction);\n\n    if (filtered) {\n      return this.createTransactionDataModel(transaction);\n    }\n  };\n\n  return PerformanceMonitoring;\n}();\n\nexport { PerformanceMonitoring as default };","import { getDuration, PERF } from '../common/utils';\nimport { PAGE_LOAD, TRUNCATED_TYPE } from '../common/constants';\nvar pageLoadBreakdowns = [['domainLookupStart', 'domainLookupEnd', 'DNS'], ['connectStart', 'connectEnd', 'TCP'], ['requestStart', 'responseStart', 'Request'], ['responseStart', 'responseEnd', 'Response'], ['domLoading', 'domComplete', 'Processing'], ['loadEventStart', 'loadEventEnd', 'Load']];\n\nfunction getValue(value) {\n  return {\n    value: value\n  };\n}\n\nfunction calculateSelfTime(transaction) {\n  var spans = transaction.spans,\n      _start = transaction._start,\n      _end = transaction._end;\n\n  if (spans.length === 0) {\n    return transaction.duration();\n  }\n\n  spans.sort(function (span1, span2) {\n    return span1._start - span2._start;\n  });\n  var span = spans[0];\n  var spanEnd = span._end;\n  var spanStart = span._start;\n  var lastContinuousEnd = spanEnd;\n  var selfTime = spanStart - _start;\n\n  for (var i = 1; i < spans.length; i++) {\n    span = spans[i];\n    spanStart = span._start;\n    spanEnd = span._end;\n\n    if (spanStart > lastContinuousEnd) {\n      selfTime += spanStart - lastContinuousEnd;\n      lastContinuousEnd = spanEnd;\n    } else if (spanEnd > lastContinuousEnd) {\n      lastContinuousEnd = spanEnd;\n    }\n  }\n\n  if (lastContinuousEnd < _end) {\n    selfTime += _end - lastContinuousEnd;\n  }\n\n  return selfTime;\n}\n\nfunction groupSpans(transaction) {\n  var spanMap = {};\n  var transactionSelfTime = calculateSelfTime(transaction);\n  spanMap['app'] = {\n    count: 1,\n    duration: transactionSelfTime\n  };\n  var spans = transaction.spans;\n\n  for (var i = 0; i < spans.length; i++) {\n    var span = spans[i];\n    var duration = span.duration();\n\n    if (duration === 0 || duration == null) {\n      continue;\n    }\n\n    var type = span.type,\n        subtype = span.subtype;\n    var key = type.replace(TRUNCATED_TYPE, '');\n\n    if (subtype) {\n      key += '.' + subtype;\n    }\n\n    if (!spanMap[key]) {\n      spanMap[key] = {\n        duration: 0,\n        count: 0\n      };\n    }\n\n    spanMap[key].count++;\n    spanMap[key].duration += duration;\n  }\n\n  return spanMap;\n}\n\nfunction getSpanBreakdown(transactionDetails, _ref) {\n  var details = _ref.details,\n      _ref$count = _ref.count,\n      count = _ref$count === void 0 ? 1 : _ref$count,\n      duration = _ref.duration;\n  return {\n    transaction: transactionDetails,\n    span: details,\n    samples: {\n      'span.self_time.count': getValue(count),\n      'span.self_time.sum.us': getValue(duration)\n    }\n  };\n}\n\nexport function captureBreakdown(transaction, timings) {\n  if (timings === void 0) {\n    timings = PERF.timing;\n  }\n\n  var breakdowns = [];\n  var trDuration = transaction.duration();\n  var name = transaction.name,\n      type = transaction.type,\n      sampled = transaction.sampled;\n  var transactionDetails = {\n    name: name,\n    type: type\n  };\n  breakdowns.push({\n    transaction: transactionDetails,\n    samples: {\n      'transaction.duration.count': getValue(1),\n      'transaction.duration.sum.us': getValue(trDuration),\n      'transaction.breakdown.count': getValue(sampled ? 1 : 0)\n    }\n  });\n\n  if (!sampled) {\n    return breakdowns;\n  }\n\n  if (type === PAGE_LOAD && timings) {\n    for (var i = 0; i < pageLoadBreakdowns.length; i++) {\n      var current = pageLoadBreakdowns[i];\n      var start = timings[current[0]];\n      var end = timings[current[1]];\n      var duration = getDuration(start, end);\n\n      if (duration === 0 || duration == null) {\n        continue;\n      }\n\n      breakdowns.push(getSpanBreakdown(transactionDetails, {\n        details: {\n          type: current[2]\n        },\n        duration: duration\n      }));\n    }\n  } else {\n    var spanMap = groupSpans(transaction);\n    Object.keys(spanMap).forEach(function (key) {\n      var _key$split = key.split('.'),\n          type = _key$split[0],\n          subtype = _key$split[1];\n\n      var _spanMap$key = spanMap[key],\n          duration = _spanMap$key.duration,\n          count = _spanMap$key.count;\n      breakdowns.push(getSpanBreakdown(transactionDetails, {\n        details: {\n          type: type,\n          subtype: subtype\n        },\n        duration: duration,\n        count: count\n      }));\n    });\n  }\n\n  return breakdowns;\n}","function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport Span from './span';\nimport SpanBase from './span-base';\nimport { generateRandomId, merge, now, getTime, extend, removeInvalidChars } from '../common/utils';\nimport { REUSABILITY_THRESHOLD, TRUNCATED_TYPE } from '../common/constants';\nimport { captureBreakdown as _captureBreakdown } from './breakdown';\n\nvar Transaction = function (_SpanBase) {\n  _inheritsLoose(Transaction, _SpanBase);\n\n  function Transaction(name, type, options) {\n    var _this;\n\n    _this = _SpanBase.call(this, name, type, options) || this;\n    _this.traceId = generateRandomId();\n    _this.marks = undefined;\n    _this.spans = [];\n    _this._activeSpans = {};\n    _this._activeTasks = new Set();\n    _this.blocked = false;\n    _this.captureTimings = false;\n    _this.breakdownTimings = [];\n    _this.sampleRate = _this.options.transactionSampleRate;\n    _this.sampled = Math.random() <= _this.sampleRate;\n    return _this;\n  }\n\n  var _proto = Transaction.prototype;\n\n  _proto.addMarks = function addMarks(obj) {\n    this.marks = merge(this.marks || {}, obj);\n  };\n\n  _proto.mark = function mark(key) {\n    var skey = removeInvalidChars(key);\n\n    var markTime = now() - this._start;\n\n    var custom = {};\n    custom[skey] = markTime;\n    this.addMarks({\n      custom: custom\n    });\n  };\n\n  _proto.canReuse = function canReuse() {\n    var threshold = this.options.reuseThreshold || REUSABILITY_THRESHOLD;\n    return !!this.options.canReuse && !this.ended && now() - this._start < threshold;\n  };\n\n  _proto.redefine = function redefine(name, type, options) {\n    if (name) {\n      this.name = name;\n    }\n\n    if (type) {\n      this.type = type;\n    }\n\n    if (options) {\n      extend(this.options, options);\n    }\n  };\n\n  _proto.startSpan = function startSpan(name, type, options) {\n    var _this2 = this;\n\n    if (this.ended) {\n      return;\n    }\n\n    var opts = extend({}, options);\n\n    opts.onEnd = function (trc) {\n      _this2._onSpanEnd(trc);\n    };\n\n    opts.traceId = this.traceId;\n    opts.sampled = this.sampled;\n    opts.sampleRate = this.sampleRate;\n\n    if (!opts.parentId) {\n      opts.parentId = this.id;\n    }\n\n    var span = new Span(name, type, opts);\n    this._activeSpans[span.id] = span;\n\n    if (opts.blocking) {\n      this.addTask(span.id);\n    }\n\n    return span;\n  };\n\n  _proto.isFinished = function isFinished() {\n    return !this.blocked && this._activeTasks.size === 0;\n  };\n\n  _proto.detectFinish = function detectFinish() {\n    if (this.isFinished()) this.end();\n  };\n\n  _proto.end = function end(endTime) {\n    if (this.ended) {\n      return;\n    }\n\n    this.ended = true;\n    this._end = getTime(endTime);\n\n    for (var sid in this._activeSpans) {\n      var span = this._activeSpans[sid];\n      span.type = span.type + TRUNCATED_TYPE;\n      span.end(endTime);\n    }\n\n    this.callOnEnd();\n  };\n\n  _proto.captureBreakdown = function captureBreakdown() {\n    this.breakdownTimings = _captureBreakdown(this);\n  };\n\n  _proto.block = function block(flag) {\n    this.blocked = flag;\n\n    if (!this.blocked) {\n      this.detectFinish();\n    }\n  };\n\n  _proto.addTask = function addTask(taskId) {\n    if (!taskId) {\n      taskId = 'task-' + generateRandomId(16);\n    }\n\n    this._activeTasks.add(taskId);\n\n    return taskId;\n  };\n\n  _proto.removeTask = function removeTask(taskId) {\n    var deleted = this._activeTasks.delete(taskId);\n\n    deleted && this.detectFinish();\n  };\n\n  _proto.resetFields = function resetFields() {\n    this.spans = [];\n    this.sampleRate = 0;\n  };\n\n  _proto._onSpanEnd = function _onSpanEnd(span) {\n    this.spans.push(span);\n    delete this._activeSpans[span.id];\n    this.removeTask(span.id);\n  };\n\n  _proto.isManaged = function isManaged() {\n    return !!this.options.managed;\n  };\n\n  return Transaction;\n}(SpanBase);\n\nexport default Transaction;","import { LONG_TASK, LARGEST_CONTENTFUL_PAINT, FIRST_CONTENTFUL_PAINT, FIRST_INPUT, LAYOUT_SHIFT } from '../common/constants';\nimport { noop, PERF } from '../common/utils';\nimport Span from './span';\nexport var metrics = {\n  fid: 0,\n  fcp: 0,\n  tbt: {\n    start: Infinity,\n    duration: 0\n  },\n  cls: 0,\n  longtask: {\n    count: 0,\n    duration: 0,\n    max: 0\n  }\n};\nvar LONG_TASK_THRESHOLD = 50;\nexport function createLongTaskSpans(longtasks, agg) {\n  var spans = [];\n\n  for (var i = 0; i < longtasks.length; i++) {\n    var _longtasks$i = longtasks[i],\n        name = _longtasks$i.name,\n        startTime = _longtasks$i.startTime,\n        duration = _longtasks$i.duration,\n        attribution = _longtasks$i.attribution;\n    var end = startTime + duration;\n    var span = new Span(\"Longtask(\" + name + \")\", LONG_TASK, {\n      startTime: startTime\n    });\n    agg.count++;\n    agg.duration += duration;\n    agg.max = Math.max(duration, agg.max);\n\n    if (attribution.length > 0) {\n      var _attribution$ = attribution[0],\n          _name = _attribution$.name,\n          containerType = _attribution$.containerType,\n          containerName = _attribution$.containerName,\n          containerId = _attribution$.containerId;\n      var customContext = {\n        attribution: _name,\n        type: containerType\n      };\n\n      if (containerName) {\n        customContext.name = containerName;\n      }\n\n      if (containerId) {\n        customContext.id = containerId;\n      }\n\n      span.addContext({\n        custom: customContext\n      });\n    }\n\n    span.end(end);\n    spans.push(span);\n  }\n\n  return spans;\n}\nexport function createFirstInputDelaySpan(fidEntries) {\n  var firstInput = fidEntries[0];\n\n  if (firstInput) {\n    var startTime = firstInput.startTime,\n        processingStart = firstInput.processingStart;\n    var span = new Span('First Input Delay', FIRST_INPUT, {\n      startTime: startTime\n    });\n    span.end(processingStart);\n    return span;\n  }\n}\nexport function createTotalBlockingTimeSpan(tbtObject) {\n  var start = tbtObject.start,\n      duration = tbtObject.duration;\n  var tbtSpan = new Span('Total Blocking Time', LONG_TASK, {\n    startTime: start\n  });\n  tbtSpan.end(start + duration);\n  return tbtSpan;\n}\nexport function calculateTotalBlockingTime(longtaskEntries) {\n  longtaskEntries.forEach(function (entry) {\n    var name = entry.name,\n        startTime = entry.startTime,\n        duration = entry.duration;\n\n    if (startTime < metrics.fcp) {\n      return;\n    }\n\n    if (name !== 'self' && name.indexOf('same-origin') === -1) {\n      return;\n    }\n\n    metrics.tbt.start = Math.min(metrics.tbt.start, startTime);\n    var blockingTime = duration - LONG_TASK_THRESHOLD;\n\n    if (blockingTime > 0) {\n      metrics.tbt.duration += blockingTime;\n    }\n  });\n}\nexport function calculateCumulativeLayoutShift(clsEntries) {\n  clsEntries.forEach(function (entry) {\n    if (!entry.hadRecentInput && entry.value) {\n      metrics.cls += entry.value;\n    }\n  });\n}\nexport function captureObserverEntries(list, _ref) {\n  var isHardNavigation = _ref.isHardNavigation,\n      trStart = _ref.trStart;\n  var longtaskEntries = list.getEntriesByType(LONG_TASK).filter(function (entry) {\n    return entry.startTime >= trStart;\n  });\n  var longTaskSpans = createLongTaskSpans(longtaskEntries, metrics.longtask);\n  var result = {\n    spans: longTaskSpans,\n    marks: {}\n  };\n\n  if (!isHardNavigation) {\n    return result;\n  }\n\n  var lcpEntries = list.getEntriesByType(LARGEST_CONTENTFUL_PAINT);\n  var lastLcpEntry = lcpEntries[lcpEntries.length - 1];\n\n  if (lastLcpEntry) {\n    var lcp = parseInt(lastLcpEntry.startTime);\n    metrics.lcp = lcp;\n    result.marks.largestContentfulPaint = lcp;\n  }\n\n  var timing = PERF.timing;\n  var unloadDiff = timing.fetchStart - timing.navigationStart;\n  var fcpEntry = list.getEntriesByName(FIRST_CONTENTFUL_PAINT)[0];\n\n  if (fcpEntry) {\n    var fcp = parseInt(unloadDiff >= 0 ? fcpEntry.startTime - unloadDiff : fcpEntry.startTime);\n    metrics.fcp = fcp;\n    result.marks.firstContentfulPaint = fcp;\n  }\n\n  var fidEntries = list.getEntriesByType(FIRST_INPUT);\n  var fidSpan = createFirstInputDelaySpan(fidEntries);\n\n  if (fidSpan) {\n    metrics.fid = fidSpan.duration();\n    result.spans.push(fidSpan);\n  }\n\n  calculateTotalBlockingTime(longtaskEntries);\n  var clsEntries = list.getEntriesByType(LAYOUT_SHIFT);\n  calculateCumulativeLayoutShift(clsEntries);\n  return result;\n}\nexport var PerfEntryRecorder = function () {\n  function PerfEntryRecorder(callback) {\n    this.po = {\n      observe: noop,\n      disconnect: noop\n    };\n\n    if (window.PerformanceObserver) {\n      this.po = new PerformanceObserver(callback);\n    }\n  }\n\n  var _proto = PerfEntryRecorder.prototype;\n\n  _proto.start = function start(type) {\n    try {\n      this.po.observe({\n        type: type,\n        buffered: true\n      });\n    } catch (_) {}\n  };\n\n  _proto.stop = function stop() {\n    this.po.disconnect();\n  };\n\n  return PerfEntryRecorder;\n}();","import { Promise } from '../common/polyfills';\nimport Transaction from './transaction';\nimport { PerfEntryRecorder, captureObserverEntries, metrics, createTotalBlockingTimeSpan } from './metrics';\nimport { extend, getEarliestSpan, getLatestNonXHRSpan, isPerfTypeSupported, generateRandomId } from '../common/utils';\nimport { captureNavigation } from './capture-navigation';\nimport { PAGE_LOAD, NAME_UNKNOWN, TRANSACTION_START, TRANSACTION_END, TEMPORARY_TYPE, TRANSACTION_TYPE_ORDER, LARGEST_CONTENTFUL_PAINT, LONG_TASK, PAINT, TRUNCATED_TYPE, FIRST_INPUT, LAYOUT_SHIFT, SESSION_TIMEOUT } from '../common/constants';\nimport { addTransactionContext } from '../common/context';\nimport { __DEV__, state } from '../state';\nimport { slugifyUrl } from '../common/url';\n\nvar TransactionService = function () {\n  function TransactionService(logger, config) {\n    var _this = this;\n\n    this._config = config;\n    this._logger = logger;\n    this.currentTransaction = undefined;\n    this.respIntervalId = undefined;\n    this.recorder = new PerfEntryRecorder(function (list) {\n      var tr = _this.getCurrentTransaction();\n\n      if (tr && tr.captureTimings) {\n        var _tr$spans;\n\n        var isHardNavigation = tr.type === PAGE_LOAD;\n\n        var _captureObserverEntri = captureObserverEntries(list, {\n          isHardNavigation: isHardNavigation,\n          trStart: isHardNavigation ? 0 : tr._start\n        }),\n            spans = _captureObserverEntri.spans,\n            marks = _captureObserverEntri.marks;\n\n        (_tr$spans = tr.spans).push.apply(_tr$spans, spans);\n\n        tr.addMarks({\n          agent: marks\n        });\n      }\n    });\n  }\n\n  var _proto = TransactionService.prototype;\n\n  _proto.createCurrentTransaction = function createCurrentTransaction(name, type, options) {\n    var tr = new Transaction(name, type, options);\n    this.currentTransaction = tr;\n    return tr;\n  };\n\n  _proto.getCurrentTransaction = function getCurrentTransaction() {\n    if (this.currentTransaction && !this.currentTransaction.ended) {\n      return this.currentTransaction;\n    }\n  };\n\n  _proto.createOptions = function createOptions(options) {\n    var config = this._config.config;\n    var presetOptions = {\n      transactionSampleRate: config.transactionSampleRate\n    };\n    var perfOptions = extend(presetOptions, options);\n\n    if (perfOptions.managed) {\n      perfOptions = extend({\n        pageLoadTraceId: config.pageLoadTraceId,\n        pageLoadSampled: config.pageLoadSampled,\n        pageLoadSpanId: config.pageLoadSpanId,\n        pageLoadTransactionName: config.pageLoadTransactionName\n      }, perfOptions);\n    }\n\n    return perfOptions;\n  };\n\n  _proto.startManagedTransaction = function startManagedTransaction(name, type, perfOptions) {\n    var tr = this.getCurrentTransaction();\n    var isRedefined = false;\n\n    if (!tr) {\n      tr = this.createCurrentTransaction(name, type, perfOptions);\n    } else if (tr.canReuse() && perfOptions.canReuse) {\n      var redefineType = tr.type;\n      var currentTypeOrder = TRANSACTION_TYPE_ORDER.indexOf(tr.type);\n      var redefineTypeOrder = TRANSACTION_TYPE_ORDER.indexOf(type);\n\n      if (currentTypeOrder >= 0 && redefineTypeOrder < currentTypeOrder) {\n        redefineType = type;\n      }\n\n      if (__DEV__) {\n        this._logger.debug(\"redefining transaction(\" + tr.id + \", \" + tr.name + \", \" + tr.type + \")\", 'to', \"(\" + (name || tr.name) + \", \" + redefineType + \")\", tr);\n      }\n\n      tr.redefine(name, redefineType, perfOptions);\n      isRedefined = true;\n    } else {\n      if (__DEV__) {\n        this._logger.debug(\"ending previous transaction(\" + tr.id + \", \" + tr.name + \")\", tr);\n      }\n\n      tr.end();\n      tr = this.createCurrentTransaction(name, type, perfOptions);\n    }\n\n    if (tr.type === PAGE_LOAD) {\n      if (!isRedefined) {\n        this.recorder.start(LARGEST_CONTENTFUL_PAINT);\n        this.recorder.start(PAINT);\n        this.recorder.start(FIRST_INPUT);\n        this.recorder.start(LAYOUT_SHIFT);\n      }\n\n      if (perfOptions.pageLoadTraceId) {\n        tr.traceId = perfOptions.pageLoadTraceId;\n      }\n\n      if (perfOptions.pageLoadSampled) {\n        tr.sampled = perfOptions.pageLoadSampled;\n      }\n\n      if (tr.name === NAME_UNKNOWN && perfOptions.pageLoadTransactionName) {\n        tr.name = perfOptions.pageLoadTransactionName;\n      }\n    }\n\n    if (!isRedefined && this._config.get('monitorLongtasks')) {\n      this.recorder.start(LONG_TASK);\n    }\n\n    if (tr.sampled) {\n      tr.captureTimings = true;\n    }\n\n    return tr;\n  };\n\n  _proto.startTransaction = function startTransaction(name, type, options) {\n    var _this2 = this;\n\n    var perfOptions = this.createOptions(options);\n    var tr;\n    var fireOnstartHook = true;\n\n    if (perfOptions.managed) {\n      var current = this.currentTransaction;\n      tr = this.startManagedTransaction(name, type, perfOptions);\n\n      if (current === tr) {\n        fireOnstartHook = false;\n      }\n    } else {\n      tr = new Transaction(name, type, perfOptions);\n    }\n\n    tr.onEnd = function () {\n      return _this2.handleTransactionEnd(tr);\n    };\n\n    if (fireOnstartHook) {\n      if (__DEV__) {\n        this._logger.debug(\"startTransaction(\" + tr.id + \", \" + tr.name + \", \" + tr.type + \")\");\n      }\n\n      this._config.events.send(TRANSACTION_START, [tr]);\n    }\n\n    return tr;\n  };\n\n  _proto.handleTransactionEnd = function handleTransactionEnd(tr) {\n    var _this3 = this;\n\n    this.recorder.stop();\n    var currentUrl = window.location.href;\n    return Promise.resolve().then(function () {\n      var name = tr.name,\n          type = tr.type;\n      var lastHiddenStart = state.lastHiddenStart;\n\n      if (lastHiddenStart >= tr._start) {\n        if (__DEV__) {\n          _this3._logger.debug(\"transaction(\" + tr.id + \", \" + name + \", \" + type + \") was discarded! The page was hidden during the transaction!\");\n        }\n\n        return;\n      }\n\n      if (_this3.shouldIgnoreTransaction(name) || type === TEMPORARY_TYPE) {\n        if (__DEV__) {\n          _this3._logger.debug(\"transaction(\" + tr.id + \", \" + name + \", \" + type + \") is ignored\");\n        }\n\n        return;\n      }\n\n      if (type === PAGE_LOAD) {\n        var pageLoadTransactionName = _this3._config.get('pageLoadTransactionName');\n\n        if (name === NAME_UNKNOWN && pageLoadTransactionName) {\n          tr.name = pageLoadTransactionName;\n        }\n\n        if (tr.captureTimings) {\n          var cls = metrics.cls,\n              fid = metrics.fid,\n              tbt = metrics.tbt,\n              longtask = metrics.longtask;\n\n          if (tbt.duration > 0) {\n            tr.spans.push(createTotalBlockingTimeSpan(tbt));\n          }\n\n          tr.experience = {};\n\n          if (isPerfTypeSupported(LONG_TASK)) {\n            tr.experience.tbt = tbt.duration;\n          }\n\n          if (isPerfTypeSupported(LAYOUT_SHIFT)) {\n            tr.experience.cls = cls;\n          }\n\n          if (fid > 0) {\n            tr.experience.fid = fid;\n          }\n\n          if (longtask.count > 0) {\n            tr.experience.longtask = {\n              count: longtask.count,\n              sum: longtask.duration,\n              max: longtask.max\n            };\n          }\n        }\n\n        _this3.setSession(tr);\n      }\n\n      if (tr.name === NAME_UNKNOWN) {\n        tr.name = slugifyUrl(currentUrl);\n      }\n\n      captureNavigation(tr);\n\n      _this3.adjustTransactionTime(tr);\n\n      var breakdownMetrics = _this3._config.get('breakdownMetrics');\n\n      if (breakdownMetrics) {\n        tr.captureBreakdown();\n      }\n\n      var configContext = _this3._config.get('context');\n\n      addTransactionContext(tr, configContext);\n\n      _this3._config.events.send(TRANSACTION_END, [tr]);\n\n      if (__DEV__) {\n        _this3._logger.debug(\"end transaction(\" + tr.id + \", \" + tr.name + \", \" + tr.type + \")\", tr);\n      }\n    }, function (err) {\n      if (__DEV__) {\n        _this3._logger.debug(\"error ending transaction(\" + tr.id + \", \" + tr.name + \")\", err);\n      }\n    });\n  };\n\n  _proto.setSession = function setSession(tr) {\n    var session = this._config.get('session');\n\n    if (session) {\n      if (typeof session == 'boolean') {\n        tr.session = {\n          id: generateRandomId(16),\n          sequence: 1\n        };\n      } else {\n        if (session.timestamp && Date.now() - session.timestamp > SESSION_TIMEOUT) {\n          tr.session = {\n            id: generateRandomId(16),\n            sequence: 1\n          };\n        } else {\n          tr.session = {\n            id: session.id,\n            sequence: session.sequence ? session.sequence + 1 : 1\n          };\n        }\n      }\n\n      var sessionConfig = {\n        session: {\n          id: tr.session.id,\n          sequence: tr.session.sequence,\n          timestamp: Date.now()\n        }\n      };\n\n      this._config.setConfig(sessionConfig);\n\n      this._config.setLocalConfig(sessionConfig, true);\n    }\n  };\n\n  _proto.adjustTransactionTime = function adjustTransactionTime(transaction) {\n    var spans = transaction.spans;\n    var earliestSpan = getEarliestSpan(spans);\n\n    if (earliestSpan && earliestSpan._start < transaction._start) {\n      transaction._start = earliestSpan._start;\n    }\n\n    var latestSpan = getLatestNonXHRSpan(spans);\n\n    if (latestSpan && latestSpan._end > transaction._end) {\n      transaction._end = latestSpan._end;\n    }\n\n    var transactionEnd = transaction._end;\n\n    for (var i = 0; i < spans.length; i++) {\n      var span = spans[i];\n\n      if (span._end > transactionEnd) {\n        span._end = transactionEnd;\n        span.type += TRUNCATED_TYPE;\n      }\n\n      if (span._start > transactionEnd) {\n        span._start = transactionEnd;\n      }\n    }\n  };\n\n  _proto.shouldIgnoreTransaction = function shouldIgnoreTransaction(transactionName) {\n    var ignoreList = this._config.get('ignoreTransactions');\n\n    if (ignoreList && ignoreList.length) {\n      for (var i = 0; i < ignoreList.length; i++) {\n        var element = ignoreList[i];\n\n        if (typeof element.test === 'function') {\n          if (element.test(transactionName)) {\n            return true;\n          }\n        } else if (element === transactionName) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  _proto.startSpan = function startSpan(name, type, options) {\n    var tr = this.getCurrentTransaction();\n\n    if (!tr) {\n      tr = this.createCurrentTransaction(undefined, TEMPORARY_TYPE, this.createOptions({\n        canReuse: true,\n        managed: true\n      }));\n    }\n\n    var span = tr.startSpan(name, type, options);\n\n    if (__DEV__) {\n      this._logger.debug(\"startSpan(\" + name + \", \" + span.type + \")\", \"on transaction(\" + tr.id + \", \" + tr.name + \")\");\n    }\n\n    return span;\n  };\n\n  _proto.endSpan = function endSpan(span, context) {\n    if (!span) {\n      return;\n    }\n\n    if (__DEV__) {\n      var tr = this.getCurrentTransaction();\n      tr && this._logger.debug(\"endSpan(\" + span.name + \", \" + span.type + \")\", \"on transaction(\" + tr.id + \", \" + tr.name + \")\");\n    }\n\n    span.end(null, context);\n  };\n\n  return TransactionService;\n}();\n\nexport default TransactionService;","import PerformanceMonitoring from './performance-monitoring';\nimport TransactionService from './transaction-service';\nimport { APM_SERVER, CONFIG_SERVICE, LOGGING_SERVICE } from '../common/constants';\nimport { serviceCreators } from '../common/service-factory';\n\nfunction registerServices() {\n  serviceCreators['TransactionService'] = function (serviceFactory) {\n    var _serviceFactory$getSe = serviceFactory.getService([LOGGING_SERVICE, CONFIG_SERVICE]),\n        loggingService = _serviceFactory$getSe[0],\n        configService = _serviceFactory$getSe[1];\n\n    return new TransactionService(loggingService, configService);\n  };\n\n  serviceCreators['PerformanceMonitoring'] = function (serviceFactory) {\n    var _serviceFactory$getSe2 = serviceFactory.getService([APM_SERVER, CONFIG_SERVICE, LOGGING_SERVICE, 'TransactionService']),\n        apmServer = _serviceFactory$getSe2[0],\n        configService = _serviceFactory$getSe2[1],\n        loggingService = _serviceFactory$getSe2[2],\n        transactionService = _serviceFactory$getSe2[3];\n\n    return new PerformanceMonitoring(apmServer, configService, loggingService, transactionService);\n  };\n}\n\nexport { registerServices };","import { XMLHTTPREQUEST, FETCH, HISTORY, PAGE_LOAD, ERROR, EVENT_TARGET } from './constants';\nexport function getInstrumentationFlags(instrument, disabledInstrumentations) {\n  var _flags;\n\n  var flags = (_flags = {}, _flags[XMLHTTPREQUEST] = false, _flags[FETCH] = false, _flags[HISTORY] = false, _flags[PAGE_LOAD] = false, _flags[ERROR] = false, _flags[EVENT_TARGET] = false, _flags);\n\n  if (!instrument) {\n    return flags;\n  }\n\n  Object.keys(flags).forEach(function (key) {\n    if (disabledInstrumentations.indexOf(key) === -1) {\n      flags[key] = true;\n    }\n  });\n  return flags;\n}","var RAF_TIMEOUT = 100;\nexport default function afterFrame(callback) {\n  var handler = function handler() {\n    clearTimeout(timeout);\n    cancelAnimationFrame(raf);\n    setTimeout(callback);\n  };\n\n  var timeout = setTimeout(handler, RAF_TIMEOUT);\n  var raf = requestAnimationFrame(handler);\n}","import { isPlatformSupported, isBrowser, now } from './common/utils';\nimport { patchAll } from './common/patching';\nimport { state } from './state';\nvar enabled = false;\nexport function bootstrap() {\n  if (isPlatformSupported()) {\n    patchAll();\n    bootstrapPerf();\n    state.bootstrapTime = now();\n    enabled = true;\n  } else if (isBrowser) {\n    console.log('[Elastic APM] platform is not supported!');\n  }\n\n  return enabled;\n}\nexport function bootstrapPerf() {\n  if (document.visibilityState === 'hidden') {\n    state.lastHiddenStart = 0;\n  }\n\n  window.addEventListener('visibilitychange', function () {\n    if (document.visibilityState === 'hidden') {\n      state.lastHiddenStart = performance.now();\n    }\n  }, {\n    capture: true\n  });\n}","/**\n * SpanContext represents Span state that must propagate to descendant Spans\n * and across process boundaries.\n *\n * SpanContext is logically divided into two pieces: the user-level \"Baggage\"\n * (see setBaggageItem and getBaggageItem) that propagates across Span\n * boundaries and any Tracer-implementation-specific fields that are needed to\n * identify or otherwise contextualize the associated Span instance (e.g., a\n * <trace_id, span_id, sampled> tuple).\n */\nexport class SpanContext {\n    // The SpanContext is entirely implementation dependent\n\n    /**\n     * Returns a string representation of the implementation internal trace ID.\n     *\n     * @returns {string}\n     */\n    toTraceId(): string {\n        return '';\n    }\n\n    /**\n     * Returns a string representation of the implementation internal span ID.\n     *\n     * @returns {string}\n     */\n    toSpanId(): string {\n        return '';\n    }\n}\n\nexport default SpanContext;\n","import Span from './span';\nimport SpanContext from './span_context';\nimport Tracer from './tracer';\n\nexport let tracer: Tracer | null = null;\nexport let spanContext: SpanContext | null = null;\nexport let span: Span | null = null;\n\n// Deferred initialization to avoid a dependency cycle where Tracer depends on\n// Span which depends on the noop tracer.\nexport function initialize(): void {\n    tracer = new Tracer();\n    span = new Span();\n    spanContext = new SpanContext();\n}\n","import * as noop from './noop';\nimport SpanContext from './span_context';\nimport Tracer from './tracer';\n\n/**\n * Span represents a logical unit of work as part of a broader Trace. Examples\n * of span might include remote procedure calls or a in-process function calls\n * to sub-components. A Trace has a single, top-level \"root\" Span that in turn\n * may have zero or more child Spans, which in turn may have children.\n */\nexport class Span {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Returns the SpanContext object associated with this Span.\n     *\n     * @return {SpanContext}\n     */\n    context(): SpanContext {\n        return this._context();\n    }\n\n    /**\n     * Returns the Tracer object used to create this Span.\n     *\n     * @return {Tracer}\n     */\n    tracer(): Tracer {\n        return this._tracer();\n    }\n\n    /**\n     * Sets the string name for the logical operation this span represents.\n     *\n     * @param {string} name\n     */\n    setOperationName(name: string): this {\n        this._setOperationName(name);\n        return this;\n    }\n\n    /**\n     * Sets a key:value pair on this Span that also propagates to future\n     * children of the associated Span.\n     *\n     * setBaggageItem() enables powerful functionality given a full-stack\n     * opentracing integration (e.g., arbitrary application data from a web\n     * client can make it, transparently, all the way into the depths of a\n     * storage system), and with it some powerful costs: use this feature with\n     * care.\n     *\n     * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n     * *future* causal descendants of the associated Span.\n     *\n     * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n     * value is copied into every local *and remote* child of the associated\n     * Span, and that can add up to a lot of network and cpu overhead.\n     *\n     * @param {string} key\n     * @param {string} value\n     */\n    setBaggageItem(key: string, value: string): this {\n        this._setBaggageItem(key, value);\n        return this;\n    }\n\n    /**\n     * Returns the value for a baggage item given its key.\n     *\n     * @param  {string} key\n     *         The key for the given trace attribute.\n     * @return {string}\n     *         String value for the given key, or undefined if the key does not\n     *         correspond to a set trace attribute.\n     */\n    getBaggageItem(key: string): string | undefined {\n        return this._getBaggageItem(key);\n    }\n\n    /**\n     * Adds a single tag to the span.  See `addTags()` for details.\n     *\n     * @param {string} key\n     * @param {any} value\n     */\n    setTag(key: string, value: any): this {\n        // NOTE: the call is normalized to a call to _addTags()\n        this._addTags({ [key]: value });\n        return this;\n    }\n\n    /**\n     * Adds the given key value pairs to the set of span tags.\n     *\n     * Multiple calls to addTags() results in the tags being the superset of\n     * all calls.\n     *\n     * The behavior of setting the same key multiple times on the same span\n     * is undefined.\n     *\n     * The supported type of the values is implementation-dependent.\n     * Implementations are expected to safely handle all types of values but\n     * may choose to ignore unrecognized / unhandle-able values (e.g. objects\n     * with cyclic references, function objects).\n     *\n     * @return {[type]} [description]\n     */\n    addTags(keyValueMap: { [key: string]: any }): this {\n        this._addTags(keyValueMap);\n        return this;\n    }\n\n    /**\n     * Add a log record to this Span, optionally at a user-provided timestamp.\n     *\n     * For example:\n     *\n     *     span.log({\n     *         size: rpc.size(),  // numeric value\n     *         URI: rpc.URI(),  // string value\n     *         payload: rpc.payload(),  // Object value\n     *         \"keys can be arbitrary strings\": rpc.foo(),\n     *     });\n     *\n     *     span.log({\n     *         \"error.description\": someError.description(),\n     *     }, someError.timestampMillis());\n     *\n     * @param {object} keyValuePairs\n     *        An object mapping string keys to arbitrary value types. All\n     *        Tracer implementations should support bool, string, and numeric\n     *        value types, and some may also support Object values.\n     * @param {number} timestamp\n     *        An optional parameter specifying the timestamp in milliseconds\n     *        since the Unix epoch. Fractional values are allowed so that\n     *        timestamps with sub-millisecond accuracy can be represented. If\n     *        not specified, the implementation is expected to use its notion\n     *        of the current time of the call.\n     */\n    log(keyValuePairs: { [key: string]: any }, timestamp?: number): this {\n        this._log(keyValuePairs, timestamp);\n        return this;\n    }\n\n    /**\n     * DEPRECATED\n     */\n    logEvent(eventName: string, payload: any): void {\n        return this._log({ event: eventName, payload });\n    }\n\n    /**\n     * Sets the end timestamp and finalizes Span state.\n     *\n     * With the exception of calls to Span.context() (which are always allowed),\n     * finish() must be the last call made to any span instance, and to do\n     * otherwise leads to undefined behavior.\n     *\n     * @param  {number} finishTime\n     *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n     *         values are supported for timestamps with sub-millisecond accuracy.\n     *         If not specified, the current time (as defined by the\n     *         implementation) will be used.\n     */\n    finish(finishTime?: number): void {\n        this._finish(finishTime);\n\n        // Do not return `this`. The Span generally should not be used after it\n        // is finished so chaining is not desired in this context.\n    }\n\n    // ---------------------------------------------------------------------- //\n    // Derived classes can choose to implement the below\n    // ---------------------------------------------------------------------- //\n\n    // By default returns a no-op SpanContext.\n    protected _context(): SpanContext {\n        return noop.spanContext!;\n    }\n\n    // By default returns a no-op tracer.\n    //\n    // The base class could store the tracer that created it, but it does not\n    // in order to ensure the no-op span implementation has zero members,\n    // which allows V8 to aggressively optimize calls to such objects.\n    protected _tracer(): Tracer {\n        return noop.tracer!;\n    }\n\n    // By default does nothing\n    protected _setOperationName(name: string): void {\n    }\n\n    // By default does nothing\n    protected _setBaggageItem(key: string, value: string): void {\n    }\n\n    // By default does nothing\n    protected _getBaggageItem(key: string): string | undefined {\n        return undefined;\n    }\n\n    // By default does nothing\n    //\n    // NOTE: both setTag() and addTags() map to this function. keyValuePairs\n    // will always be an associative array.\n    protected _addTags(keyValuePairs: { [key: string]: any }): void {\n    }\n\n    // By default does nothing\n    protected _log(keyValuePairs: { [key: string]: any }, timestamp?: number): void {\n    }\n\n    // By default does nothing\n    //\n    // finishTime is expected to be either a number or undefined.\n    protected _finish(finishTime?: number): void {\n    }\n}\n\nexport default Span;\n","import Span from './span';\nimport SpanContext from './span_context';\n\n/**\n * Reference pairs a reference type constant (e.g., REFERENCE_CHILD_OF or\n * REFERENCE_FOLLOWS_FROM) with the SpanContext it points to.\n *\n * See the exported childOf() and followsFrom() functions at the package level.\n */\nexport default class Reference {\n\n    protected _type: string;\n    protected _referencedContext: SpanContext;\n\n    /**\n     * @return {string} The Reference type (e.g., REFERENCE_CHILD_OF or\n     *         REFERENCE_FOLLOWS_FROM).\n     */\n    type(): string {\n        return this._type;\n    }\n\n    /**\n     * @return {SpanContext} The SpanContext being referred to (e.g., the\n     *         parent in a REFERENCE_CHILD_OF Reference).\n     */\n    referencedContext(): SpanContext {\n        return this._referencedContext;\n    }\n\n    /**\n     * Initialize a new Reference instance.\n     *\n     * @param {string} type - the Reference type constant (e.g.,\n     *        REFERENCE_CHILD_OF or REFERENCE_FOLLOWS_FROM).\n     * @param {SpanContext} referencedContext - the SpanContext being referred\n     *        to. As a convenience, a Span instance may be passed in instead\n     *        (in which case its .context() is used here).\n     */\n    constructor(type: string, referencedContext: SpanContext | Span) {\n        this._type = type;\n        this._referencedContext = (\n                referencedContext instanceof Span ?\n                referencedContext.context() :\n                referencedContext);\n    }\n}\n","import * as Constants from './constants';\nimport Reference from './reference';\nimport Span from './span';\nimport SpanContext from './span_context';\n\n/**\n * Return a new REFERENCE_CHILD_OF reference.\n *\n * @param {SpanContext} spanContext - the parent SpanContext instance to\n *        reference.\n * @return a REFERENCE_CHILD_OF reference pointing to `spanContext`\n */\nexport function childOf(spanContext: SpanContext | Span): Reference {\n    // Allow the user to pass a Span instead of a SpanContext\n    if (spanContext instanceof Span) {\n        spanContext = spanContext.context();\n    }\n    return new Reference(Constants.REFERENCE_CHILD_OF, spanContext);\n}\n\n/**\n * Return a new REFERENCE_FOLLOWS_FROM reference.\n *\n * @param {SpanContext} spanContext - the parent SpanContext instance to\n *        reference.\n * @return a REFERENCE_FOLLOWS_FROM reference pointing to `spanContext`\n */\nexport function followsFrom(spanContext: SpanContext | Span): Reference {\n    // Allow the user to pass a Span instead of a SpanContext\n    if (spanContext instanceof Span) {\n        spanContext = spanContext.context();\n    }\n    return new Reference(Constants.REFERENCE_FOLLOWS_FROM, spanContext);\n}\n","import * as Functions from './functions';\nimport * as Noop from './noop';\nimport Reference from './reference';\nimport Span from './span';\nimport SpanContext from './span_context';\n\nexport interface SpanOptions {\n\n    /**\n     * a parent SpanContext (or Span, for convenience) that the newly-started\n     * span will be the child of (per REFERENCE_CHILD_OF). If specified,\n     * `references` must be unspecified.\n     */\n    childOf?: Span | SpanContext;\n\n    /**\n     * an array of Reference instances, each pointing to a causal parent\n     * SpanContext. If specified, `fields.childOf` must be unspecified.\n     */\n    references?: Reference[];\n\n    /**\n     * set of key-value pairs which will be set as tags on the newly created\n     * Span. Ownership of the object is passed to the created span for\n     * efficiency reasons (the caller should not modify this object after\n     * calling startSpan).\n     */\n    tags?: { [key: string]: any };\n\n    /**\n     * a manually specified start time for the created Span object. The time\n     * should be specified in milliseconds as Unix timestamp. Decimal value are\n     * supported to represent time values with sub-millisecond accuracy.\n     */\n    startTime?: number;\n}\n\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n *\n * Note to implementators: derived classes can choose to directly implement the\n * methods in the \"OpenTracing API methods\" section, or optionally the subset of\n * underscore-prefixed methods to pick up the argument checking and handling\n * automatically from the base class.\n */\nexport class Tracer {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Starts and returns a new Span representing a logical unit of work.\n     *\n     * For example:\n     *\n     *     // Start a new (parentless) root Span:\n     *     var parent = Tracer.startSpan('DoWork');\n     *\n     *     // Start a new (child) Span:\n     *     var child = Tracer.startSpan('load-from-db', {\n     *         childOf: parent.context(),\n     *     });\n     *\n     *     // Start a new async (FollowsFrom) Span:\n     *     var child = Tracer.startSpan('async-cache-write', {\n     *         references: [\n     *             opentracing.followsFrom(parent.context())\n     *         ],\n     *     });\n     *\n     * @param {string} name - the name of the operation (REQUIRED).\n     * @param {SpanOptions} [options] - options for the newly created span.\n     * @return {Span} - a new Span object.\n     */\n    startSpan(name: string, options: SpanOptions = {}): Span {\n\n        // Convert options.childOf to fields.references as needed.\n        if (options.childOf) {\n            // Convert from a Span or a SpanContext into a Reference.\n            const childOf = Functions.childOf(options.childOf);\n            if (options.references) {\n                options.references.push(childOf);\n            } else {\n                options.references = [childOf];\n            }\n            delete(options.childOf);\n        }\n        return this._startSpan(name, options);\n    }\n\n    /**\n     * Injects the given SpanContext instance for cross-process propagation\n     * within `carrier`. The expected type of `carrier` depends on the value of\n     * `format.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     var clientSpan = ...;\n     *     ...\n     *     // Inject clientSpan into a text carrier.\n     *     var headersCarrier = {};\n     *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     // Incorporate the textCarrier into the outbound HTTP request header\n     *     // map.\n     *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n     *     // ... send the httpReq\n     *\n     * @param  {SpanContext} spanContext - the SpanContext to inject into the\n     *         carrier object. As a convenience, a Span instance may be passed\n     *         in instead (in which case its .context() is used for the\n     *         inject()).\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - see the documentation for the chosen `format`\n     *         for a description of the carrier object.\n     */\n    inject(spanContext: SpanContext | Span, format: string, carrier: any): void {\n        // Allow the user to pass a Span instead of a SpanContext\n        if (spanContext instanceof Span) {\n            spanContext = spanContext.context();\n        }\n        return this._inject(spanContext, format, carrier);\n    }\n\n    /**\n     * Returns a SpanContext instance extracted from `carrier` in the given\n     * `format`.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     // Use the inbound HTTP request's headers as a text map carrier.\n     *     var headersCarrier = inboundHTTPReq.headers;\n     *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n     *\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - the type of the carrier object is determined by\n     *         the format.\n     * @return {SpanContext}\n     *         The extracted SpanContext, or null if no such SpanContext could\n     *         be found in `carrier`\n     */\n    extract(format: string, carrier: any): SpanContext | null {\n        return this._extract(format, carrier);\n    }\n\n    // ---------------------------------------------------------------------- //\n    // Derived classes can choose to implement the below\n    // ---------------------------------------------------------------------- //\n\n    // NOTE: the input to this method is *always* an associative array. The\n    // public-facing startSpan() method normalizes the arguments so that\n    // all N implementations do not need to worry about variations in the call\n    // signature.\n    //\n    // The default behavior returns a no-op span.\n    protected _startSpan(name: string, fields: SpanOptions): Span {\n        return Noop.span!;\n    }\n\n    // The default behavior is a no-op.\n    protected _inject(spanContext: SpanContext, format: string, carrier: any): void {\n    }\n\n    // The default behavior is to return a no-op SpanContext.\n    protected _extract(format: string, carrier: any): SpanContext | null {\n        return Noop.spanContext!;\n    }\n}\n\nexport default Tracer;\n","function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport { Span as otSpan } from 'opentracing/lib/span';\nimport { extend, getTimeOrigin } from '../common/utils';\nimport Transaction from '../performance-monitoring/transaction';\n\nvar Span = function (_otSpan) {\n  _inheritsLoose(Span, _otSpan);\n\n  function Span(tracer, span) {\n    var _this;\n\n    _this = _otSpan.call(this) || this;\n    _this.__tracer = tracer;\n    _this.span = span;\n    _this.isTransaction = span instanceof Transaction;\n    _this.spanContext = {\n      id: span.id,\n      traceId: span.traceId,\n      sampled: span.sampled\n    };\n    return _this;\n  }\n\n  var _proto = Span.prototype;\n\n  _proto._context = function _context() {\n    return this.spanContext;\n  };\n\n  _proto._tracer = function _tracer() {\n    return this.__tracer;\n  };\n\n  _proto._setOperationName = function _setOperationName(name) {\n    this.span.name = name;\n  };\n\n  _proto._addTags = function _addTags(keyValuePairs) {\n    var tags = extend({}, keyValuePairs);\n\n    if (tags.type) {\n      this.span.type = tags.type;\n      delete tags.type;\n    }\n\n    if (this.isTransaction) {\n      var userId = tags['user.id'];\n      var username = tags['user.username'];\n      var email = tags['user.email'];\n\n      if (userId || username || email) {\n        this.span.addContext({\n          user: {\n            id: userId,\n            username: username,\n            email: email\n          }\n        });\n        delete tags['user.id'];\n        delete tags['user.username'];\n        delete tags['user.email'];\n      }\n    }\n\n    this.span.addLabels(tags);\n  };\n\n  _proto._log = function _log(log, timestamp) {\n    if (log.event === 'error') {\n      if (log['error.object']) {\n        this.__tracer.errorLogging.logError(log['error.object']);\n      } else if (log.message) {\n        this.__tracer.errorLogging.logError(log.message);\n      }\n    }\n  };\n\n  _proto._finish = function _finish(finishTime) {\n    this.span.end();\n\n    if (finishTime) {\n      this.span._end = finishTime - getTimeOrigin();\n    }\n  };\n\n  return Span;\n}(otSpan);\n\nexport default Span;","function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport { Tracer as otTracer } from 'opentracing/lib/tracer';\nimport { REFERENCE_CHILD_OF, FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, FORMAT_BINARY } from 'opentracing/lib/constants';\nimport { Span as NoopSpan } from 'opentracing/lib/span';\nimport { getTimeOrigin, find } from '../common/utils';\nimport { __DEV__ } from '../state';\nimport Span from './span';\n\nvar Tracer = function (_otTracer) {\n  _inheritsLoose(Tracer, _otTracer);\n\n  function Tracer(performanceMonitoring, transactionService, loggingService, errorLogging) {\n    var _this;\n\n    _this = _otTracer.call(this) || this;\n    _this.performanceMonitoring = performanceMonitoring;\n    _this.transactionService = transactionService;\n    _this.loggingService = loggingService;\n    _this.errorLogging = errorLogging;\n    return _this;\n  }\n\n  var _proto = Tracer.prototype;\n\n  _proto._startSpan = function _startSpan(name, options) {\n    var spanOptions = {\n      managed: true\n    };\n\n    if (options) {\n      spanOptions.timestamp = options.startTime;\n\n      if (options.childOf) {\n        spanOptions.parentId = options.childOf.id;\n      } else if (options.references && options.references.length > 0) {\n        if (options.references.length > 1) {\n          if (__DEV__) {\n            this.loggingService.debug('Elastic APM OpenTracing: Unsupported number of references, only the first childOf reference will be recorded.');\n          }\n        }\n\n        var childRef = find(options.references, function (ref) {\n          return ref.type() === REFERENCE_CHILD_OF;\n        });\n\n        if (childRef) {\n          spanOptions.parentId = childRef.referencedContext().id;\n        }\n      }\n    }\n\n    var span;\n    var currentTransaction = this.transactionService.getCurrentTransaction();\n\n    if (currentTransaction) {\n      span = this.transactionService.startSpan(name, undefined, spanOptions);\n    } else {\n      span = this.transactionService.startTransaction(name, undefined, spanOptions);\n    }\n\n    if (!span) {\n      return new NoopSpan();\n    }\n\n    if (spanOptions.timestamp) {\n      span._start = spanOptions.timestamp - getTimeOrigin();\n    }\n\n    var otSpan = new Span(this, span);\n\n    if (options && options.tags) {\n      otSpan.addTags(options.tags);\n    }\n\n    return otSpan;\n  };\n\n  _proto._inject = function _inject(spanContext, format, carrier) {\n    switch (format) {\n      case FORMAT_TEXT_MAP:\n      case FORMAT_HTTP_HEADERS:\n        this.performanceMonitoring.injectDtHeader(spanContext, carrier);\n        break;\n\n      case FORMAT_BINARY:\n        if (__DEV__) {\n          this.loggingService.debug('Elastic APM OpenTracing: binary carrier format is not supported.');\n        }\n\n        break;\n    }\n  };\n\n  _proto._extract = function _extract(format, carrier) {\n    var ctx;\n\n    switch (format) {\n      case FORMAT_TEXT_MAP:\n      case FORMAT_HTTP_HEADERS:\n        ctx = this.performanceMonitoring.extractDtHeader(carrier);\n        break;\n\n      case FORMAT_BINARY:\n        if (__DEV__) {\n          this.loggingService.debug('Elastic APM OpenTracing: binary carrier format is not supported.');\n        }\n\n        break;\n    }\n\n    if (!ctx) {\n      ctx = null;\n    }\n\n    return ctx;\n  };\n\n  return Tracer;\n}(otTracer);\n\nexport default Tracer;","import Tracer from './tracer';\nimport Span from './span';\n\nfunction createTracer(serviceFactory) {\n  var performanceMonitoring = serviceFactory.getService('PerformanceMonitoring');\n  var transactionService = serviceFactory.getService('TransactionService');\n  var errorLogging = serviceFactory.getService('ErrorLogging');\n  var loggingService = serviceFactory.getService('LoggingService');\n  return new Tracer(performanceMonitoring, transactionService, loggingService, errorLogging);\n}\n\nexport { Span, Tracer, createTracer };","import { registerServices as registerErrorServices } from './error-logging';\nimport { registerServices as registerPerfServices } from './performance-monitoring';\nimport { ServiceFactory } from './common/service-factory';\nimport { isPlatformSupported, scheduleMicroTask, scheduleMacroTask, isBrowser } from './common/utils';\nimport { patchAll, patchEventHandler } from './common/patching';\nimport { PAGE_LOAD, ERROR, CONFIG_SERVICE, LOGGING_SERVICE, APM_SERVER } from './common/constants';\nimport { getInstrumentationFlags } from './common/instrument';\nimport afterFrame from './common/after-frame';\nimport { bootstrap } from './bootstrap';\nimport { createTracer } from './opentracing';\n\nfunction createServiceFactory() {\n  registerPerfServices();\n  registerErrorServices();\n  var serviceFactory = new ServiceFactory();\n  return serviceFactory;\n}\n\nexport { createServiceFactory, ServiceFactory, patchAll, patchEventHandler, isPlatformSupported, isBrowser, getInstrumentationFlags, createTracer, scheduleMicroTask, scheduleMacroTask, afterFrame, ERROR, PAGE_LOAD, CONFIG_SERVICE, LOGGING_SERVICE, APM_SERVER, bootstrap };","import { getInstrumentationFlags, PAGE_LOAD, ERROR, CONFIG_SERVICE, LOGGING_SERVICE, APM_SERVER } from '@elastic/apm-rum-core';\n\nvar ApmBase = function () {\n  function ApmBase(serviceFactory, disable) {\n    this._disable = disable;\n    this.serviceFactory = serviceFactory;\n    this._initialized = false;\n  }\n\n  var _proto = ApmBase.prototype;\n\n  _proto.isEnabled = function isEnabled() {\n    return !this._disable;\n  };\n\n  _proto.isActive = function isActive() {\n    var configService = this.serviceFactory.getService(CONFIG_SERVICE);\n    return this.isEnabled() && this._initialized && configService.get('active');\n  };\n\n  _proto.init = function init(config) {\n    var _this = this;\n\n    if (this.isEnabled() && !this._initialized) {\n      this._initialized = true;\n\n      var _this$serviceFactory$ = this.serviceFactory.getService([CONFIG_SERVICE, LOGGING_SERVICE]),\n          configService = _this$serviceFactory$[0],\n          loggingService = _this$serviceFactory$[1];\n\n      configService.setVersion('5.9.1');\n      this.config(config);\n      var logLevel = configService.get('logLevel');\n      loggingService.setLevel(logLevel);\n      var isConfigActive = configService.get('active');\n\n      if (isConfigActive) {\n        this.serviceFactory.init();\n        var flags = getInstrumentationFlags(configService.get('instrument'), configService.get('disableInstrumentations'));\n        var performanceMonitoring = this.serviceFactory.getService('PerformanceMonitoring');\n        performanceMonitoring.init(flags);\n\n        if (flags[ERROR]) {\n          var errorLogging = this.serviceFactory.getService('ErrorLogging');\n          errorLogging.registerListeners();\n        }\n\n        if (configService.get('session')) {\n          var localConfig = configService.getLocalConfig();\n\n          if (localConfig && localConfig.session) {\n            configService.setConfig({\n              session: localConfig.session\n            });\n          }\n        }\n\n        var sendPageLoad = function sendPageLoad() {\n          return flags[PAGE_LOAD] && _this._sendPageLoadMetrics();\n        };\n\n        if (configService.get('centralConfig')) {\n          this.fetchCentralConfig().then(sendPageLoad);\n        } else {\n          sendPageLoad();\n        }\n      } else {\n        this._disable = true;\n        loggingService.warn('RUM agent is inactive');\n      }\n    }\n\n    return this;\n  };\n\n  _proto.fetchCentralConfig = function fetchCentralConfig() {\n    var _this$serviceFactory$2 = this.serviceFactory.getService([APM_SERVER, LOGGING_SERVICE, CONFIG_SERVICE]),\n        apmServer = _this$serviceFactory$2[0],\n        loggingService = _this$serviceFactory$2[1],\n        configService = _this$serviceFactory$2[2];\n\n    return apmServer.fetchConfig(configService.get('serviceName'), configService.get('environment')).then(function (config) {\n      var transactionSampleRate = config['transaction_sample_rate'];\n\n      if (transactionSampleRate) {\n        transactionSampleRate = Number(transactionSampleRate);\n        var _config2 = {\n          transactionSampleRate: transactionSampleRate\n        };\n\n        var _configService$valida = configService.validate(_config2),\n            invalid = _configService$valida.invalid;\n\n        if (invalid.length === 0) {\n          configService.setConfig(_config2);\n        } else {\n          var _invalid$ = invalid[0],\n              key = _invalid$.key,\n              value = _invalid$.value,\n              allowed = _invalid$.allowed;\n          loggingService.warn(\"invalid value \\\"\" + value + \"\\\" for \" + key + \". Allowed: \" + allowed + \".\");\n        }\n      }\n\n      return config;\n    }).catch(function (error) {\n      loggingService.warn('failed fetching config:', error);\n    });\n  };\n\n  _proto._sendPageLoadMetrics = function _sendPageLoadMetrics() {\n    var tr = this.startTransaction(undefined, PAGE_LOAD, {\n      managed: true,\n      canReuse: true\n    });\n\n    if (!tr) {\n      return;\n    }\n\n    tr.addTask(PAGE_LOAD);\n\n    var sendPageLoadMetrics = function sendPageLoadMetrics() {\n      setTimeout(function () {\n        return tr.removeTask(PAGE_LOAD);\n      });\n    };\n\n    if (document.readyState === 'complete') {\n      sendPageLoadMetrics();\n    } else {\n      window.addEventListener('load', sendPageLoadMetrics);\n    }\n  };\n\n  _proto.observe = function observe(name, fn) {\n    var configService = this.serviceFactory.getService(CONFIG_SERVICE);\n    configService.events.observe(name, fn);\n  };\n\n  _proto.config = function config(_config) {\n    var configService = this.serviceFactory.getService(CONFIG_SERVICE);\n\n    var _configService$valida2 = configService.validate(_config),\n        missing = _configService$valida2.missing,\n        invalid = _configService$valida2.invalid;\n\n    if (missing.length === 0 && invalid.length === 0) {\n      configService.setConfig(_config);\n    } else {\n      var loggingService = this.serviceFactory.getService(LOGGING_SERVICE);\n      var separator = ', ';\n      var message = \"RUM agent isn't correctly configured. \";\n\n      if (missing.length > 0) {\n        message += missing.join(separator) + ' is missing';\n\n        if (invalid.length > 0) {\n          message += separator;\n        }\n      }\n\n      invalid.forEach(function (_ref, index) {\n        var key = _ref.key,\n            value = _ref.value,\n            allowed = _ref.allowed;\n        message += key + \" \\\"\" + value + \"\\\" contains invalid characters! (allowed: \" + allowed + \")\" + (index !== invalid.length - 1 ? separator : '');\n      });\n      loggingService.error(message);\n      configService.setConfig({\n        active: false\n      });\n    }\n  };\n\n  _proto.setUserContext = function setUserContext(userContext) {\n    var configService = this.serviceFactory.getService(CONFIG_SERVICE);\n    configService.setUserContext(userContext);\n  };\n\n  _proto.setCustomContext = function setCustomContext(customContext) {\n    var configService = this.serviceFactory.getService(CONFIG_SERVICE);\n    configService.setCustomContext(customContext);\n  };\n\n  _proto.addLabels = function addLabels(labels) {\n    var configService = this.serviceFactory.getService(CONFIG_SERVICE);\n    configService.addLabels(labels);\n  };\n\n  _proto.setInitialPageLoadName = function setInitialPageLoadName(name) {\n    var configService = this.serviceFactory.getService(CONFIG_SERVICE);\n    configService.setConfig({\n      pageLoadTransactionName: name\n    });\n  };\n\n  _proto.startTransaction = function startTransaction(name, type, options) {\n    if (this.isEnabled()) {\n      var transactionService = this.serviceFactory.getService('TransactionService');\n      return transactionService.startTransaction(name, type, options);\n    }\n  };\n\n  _proto.startSpan = function startSpan(name, type, options) {\n    if (this.isEnabled()) {\n      var transactionService = this.serviceFactory.getService('TransactionService');\n      return transactionService.startSpan(name, type, options);\n    }\n  };\n\n  _proto.getCurrentTransaction = function getCurrentTransaction() {\n    if (this.isEnabled()) {\n      var transactionService = this.serviceFactory.getService('TransactionService');\n      return transactionService.getCurrentTransaction();\n    }\n  };\n\n  _proto.captureError = function captureError(error) {\n    if (this.isEnabled()) {\n      var errorLogging = this.serviceFactory.getService('ErrorLogging');\n      return errorLogging.logError(error);\n    }\n  };\n\n  _proto.addFilter = function addFilter(fn) {\n    var configService = this.serviceFactory.getService(CONFIG_SERVICE);\n    configService.addFilter(fn);\n  };\n\n  return ApmBase;\n}();\n\nexport { ApmBase as default };","import { createServiceFactory, bootstrap, isBrowser } from '@elastic/apm-rum-core';\nimport ApmBase from './apm-base';\n\nfunction getApmBase() {\n  if (isBrowser && window.elasticApm) {\n    return window.elasticApm;\n  }\n\n  var enabled = bootstrap();\n  var serviceFactory = createServiceFactory();\n  var apmBase = new ApmBase(serviceFactory, !enabled);\n\n  if (isBrowser) {\n    window.elasticApm = apmBase;\n  }\n\n  return apmBase;\n}\n\nvar apmBase = getApmBase();\nvar init = apmBase.init.bind(apmBase);\nexport default init;\nexport { init, apmBase, ApmBase, apmBase as apm };","import React, { useMemo, useContext, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport { init as initApm } from '@elastic/apm-rum'\nimport { afterFrame } from '@elastic/apm-rum-core'\n\nconst UseAPMContext = React.createContext()\n\nfunction APMProvider({ children }) {\n  const [apm, setApm] = useState(() => {\n    if (\n      process.env.REACT_APP_DEPLOY_VERSION &&\n      process.env.REACT_APP_DEPLOY_ENVIRONMENT\n    ) {\n      return initApm({\n        serviceName: 'client',\n        serverUrl: 'https://apm-monitoring.aragon.org',\n        serviceVersion: process.env.REACT_APP_DEPLOY_VERSION,\n        environment: process.env.REACT_APP_DEPLOY_ENVIRONMENT,\n      })\n    } else {\n      console.warn(\n        'REACT_APP_DEPLOY_VERSION or REACT_APP_DEPLOY_ENVIRONMENT is not provided.'\n      )\n      return null\n    }\n  })\n\n  const contextValue = useMemo(() => {\n    return { apm, setApm }\n  }, [apm, setApm])\n\n  return (\n    <UseAPMContext.Provider value={contextValue}>\n      {children}\n    </UseAPMContext.Provider>\n  )\n}\n\nAPMProvider.propTypes = {\n  children: PropTypes.node,\n}\n\nfunction useAPM() {\n  return useContext(UseAPMContext)\n}\n\nfunction updateAPMContext(apm, networkType) {\n  if (apm && networkType) {\n    const context = { networkType: networkType }\n    apm.addLabels(context)\n    apm.setCustomContext(context)\n  }\n}\n\nupdateAPMContext.propTypes = {\n  apm: PropTypes.any,\n  networkType: PropTypes.string,\n}\n\nfunction instrumentAPMRouts(apm, routingMod) {\n  if (apm && routingMod) {\n    const { instanceId, instancePath, name, status } = routingMod\n    const path = status\n      ? `${name}/${status}`\n      : `${name}/${instanceId}${instancePath}`\n\n    const tx = apm.startTransaction(path, 'route-change', {\n      managed: false,\n      canReuse: false,\n    })\n\n    afterFrame(() => {\n      tx && tx.detectFinish()\n    })\n  }\n}\n\ninstrumentAPMRouts.propTypes = {\n  apm: PropTypes.any,\n  routing: PropTypes.any,\n}\n\nexport { useAPM, APMProvider, updateAPMContext, instrumentAPMRouts }\n","let instance\n\nclass LocalStorage {\n  constructor() {\n    if (instance) {\n      return instance\n    }\n    instance = this\n    instance.cachePrefix = null\n  }\n\n  _getKey(key, usePrefix) {\n    return usePrefix ? `${this.cachePrefix}:${key}` : key\n  }\n\n  setPrefix(prefix) {\n    this.cachePrefix = prefix\n  }\n\n  set(key, value, usePrefix = true) {\n    if (key == null) {\n      return\n    }\n\n    localStorage.setItem(this._getKey(key, usePrefix), value)\n  }\n\n  get(key, usePrefix = true) {\n    return localStorage.getItem(this._getKey(key, usePrefix))\n  }\n}\n\nexport const LocalStorageWrapper = new LocalStorage()\n","import React, {\n  useContext,\n  useEffect,\n  useMemo,\n  useCallback,\n  useState,\n} from 'react'\nimport PropTypes from 'prop-types'\nimport BN from 'bn.js'\nimport {\n  useWallet as useWalletBase,\n  UseWalletProvider,\n  ChainUnsupportedError,\n  chains,\n} from 'use-wallet'\nimport { getWeb3, filterBalanceValue } from '../util/web3'\nimport { useWalletConnectors } from '../ethereum-providers/connectors'\nimport { useAPM, updateAPMContext } from './elasticAPM'\nimport { LocalStorageWrapper } from '../local-storage-wrapper'\n\nexport const WALLET_STATUS = Object.freeze({\n  providers: 'providers',\n  connecting: 'connecting',\n  connected: 'connected',\n  disconnected: 'disconnected',\n  error: 'error',\n})\n\n// default network is mainnet if user is not connected\nconst NETWORK_TYPE_DEFAULT = chains.getChainInformation(1)?.type\n\nconst WalletContext = React.createContext()\n\nfunction WalletContextProvider({ children }) {\n  const {\n    account,\n    balance,\n    ethereum,\n    connector,\n    status,\n    chainId,\n    providerInfo,\n    type,\n    networkName,\n    ...walletBaseRest\n  } = useWalletBase()\n\n  const initialNetwork = useMemo(() => {\n    const lastNetwork = LocalStorageWrapper.get('last-network', false)\n    if (!lastNetwork) return NETWORK_TYPE_DEFAULT\n    return lastNetwork\n  }, [])\n\n  const [walletWeb3, setWalletWeb3] = useState(null)\n  const [disconnectedNetworkType, setDisconnectedNetworkType] = useState(\n    initialNetwork\n  )\n\n  const connected = useMemo(() => status === 'connected', [status])\n  const networkType = useMemo(() => {\n    const newNetwork = connected ? networkName : disconnectedNetworkType\n    LocalStorageWrapper.set('last-network', newNetwork, false)\n    return newNetwork\n  }, [connected, networkName, disconnectedNetworkType])\n\n  const changeNetworkTypeDisconnected = useCallback(\n    newNetworkType => {\n      if (status === 'disconnected') {\n        setDisconnectedNetworkType(newNetworkType)\n      }\n    },\n    [status]\n  )\n\n  // get web3 and set local storage prefix whenever networkType changes\n  useEffect(() => {\n    let cancel = false\n\n    if (!ethereum) {\n      return\n    }\n\n    const walletWeb3 = getWeb3(ethereum)\n    if (!cancel) {\n      setWalletWeb3(walletWeb3)\n    }\n\n    return () => {\n      cancel = true\n      setWalletWeb3(null)\n    }\n  }, [ethereum, networkType])\n\n  const wallet = useMemo(\n    () => ({\n      account,\n      balance: new BN(filterBalanceValue(balance)),\n      ethereum,\n      networkType,\n      providerInfo: providerInfo,\n      web3: walletWeb3,\n      status,\n      chainId: connected ? chainId : 1, // connect to mainnet if wallet is not connected\n      connected,\n      changeNetworkTypeDisconnected,\n      ...walletBaseRest,\n    }),\n    [\n      account,\n      balance,\n      ethereum,\n      networkType,\n      providerInfo,\n      status,\n      chainId,\n      walletBaseRest,\n      walletWeb3,\n      connected,\n      changeNetworkTypeDisconnected,\n    ]\n  )\n\n  const { apm } = useAPM()\n  useEffect(() => {\n    updateAPMContext(apm, wallet.networkType)\n  }, [apm, wallet.networkType])\n\n  return (\n    <WalletContext.Provider value={wallet}>{children}</WalletContext.Provider>\n  )\n}\nWalletContextProvider.propTypes = { children: PropTypes.node }\n\nexport function WalletProvider({ children }) {\n  return (\n    <UseWalletProvider connectors={useWalletConnectors}>\n      <WalletContextProvider>{children}</WalletContextProvider>\n    </UseWalletProvider>\n  )\n}\nWalletProvider.propTypes = { children: PropTypes.node }\n\nexport function useWallet() {\n  return useContext(WalletContext)\n}\n\nexport { ChainUnsupportedError }\n","import { getEnsRegistryAddress } from './local-settings'\nimport { useWallet } from './contexts/wallet'\nimport { chains } from 'use-wallet'\n\nconst localEnsRegistryAddress = getEnsRegistryAddress()\nconst DAI_MAINNET_TOKEN_ADDRESS = '0x6b175474e89094c44da98b954eedeac495271d0f'\nconst DAI_RINKEBY_TOKEN_ADDRESS = '0x0527e400502d0cb4f214dd0d2f2a323fc88ff924'\n\n// TODO stop exposing data object [vr 17-09-2021]\n// cconnectGraphEndpoint is https://github.com/aragon/connect/tree/master/packages/connect-thegraph\nexport const networkConfigs = {\n  [chains.getChainInformation(1).type]: {\n    isActive: true,\n    addresses: {\n      ensRegistry:\n        localEnsRegistryAddress || '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n      dai: DAI_MAINNET_TOKEN_ADDRESS,\n      governExecutorProxy: '0x2ac40310167fb00afa3c0bb5953c707db155afac',\n    },\n    nodes: {\n      defaultEth: 'wss://mainnet.eth.aragon.network/ws',\n    },\n    connectGraphEndpoint:\n      'https://api.thegraph.com/subgraphs/name/aragon/aragon-mainnet',\n    settings: {\n      chainId: 1,\n      testnet: false,\n      ...chains.getChainInformation(1),\n      live: true,\n    },\n  },\n  [chains.getChainInformation(3).type]: {\n    isActive: false,\n    addresses: {\n      ensRegistry:\n        localEnsRegistryAddress || '0x6afe2cacee211ea9179992f89dc61ff25c61e923',\n      governExecutorProxy: null,\n    },\n    nodes: {\n      defaultEth: 'wss://ropsten.eth.aragon.network/ws',\n    },\n    connectGraphEndpoint: null,\n    settings: {\n      chainId: 3,\n      testnet: true,\n      ...chains.getChainInformation(3),\n    },\n  },\n  [chains.getChainInformation(4).type]: {\n    isActive: true,\n    addresses: {\n      ensRegistry:\n        localEnsRegistryAddress || '0x98df287b6c145399aaa709692c8d308357bc085d',\n      dai: DAI_RINKEBY_TOKEN_ADDRESS,\n      governExecutorProxy: '0x0451533f685fe028c439821b7502e4cf63b4c32f',\n    },\n    nodes: {\n      defaultEth: 'wss://rinkeby.eth.aragon.network/ws',\n    },\n    connectGraphEndpoint:\n      'https://api.thegraph.com/subgraphs/name/aragon/aragon-rinkeby',\n    settings: {\n      chainId: 4,\n      testnet: true,\n      ...chains.getChainInformation(4), // as returned by web3.eth.net.getNetworkType()\n      live: true,\n    },\n  },\n  [chains.getChainInformation(1337).type]: {\n    isActive: false,\n    addresses: {\n      ensRegistry: localEnsRegistryAddress,\n      governExecutorProxy: null,\n    },\n    nodes: {\n      defaultEth: 'ws://localhost:8545',\n    },\n    connectGraphEndpoint: null,\n    settings: {\n      // Local development environments by convention use\n      // a chainId of value 1337, but for the sake of configuration\n      // we expose a way to change this value.\n      chainId: 1337,\n      testnet: true,\n      ...chains.getChainInformation(1337),\n      live: false,\n    },\n  },\n  // xDai is an experimental chain in the Aragon Client. It's possible\n  // and expected that a few things will break.\n  [chains.getChainInformation(100).type]: {\n    isActive: false,\n    addresses: {\n      ensRegistry:\n        localEnsRegistryAddress || '0xaafca6b0c89521752e559650206d7c925fd0e530',\n      governExecutorProxy: null,\n    },\n    nodes: {\n      defaultEth: 'wss://xdai.poanetwork.dev/wss',\n    },\n    connectGraphEndpoint: null,\n    settings: {\n      chainId: 100,\n      testnet: false,\n      ...chains.getChainInformation(100),\n    },\n  },\n  [chains.getChainInformation(137).type]: {\n    isActive: true,\n    addresses: {\n      ensRegistry:\n        localEnsRegistryAddress || '0x3c70a0190d09f34519e6e218364451add21b7d4b',\n      governExecutorProxy: null,\n      dai: '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063',\n    },\n    nodes: {\n      defaultEth: 'wss://mainnet-polygon-1.aragon.network/ws',\n    },\n    connectGraphEndpoint: null,\n    settings: {\n      chainId: 137,\n      testnet: false,\n      ...chains.getChainInformation(137),\n      live: true,\n      options: {\n        timeout: 30000, // ms\n\n        clientConfig: {\n          // Useful if requests are large\n          maxReceivedFrameSize: 100000000, // bytes - default: 1MiB\n          maxReceivedMessageSize: 100000000, // bytes - default: 8MiB\n          // Useful to keep a connection alive\n          keepalive: true,\n          keepaliveInterval: 60000, // ms\n        },\n\n        // Enable auto reconnection\n        reconnect: {\n          auto: true,\n          delay: 5000, // ms\n          maxAttempts: 5,\n          onTimeout: false,\n        },\n      },\n    },\n  },\n  [chains.getChainInformation(80001).type]: {\n    isActive: true,\n    addresses: {\n      ensRegistry:\n        localEnsRegistryAddress || '0x431f0eed904590b176f9ff8c36a1c4ff0ee9b982',\n      governExecutorProxy: null,\n      dai: '0x94f417C155bB3fF7365828Bb7aCD26E84C17e830',\n    },\n    nodes: {\n      defaultEth: 'wss://matic-testnet-archive-ws.bwarelabs.com',\n    },\n    connectGraphEndpoint: null,\n    settings: {\n      chainId: 80001,\n      testnet: true,\n      ...chains.getChainInformation(80001),\n      live: true,\n    },\n  },\n  [chains.getChainInformation(56).type]: {\n    isActive: false,\n    addresses: {\n      ensRegistry:\n        localEnsRegistryAddress || '0x431f0eed904590b176f9ff8c36a1c4ff0ee9b982',\n      governExecutorProxy: null,\n      dai: '0x94f417C155bB3fF7365828Bb7aCD26E84C17e830',\n    },\n    nodes: {\n      // defaultEth: 'TO BE CREATED',\n    },\n    connectGraphEndpoint: null,\n    settings: {\n      chainId: 56,\n      testnet: false,\n      ...chains.getChainInformation(56),\n      live: true,\n    },\n  },\n  [chains.getChainInformation(97).type]: {\n    isActive: true,\n    addresses: {\n      ensRegistry:\n        localEnsRegistryAddress || '0x843ddfab8406e752d03fa75dbb275070f368658d',\n      governExecutorProxy: null,\n    },\n    nodes: {\n      defaultEth:\n        'wss://speedy-nodes-nyc.moralis.io/e2537fd4d6ad21265cf9d450/bsc/testnet/ws',\n    },\n    connectGraphEndpoint: null,\n    settings: {\n      chainId: 97,\n      testnet: true,\n      ...chains.getChainInformation(97),\n      live: true,\n    },\n  },\n\n  [chains.getChainInformation(1666600000).type]: {\n    isActive: true,\n    enableMigrateBanner: false,\n    addresses: {\n      ensRegistry:\n        localEnsRegistryAddress || '0x843ddfab8406e752d03fa75dbb275070f368658d',\n      governExecutorProxy: null,\n    },\n    nodes: {\n      defaultEth: 'wss://ws.s0.t.hmny.io/',\n    },\n    connectGraphEndpoint: null,\n    settings: {\n      chainId: 1666600000,\n      ...chains.getChainInformation(1666600000),\n      live: false,\n      events: {\n        blockSizeLimit: 1024,\n      },\n      options: {\n        timeout: 30000, // ms\n\n        clientConfig: {\n          // Useful if requests are large\n          maxReceivedFrameSize: 100000000, // bytes - default: 1MiB\n          maxReceivedMessageSize: 100000000, // bytes - default: 8MiB\n          // Useful to keep a connection alive\n          keepalive: true,\n          keepaliveInterval: 60000, // ms\n        },\n\n        // Enable auto reconnection\n        reconnect: {\n          auto: true,\n          delay: 5000, // ms\n          maxAttempts: 5,\n          onTimeout: false,\n        },\n      },\n    },\n  },\n\n  [chains.getChainInformation(1666700000).type]: {\n    isActive: true,\n    enableMigrateBanner: false,\n    addresses: {\n      ensRegistry:\n        localEnsRegistryAddress || '0xbc7828fa8665c637901ad5abd5c7e647c9ab140f',\n      governExecutorProxy: null,\n    },\n    nodes: {\n      defaultEth: 'wss://ws.s0.pops.one/',\n    },\n    connectGraphEndpoint: null,\n    settings: {\n      chainId: 1666700000,\n      ...chains.getChainInformation(1666700000),\n      live: true,\n      events: {\n        blockSizeLimit: 1024,\n      },\n      options: {\n        timeout: 30000, // ms\n\n        clientConfig: {\n          // Useful if requests are large\n          maxReceivedFrameSize: 100000000, // bytes - default: 1MiB\n          maxReceivedMessageSize: 100000000, // bytes - default: 8MiB\n\n          // Useful to keep a connection alive\n          keepalive: true,\n          keepaliveInterval: 60000, // ms\n        },\n\n        // Enable auto reconnection\n        reconnect: {\n          auto: true,\n          delay: 5000, // ms\n          maxAttempts: 5,\n          onTimeout: false,\n        },\n      },\n    },\n  },\n\n  unknown: {\n    isActive: false,\n    addresses: {\n      ensRegistry: localEnsRegistryAddress,\n      governExecutorProxy: null,\n    },\n    nodes: {\n      defaultEth: 'ws://localhost:8545',\n    },\n    connectGraphEndpoint: null,\n    settings: {\n      testnet: true,\n      type: 'unknown',\n      live: false,\n    },\n  },\n}\n\nexport function getNetworkConfig(type) {\n  return (\n    networkConfigs[type] || {\n      ...networkConfigs.unknown,\n      settings: {\n        ...networkConfigs.unknown.settings,\n        name: `Unsupported network (${type})`,\n      },\n    }\n  )\n}\n\nexport function useNetworkConfig() {\n  const { networkType } = useWallet()\n  return getNetworkConfig(networkType)\n}\n","import appIds from './known-app-ids'\nimport { parseAppLocator } from './app-locator'\nimport { getAppLocator, getDefaultEthNode } from './local-settings'\nimport { getNetworkConfig } from './network-config'\n\nconst appsOrder = ['TokenManager', 'Voting', 'Finance', 'Agent']\n\n// Utility to sort a pair of apps (to be used with Array.prototype.sort)\nexport const sortAppsPair = (app1, app2) => {\n  const pairs = Object.entries(appIds)\n  const [name1] = pairs.find(([_, id]) => id === app1.appId) || []\n  const [name2] = pairs.find(([_, id]) => id === app2.appId) || []\n  const index1 = name1 ? appsOrder.indexOf(name1) : -1\n  const index2 = name2 ? appsOrder.indexOf(name2) : -1\n\n  // Keep kernel first\n  if (app1.name === 'Kernel') {\n    return -1\n  }\n  if (app2.name === 'Kernel') {\n    return 1\n  }\n\n  // Internal apps first\n  if (app1.isAragonOsInternalApp !== app2.isAragonOsInternalApp) {\n    return app1.isAragonOsInternalApp ? -1 : 1\n  }\n\n  // Try to sort it if the app exists in the list\n  if (index1 === -1 && index2 > -1) {\n    return 1\n  }\n  if (index1 > -1 && index2 === -1) {\n    return -1\n  }\n  if (index1 > -1 && index2 > -1) {\n    return index1 - index2\n  }\n\n  // Missing app name\n  if (!(app1.name && app2.name)) {\n    return 0\n  }\n\n  // Otherwise, alphabetical order\n  const unknownName1 = app1.name.toLowerCase()\n  const unknownName2 = app2.name.toLowerCase()\n  if (unknownName1 === unknownName2) {\n    return 0\n  }\n  return unknownName1 < unknownName2 ? -1 : 1\n}\n\n// Use appOverrides to override specific keys in an app instance, e.g. the start_url or script location\nexport const appOverrides = {\n  // Needed to change app name on sidebar for old versions whose aragonPM repo content cannot be changed anymore\n  [appIds['TokenManager']]: { name: 'Tokens' },\n}\n\nexport function getParsedAppLocator(networkType) {\n  return parseAppLocator(getAppLocator(networkType))\n}\n\nexport const getEthNode = networkType => {\n  return (\n    getDefaultEthNode(networkType) ||\n    getNetworkConfig(networkType).nodes.defaultEth\n  )\n}\n","import { chains } from 'use-wallet'\nimport { getNetworkConfig, networkConfigs } from '../network-config'\n\nexport const isActiveNetwork = networkType => {\n  return getNetworkConfig(networkType).isActive\n}\n\nexport const getActiveNetworks = () => {\n  return Object.values(networkConfigs)\n    .filter(v => v.isActive)\n    .map(n => n.settings.type)\n}\n\nexport const getOptions = networkType => {\n  return getNetworkConfig(networkType).settings?.options\n}\n\nexport function isOnEthMainnet(networkType) {\n  return networkType === chains.getChainInformation(1).type\n}\n\nexport function isMainnet(networkType) {\n  return !getNetworkConfig(networkType).settings?.testnet\n}\n\nexport function isTestnet(networkType) {\n  return getNetworkConfig(networkType).settings?.testnet\n}\n\nexport function getDaiTokenAddress(networkType) {\n  return getNetworkConfig(networkType).addresses.dai || ''\n}\n\nexport function normalizeNetworkName(networkType) {\n  return getNetworkConfig(networkType).settings?.shortName || 'unknown'\n}\n\nexport function sanitizeNetworkType(networkType) {\n  if (networkType === 'private') {\n    return 'localhost'\n  } else if (isOnEthMainnet(networkType)) {\n    return 'mainnet'\n  }\n  return networkType\n}\n\nexport function getNetworkFullName(networkType) {\n  return getNetworkConfig(networkType).settings?.fullName || 'uknown'\n}\nexport function getNetworkShortName(networkType) {\n  return getNetworkConfig(networkType).settings?.shortName || 'uknown'\n}\n\nexport function getNetworkSettings(networkType) {\n  return getNetworkConfig(networkType).settings\n}\n\nexport function getChainId(networkType) {\n  return getNetworkSettings(networkType).chainId\n}\n","/* This utils library is meant to capture all of the web3-related utilities\n * that we use. Any utilities we need from web3-utils should be re-exported\n * from this file.\n */\nimport Web3 from 'web3'\nimport { toWei } from 'web3-utils'\nimport BN from 'bn.js'\nimport { InvalidNetworkType, InvalidURI, NoConnection } from '../errors'\nimport { log } from './utils'\nimport { getEthNode } from '../environment'\nimport { getOptions, isOnEthMainnet } from '../util/network'\n\nconst EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'\nconst ETH_ADDRESS_SPLIT_REGEX = /(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g\nconst ETH_ADDRESS_TEST_REGEX = /(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g\n\n// Filter the value we get from getBalance() before passing it to BN.js.\n// This is because passing some values to BN.js can lead to an infinite loop\n// when .toString() is called. Returns \"-1\" when the value is invalid.\n//\n// See https://github.com/indutny/bn.js/issues/186\nexport function filterBalanceValue(value) {\n  if (value === null) {\n    return '-1'\n  }\n  if (typeof value === 'object') {\n    value = String(value)\n  }\n  if (typeof value === 'string') {\n    return /^[0-9]+$/.test(value) ? value : '-1'\n  }\n  return '-1'\n}\n\n/**\n * Check address equality without checksums\n * @param {string} first First address\n * @param {string} second Second address\n * @returns {boolean} Address equality\n */\nexport function addressesEqual(first, second) {\n  first = first && first.toLowerCase()\n  second = second && second.toLowerCase()\n  return first === second\n}\n\nconst websocketRegex = /^wss?:\\/\\/.+/\n\n/**\n * Check if the ETH node at the given URI is compatible for the current environment\n * @param {string} uri URI of the ETH node.\n * @param {string} expectedNetworkType The expected network type of the ETH node.\n * @returns {Promise} Resolves if the ETH node is compatible, otherwise throws:\n *    - InvalidURI: URI given is not compatible (e.g. must be WebSockets)\n *    - InvalidNetworkType: ETH node connected to wrong network\n *    - NoConnection: Couldn't connect to URI\n */\nexport async function checkValidEthNode(uri, expectedNetworkType) {\n  // Must be websocket connection\n  if (!websocketRegex.test(uri)) {\n    throw new InvalidURI('The URI must use the WebSocket protocol')\n  }\n\n  try {\n    const web3 = new Web3(uri)\n    const connectedNetworkType = await web3.eth.net.getNetworkType()\n    if (web3.currentProvider.disconnect) {\n      web3.currentProvider.disconnect()\n    } else {\n      // Older versions of web3's providers didn't expose a generic interface for disconnecting\n      web3.currentProvider.connection.close()\n    }\n\n    if (connectedNetworkType !== expectedNetworkType) {\n      throw new InvalidNetworkType()\n    }\n  } catch (err) {\n    if (err instanceof InvalidNetworkType) {\n      throw err\n    }\n    throw new NoConnection()\n  }\n\n  return true\n}\n\n/**\n * Format the balance to a fixed number of decimals\n *\n * @param {BN} amount The total amount.\n * @param {object} options The options object.\n * @param {BN} options.base The decimals base.\n * @param {number} options.precision Number of decimals to format.\n *\n * @returns {string} The formatted balance.\n */\nexport function formatBalance(\n  amount,\n  { base = new BN(10).pow(new BN(18)), precision = 2 } = {}\n) {\n  const baseLength = base.toString().length\n\n  const whole = amount.div(base).toString()\n  let fraction = amount.mod(base).toString()\n  const zeros = '0'.repeat(Math.max(0, baseLength - fraction.length - 1))\n  fraction = `${zeros}${fraction}`.replace(/0+$/, '').slice(0, precision)\n\n  if (fraction === '' || parseInt(fraction, 10) === 0) {\n    return whole\n  }\n\n  return `${whole}.${fraction}`\n}\n\nexport function getEmptyAddress() {\n  return EMPTY_ADDRESS\n}\n\nexport async function getAccountBalance(web3, account) {\n  try {\n    const balanceValue = await web3.eth.getBalance(account)\n    return new BN(filterBalanceValue(balanceValue))\n  } catch (err) {\n    return getUnknownBalance()\n  }\n}\n\n/**\n * Get whether an account is a contract\n *\n * @param {Web3} web3 The web3 instance\n * @param {string} account The account being checked\n *\n * @returns {boolean} Whether the account is a contract or not\n */\nexport async function getIsContractAccount(web3, account) {\n  try {\n    const accountCode = await web3.eth.getCode(account)\n    return accountCode !== '0x'\n  } catch (err) {\n    return false\n  }\n}\n\nconst gasPriceApi = 'https://ethgasstation.info/json/ethgasAPI.json'\nexport async function getGasPrice(\n  networkType,\n  { mainnet: { safeMinimum = '3', disableEstimate } = {} } = {}\n) {\n  if (!isOnEthMainnet(networkType)) {\n    // Hardcode 10 for non-mainnet networks\n    return toWei('10', 'gwei')\n  }\n\n  // Mainnet and gas estimation disabled; let the web3 provider handle gas price\n  if (disableEstimate) {\n    return\n  }\n\n  const safeMinimumInWei = toWei(safeMinimum, 'gwei')\n  let priceInWei\n\n  try {\n    const response = await fetch(gasPriceApi, {\n      method: 'GET',\n      mode: 'cors',\n      cache: 'no-cache',\n    })\n    const jsonResponse = await response.json()\n\n    // Note that all prices from ethgasstation need to be divided by 10 to be in gwei.\n    // The response contains a list of suggested gas prices from 2-120 in\n    // gasPriceRange, so 40 is \"slightly higher than the recommended price\".\n    let fasterPrice = parseInt(jsonResponse.gasPriceRange[40], 10)\n    fasterPrice = isNaN(fasterPrice) ? 0 : fasterPrice / 10\n\n    // Just in case, if this isn't available or is way too high,\n    // prefer the suggested safe low price.\n    let safePrice = parseInt(jsonResponse.safeLow, 10)\n    safePrice = isNaN(safePrice) ? 0 : safePrice / 10\n\n    const recommendedPrice = Math.max(\n      safePrice,\n      Math.min(fasterPrice, safePrice + 10)\n    )\n\n    priceInWei = toWei(recommendedPrice.toString(), 'gwei')\n  } catch (e) {\n    log('Error fetching gas price: ', e)\n  }\n\n  // If we couldn't find the price or it was lower than the safe minimum,\n  // use the safe minimum\n  priceInWei = new BN(priceInWei || 0).lt(new BN(safeMinimumInWei))\n    ? safeMinimumInWei\n    : priceInWei\n  return priceInWei\n}\n\n// Get the first account of a web3 instance\nexport async function getMainAccount(web3) {\n  try {\n    const accounts = await web3.eth.getAccounts()\n    return (accounts && accounts[0]) || null\n  } catch (err) {\n    return null\n  }\n}\n\nexport async function getLatestBlockTimestamp(web3) {\n  const { timestamp } = (await web3.eth.getBlock('latest')) || {}\n  if (!timestamp) {\n    throw new Error('Could not fetch the latest block timestamp')\n  }\n  return new Date(timestamp * 1000)\n}\n\nexport function getUnknownBalance() {\n  return new BN('-1')\n}\n\n// Cache web3 instances used in the app\nconst web3Cache = new WeakMap()\n\n/**\n * Get cached web3 instance\n * @param {Web3.Provider} provider Web3 provider\n * @returns {Web3} The web3 instance\n */\nexport function getWeb3(provider) {\n  if (web3Cache.has(provider)) {\n    return web3Cache.get(provider)\n  }\n\n  const web3 = new Web3(provider)\n  web3Cache.set(provider, web3)\n  return web3\n}\n\n/**\n * Get the web3 provider by the network type\n * @param {string} networkType node network type, i.e. main, rinkeby\n * @returns {object} web3 web socket provider\n */\nexport function getWeb3Provider(networkType) {\n  const host = getEthNode(networkType)\n  const options = getOptions(networkType)\n\n  if (!options) {\n    return new Web3.providers.WebsocketProvider(host)\n  }\n  return new Web3.providers.WebsocketProvider(host, options)\n}\n\nexport function isConnected(provider) {\n  // EIP-1193 compliant providers may not include `isConnected()`, but most should support it for\n  // the foreseeable future to be backwards compatible with older Web3.js implementations.\n  // The `status` property is also not required by EIP-1193, but is often set on providers for\n  // backwards compatibility as well.\n  return typeof provider.isConnected === 'function'\n    ? provider.isConnected()\n    : provider.status === 'connected'\n}\n\n// Check if the address represents an empty address\nexport function isEmptyAddress(address) {\n  return addressesEqual(address, EMPTY_ADDRESS)\n}\n\nexport function isValidEnsName(name) {\n  return /^([\\w-]+\\.)+eth$/.test(name)\n}\n\n/**\n * Shorten an Ethereum address. `charsLength` allows to change the number of\n * characters on both sides of the ellipsis.\n *\n * Examples:\n *   shortenAddress('0x19731977931271')    // 0x1973â€¦1271\n *   shortenAddress('0x19731977931271', 2) // 0x19â€¦71\n *   shortenAddress('0x197319')            // 0x197319 (already short enough)\n *\n * @param {string} address The address to shorten\n * @param {number} [charsLength=4] The number of characters to change on both sides of the ellipsis\n * @returns {string} The shortened address\n */\nexport function shortenAddress(address, charsLength = 4) {\n  const prefixLength = 2 // \"0x\"\n  if (!address) {\n    return ''\n  }\n  if (address.length < charsLength * 2 + prefixLength) {\n    return address\n  }\n  return (\n    address.slice(0, charsLength + prefixLength) +\n    'â€¦' +\n    address.slice(-charsLength)\n  )\n}\n\n// Detect Ethereum addresses in a string and transform each part.\n//\n// `callback` is called on every part with two params:\n//   - The string of the current part.\n//   - A boolean indicating if it is an address.\n//\nexport function transformAddresses(str, callback) {\n  return str\n    .split(ETH_ADDRESS_SPLIT_REGEX)\n    .map((part, index) =>\n      callback(part, ETH_ADDRESS_TEST_REGEX.test(part), index)\n    )\n}\n\n// Re-export some utilities from web3-utils\nexport {\n  fromWei,\n  isAddress,\n  soliditySha3,\n  toChecksumAddress,\n  toWei,\n} from 'web3-utils'\n","import PropTypes from 'prop-types'\nimport Aragon from '@aragon/wrapper'\nimport {\n  APPS_STATUS_ERROR,\n  APPS_STATUS_READY,\n  APPS_STATUS_LOADING,\n  APPS_STATUS_UNLOADED,\n  DAO_STATUS_ERROR,\n  DAO_STATUS_READY,\n  DAO_STATUS_LOADING,\n  DAO_STATUS_UNLOADED,\n  ACTIVITY_STATUS_CONFIRMED,\n  ACTIVITY_STATUS_FAILED,\n  ACTIVITY_STATUS_PENDING,\n  ACTIVITY_STATUS_TIMED_OUT,\n  TRANSACTION_STATUS_ERROR,\n  TRANSACTION_STATUS_PENDING,\n  TRANSACTION_STATUS_SUCCESS,\n  TRANSACTION_STATUS_UPCOMING,\n} from './symbols'\nimport { isAddress } from './util/web3'\n\nconst validatorCreator = nonRequiredFunction => {\n  const validator = nonRequiredFunction\n\n  validator.isRequired = (props, propName, componentName) => {\n    const value = props[propName]\n\n    if (value === null || value === undefined || value === '') {\n      return new Error(\n        `Property ${propName} is required on ${componentName}, but ${value} was given.`\n      )\n    }\n\n    return nonRequiredFunction(props, propName, componentName)\n  }\n\n  return validator\n}\n\nconst ethereumAddressValidator = (props, propName, componentName) => {\n  const value = props[propName]\n\n  if (value === null || value === undefined || value === '') {\n    return null\n  }\n\n  if (!isAddress(value)) {\n    const valueType = typeof value\n    let nonAddress = null\n\n    if (valueType !== 'object') {\n      nonAddress = value.toString()\n    }\n\n    return new Error(\n      `Invalid prop ${propName} supplied to ${componentName}. The provided value is not a valid ethereum address.${nonAddress &&\n        ` You provided \"${nonAddress}\"`}`\n    )\n  }\n}\n\nexport const EthereumAddressType = validatorCreator(ethereumAddressValidator)\n\nexport const ActivityStatusType = PropTypes.oneOf([\n  ACTIVITY_STATUS_CONFIRMED,\n  ACTIVITY_STATUS_FAILED,\n  ACTIVITY_STATUS_PENDING,\n  ACTIVITY_STATUS_TIMED_OUT,\n])\n\nexport const AppType = PropTypes.shape({\n  appId: PropTypes.string.isRequired,\n  baseUrl: PropTypes.string.isRequired,\n  codeAddress: EthereumAddressType.isRequired,\n  hasWebApp: PropTypes.bool.isRequired,\n  proxyAddress: EthereumAddressType.isRequired,\n  src: PropTypes.string.isRequired,\n  tags: PropTypes.arrayOf(PropTypes.string).isRequired,\n\n  // This content may not be available if the app's content couldn't be fetched\n  abi: PropTypes.array,\n  appName: PropTypes.string,\n  apmRegistry: PropTypes.string,\n  content: PropTypes.shape({\n    location: PropTypes.string.isRequired,\n    provider: PropTypes.string.isRequired,\n  }),\n  description: PropTypes.string,\n  functions: PropTypes.array,\n  icons: PropTypes.arrayOf(\n    PropTypes.shape({\n      src: PropTypes.string.isRequired,\n    })\n  ),\n  name: PropTypes.string,\n  roles: PropTypes.array,\n  status: PropTypes.string,\n  version: PropTypes.string,\n\n  // This content is only available if the app is an aragonOS internal app\n  isAragonOsInternalApp: PropTypes.bool,\n\n  // This content is not available if the app is the Kernel\n  isForwarder: PropTypes.bool,\n  kernelAddress: EthereumAddressType,\n})\n\nexport const AppsListType = PropTypes.arrayOf(AppType)\n\nexport const AppInstanceType = PropTypes.shape({\n  // Note that app instances also include embedded applications, like Home, that do not have\n  // associated on-chain information\n  codeAddress: EthereumAddressType,\n  identifier: PropTypes.string,\n  instanceId: PropTypes.oneOfType([EthereumAddressType, PropTypes.string])\n    .isRequired,\n  proxyAddress: EthereumAddressType,\n})\n\nexport const AppInstanceGroupType = PropTypes.shape({\n  app: PropTypes.object.isRequired,\n  appId: PropTypes.string.isRequired,\n  instances: PropTypes.arrayOf(AppInstanceType).isRequired,\n\n  // This content may not be available if the app's content couldn't be fetched\n  hasWebApp: PropTypes.bool,\n  name: PropTypes.string,\n  repoName: PropTypes.string,\n})\n\nexport const AppsStatusType = PropTypes.oneOf([\n  APPS_STATUS_ERROR,\n  APPS_STATUS_READY,\n  APPS_STATUS_LOADING,\n  APPS_STATUS_UNLOADED,\n])\n\nexport const AragonType = PropTypes.instanceOf(Aragon)\n\nexport const DaoAddressType = PropTypes.shape({\n  address: EthereumAddressType,\n  domain: PropTypes.string,\n})\n\nexport const DaoItemType = PropTypes.shape({\n  name: PropTypes.string,\n  address: EthereumAddressType,\n})\n\nexport const DaoStatusType = PropTypes.oneOf([\n  DAO_STATUS_ERROR,\n  DAO_STATUS_READY,\n  DAO_STATUS_LOADING,\n  DAO_STATUS_UNLOADED,\n])\n\nexport const FavoriteDaoType = PropTypes.shape({\n  name: PropTypes.string,\n  address: EthereumAddressType,\n  favorited: PropTypes.bool,\n})\n\nexport const RenderFnType = PropTypes.oneOfType([\n  PropTypes.func,\n  PropTypes.oneOf([false]),\n])\n\nexport const RepoContentType = PropTypes.shape({\n  name: PropTypes.string,\n  changelog_url: PropTypes.string,\n  description: PropTypes.string,\n  details_url: PropTypes.string,\n  icons: PropTypes.arrayOf(\n    PropTypes.shape({\n      src: PropTypes.string.isRequired,\n      sizes: PropTypes.string.isRequired,\n    })\n  ),\n  screenshots: PropTypes.arrayOf(\n    PropTypes.shape({\n      src: PropTypes.string.isRequired,\n    })\n  ),\n})\n\nexport const RepoVersionType = PropTypes.shape({\n  content: RepoContentType.isRequired,\n  version: PropTypes.string.isRequired,\n})\n\nexport const RepoType = PropTypes.shape({\n  appId: PropTypes.string.isRequired,\n  currentVersion: RepoVersionType,\n  latestVersion: RepoVersionType.isRequired,\n  repoAddress: EthereumAddressType.isRequired,\n  versions: PropTypes.arrayOf(\n    PropTypes.shape({\n      contentURI: PropTypes.string.isRequired,\n      contractAddress: PropTypes.string.isRequired,\n      timestamp: PropTypes.number,\n      version: PropTypes.string.isRequired,\n      versionId: PropTypes.string.isRequired,\n    })\n  ).isRequired,\n})\n\nexport const ReposListType = PropTypes.arrayOf(RepoType)\n\n// https://github.com/react-spring/react-spring/blob/31200a79843ce85200b2a7692e8f14788e60f9e9/types/renderprops-universal.d.ts#L133\nexport const ReactSpringStateType = PropTypes.oneOf([\n  'enter',\n  'update',\n  'leave',\n])\n\n// see ethereum-providers/\nexport const EthereumProviderType = PropTypes.shape({\n  id: PropTypes.string.isRequired,\n  name: PropTypes.string.isRequired,\n  type: PropTypes.string.isRequired,\n  image: PropTypes.string.isRequired,\n  strings: PropTypes.object.isRequired,\n})\n\n// see templates/\nconst OrgTemplateAppType = PropTypes.shape({\n  appName: PropTypes.string.isRequired,\n  label: PropTypes.string.isRequired,\n})\nexport const OrgTemplateType = PropTypes.shape({\n  apps: PropTypes.arrayOf(OrgTemplateAppType.isRequired),\n  caseStudyUrl: PropTypes.string,\n  description: PropTypes.string.isRequired,\n  disabled: PropTypes.bool,\n  header: PropTypes.string.isRequired,\n  icon: PropTypes.string.isRequired,\n  id: PropTypes.string.isRequired,\n  longDesc: PropTypes.string,\n  name: PropTypes.string.isRequired,\n  optionalApps: PropTypes.arrayOf(OrgTemplateAppType.isRequired),\n  prepareTransactions: PropTypes.func,\n  registry: PropTypes.string,\n  screens: PropTypes.arrayOf(\n    PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.func]))\n  ),\n  sourceCodeUrl: PropTypes.string,\n  userGuideUrl: PropTypes.string,\n})\n\n// The status of a single transaction (only used to deploy an org for now).\n// The â€œupcomingâ€ status is used to indicate that the transaction is waiting\n// for another one to be mined before being processed.\nexport const TransactionStatusType = PropTypes.oneOf([\n  TRANSACTION_STATUS_ERROR,\n  TRANSACTION_STATUS_PENDING,\n  TRANSACTION_STATUS_SUCCESS,\n  TRANSACTION_STATUS_UPCOMING,\n])\n\n// See src/wallet.js\nexport const WalletType = PropTypes.shape({\n  account: PropTypes.string,\n  balance: PropTypes.object.isRequired,\n  chainId: PropTypes.number.isRequired,\n  enable: PropTypes.bool.isRequired,\n  connected: PropTypes.bool.isRequired,\n  isContract: PropTypes.bool.isRequired,\n  networkType: PropTypes.string.isRequired,\n  providerInfo: PropTypes.object.isRequired,\n  web3: PropTypes.object.isRequired,\n})\n\nexport const AragonUiAppearanceType = PropTypes.oneOf(['dark', 'light'])\n\nexport const AragonUiThemeType = PropTypes.oneOf([\n  PropTypes.string,\n  PropTypes.shape({\n    _name: PropTypes.string.isRequired,\n    _appearance: AragonUiAppearanceType.isRequired,\n  }),\n])\n\nexport const ClientThemeType = PropTypes.shape({\n  theme: AragonUiThemeType,\n  appearance: AragonUiAppearanceType.isRequired,\n})\n","import React, { useCallback, useContext, useMemo, useState } from 'react'\nimport { getClientTheme, setClientTheme } from './local-settings'\n\nconst SETTINGS_THEME = getClientTheme()\nconst ClientThemeContext = React.createContext(SETTINGS_THEME)\n\nfunction ClientThemeProvider(props) {\n  const [appearance, setAppearance] = useState(SETTINGS_THEME.appearance)\n  const [theme, setTheme] = useState(SETTINGS_THEME.theme)\n\n  const toggleAppearance = useCallback(() => {\n    const newAppearance = appearance === 'light' ? 'dark' : 'light'\n    setAppearance(newAppearance)\n    setTheme(null)\n    setClientTheme(newAppearance)\n  }, [appearance])\n\n  const clientTheme = useMemo(\n    () => ({\n      appearance,\n      theme,\n      toggleAppearance,\n    }),\n    [appearance, theme, toggleAppearance]\n  )\n\n  return <ClientThemeContext.Provider value={clientTheme} {...props} />\n}\n\nfunction useClientTheme() {\n  return useContext(ClientThemeContext)\n}\n\nexport { ClientThemeProvider, useClientTheme }\n","function valueOf(obj) {\n  return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);\n}\n\nfunction valueEqual(a, b) {\n  // Test for strict equality first.\n  if (a === b) return true;\n\n  // Otherwise, if either of them == null they are not equal.\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return (\n      Array.isArray(b) &&\n      a.length === b.length &&\n      a.every(function(item, index) {\n        return valueEqual(item, b[index]);\n      })\n    );\n  }\n\n  if (typeof a === 'object' || typeof b === 'object') {\n    var aValue = valueOf(a);\n    var bValue = valueOf(b);\n\n    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);\n\n    return Object.keys(Object.assign({}, a, b)).every(function(key) {\n      return valueEqual(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n\nexport default valueEqual;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport resolvePathname from 'resolve-pathname';\nimport valueEqual from 'value-equal';\nimport warning from 'tiny-warning';\nimport invariant from 'tiny-invariant';\n\nfunction addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n}\nfunction stripLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path.substr(1) : path;\n}\nfunction hasBasename(path, prefix) {\n  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;\n}\nfunction stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n}\nfunction stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n}\nfunction parsePath(path) {\n  var pathname = path || '/';\n  var search = '';\n  var hash = '';\n  var hashIndex = pathname.indexOf('#');\n\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n}\nfunction createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n  var path = pathname || '/';\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : \"?\" + search;\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : \"#\" + hash;\n  return path;\n}\n\nfunction createLocation(path, state, key, currentLocation) {\n  var location;\n\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = parsePath(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n}\nfunction locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);\n}\n\nfunction createTransitionManager() {\n  var prompt = null;\n\n  function setPrompt(nextPrompt) {\n    process.env.NODE_ENV !== \"production\" ? warning(prompt == null, 'A history supports only one prompt at a time') : void 0;\n    prompt = nextPrompt;\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  }\n\n  function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message') : void 0;\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  }\n\n  var listeners = [];\n\n  function appendListener(fn) {\n    var isActive = true;\n\n    function listener() {\n      if (isActive) fn.apply(void 0, arguments);\n    }\n\n    listeners.push(listener);\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  }\n\n  function notifyListeners() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(void 0, args);\n    });\n  }\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\nfunction getConfirmation(message, callback) {\n  callback(window.confirm(message)); // eslint-disable-line no-alert\n}\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\n\nfunction supportsHistory() {\n  var ua = window.navigator.userAgent;\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\n  return window.history && 'pushState' in window.history;\n}\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\n\nfunction supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf('Trident') === -1;\n}\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\n\nfunction supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\n}\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\n\nfunction isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n}\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nfunction getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n}\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\n\n\nfunction createBrowserHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Browser history needs a DOM') : invariant(false) : void 0;\n  var globalHistory = window.history;\n  var canUseHistory = supportsHistory();\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\n  var _props = props,\n      _props$forceRefresh = _props.forceRefresh,\n      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n\n  function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var path = pathname + search + hash;\n    process.env.NODE_ENV !== \"production\" ? warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".') : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return createLocation(path, state, key);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (isExtraneousPopstateEvent(event)) return;\n    handlePop(getDOMLocation(event.state));\n  }\n\n  function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  }\n\n  var forceNextPop = false;\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  }\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key]; // Public interface\n\n  function createHref(location) {\n    return basename + createPath(location);\n  }\n\n  function push(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.pushState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex + 1);\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n        process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history') : void 0;\n        window.location.href = href;\n      }\n    });\n  }\n\n  function replace(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.replaceState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n        process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history') : void 0;\n        window.location.replace(href);\n      }\n    });\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nvar HashChangeEvent$1 = 'hashchange';\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nfunction stripHash(url) {\n  var hashIndex = url.indexOf('#');\n  return hashIndex === -1 ? url : url.slice(0, hashIndex);\n}\n\nfunction getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n}\n\nfunction pushHashPath(path) {\n  window.location.hash = path;\n}\n\nfunction replaceHashPath(path) {\n  window.location.replace(stripHash(window.location.href) + '#' + path);\n}\n\nfunction createHashHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Hash history needs a DOM') : invariant(false) : void 0;\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n  var _props = props,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = _props.hashType,\n      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n  function getDOMLocation() {\n    var path = decodePath(getHashPath());\n    process.env.NODE_ENV !== \"production\" ? warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".') : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return createLocation(path);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  function locationsAreEqual$$1(a, b) {\n    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;\n  }\n\n  function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n      handlePop(location);\n    }\n  }\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  } // Ensure the hash is encoded properly before doing anything else.\n\n\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)]; // Public interface\n\n  function createHref(location) {\n    var baseTag = document.querySelector('base');\n    var href = '';\n\n    if (baseTag && baseTag.getAttribute('href')) {\n      href = stripHash(window.location.href);\n    }\n\n    return href + '#' + encodePath(basename + createPath(location));\n  }\n\n  function push(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Hash history cannot push state; it is ignored') : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex + 1);\n        nextPaths.push(path);\n        allPaths = nextPaths;\n        setState({\n          action: action,\n          location: location\n        });\n      } else {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack') : void 0;\n        setState();\n      }\n    });\n  }\n\n  function replace(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Hash history cannot replace state; it is ignored') : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n    process.env.NODE_ENV !== \"production\" ? warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(HashChangeEvent$1, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(HashChangeEvent$1, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n/**\n * Creates a history object that stores locations in memory.\n */\n\n\nfunction createMemoryHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      getUserConfirmation = _props.getUserConfirmation,\n      _props$initialEntries = _props.initialEntries,\n      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,\n      _props$initialIndex = _props.initialIndex,\n      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = history.entries.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());\n  }); // Public interface\n\n  var createHref = createPath;\n\n  function push(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n      var nextEntries = history.entries.slice(0);\n\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  }\n\n  function replace(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      history.entries[history.index] = location;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n    var action = 'POP';\n    var location = history.entries[nextIndex];\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  }\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    return transitionManager.setPrompt(prompt);\n  }\n\n  function listen(listener) {\n    return transitionManager.appendListener(listener);\n  }\n\n  var history = {\n    length: entries.length,\n    action: 'POP',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nexport { createBrowserHistory, createHashHistory, createMemoryHistory, createLocation, locationsAreEqual, parsePath, createPath };\n","import React, { useEffect, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport { useImageExists, RADIUS } from '@aragon/ui'\nimport { appIconUrl, legacyAppIconUrl } from '../../util/utils'\n\nimport iconSvgAcl from './assets/app-acl.svg'\nimport iconSvgApps from './assets/app-apps.svg'\nimport iconSvgDefault from './assets/app-default.svg'\nimport iconSvgHome from './assets/app-home.svg'\nimport iconSvgKernel from './assets/app-kernel.svg'\nimport iconSvgPermissions from './assets/app-permissions.svg'\nimport iconSvgRegistry from './assets/app-registry.svg'\nimport iconSvgSettings from './assets/app-settings.svg'\nimport iconSvgConsole from './assets/app-console.svg'\n\nconst DEFAULT_SIZE = 24\nconst DEFAULT_RADIUS = RADIUS\n\n// Delay before we start displaying the fallback\nconst DISPLAY_FALLBACK_DELAY = 50\n\nconst KNOWN_ICONS = new Map([\n  ['apps', iconSvgApps],\n  ['console', iconSvgConsole],\n  ['home', iconSvgHome],\n  ['organization', iconSvgSettings],\n  ['permissions', iconSvgPermissions],\n  [\n    '0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c',\n    iconSvgKernel,\n  ],\n  [\n    '0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61',\n    iconSvgRegistry,\n  ],\n  [\n    '0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a',\n    iconSvgAcl,\n  ],\n])\n\nconst AppIcon = React.memo(function AppIcon({\n  app,\n  src,\n  size,\n  radius,\n  ...props\n}) {\n  if (radius === -1) {\n    radius = size * (DEFAULT_RADIUS / DEFAULT_SIZE)\n  }\n  return (\n    <div\n      css={`\n        display: flex;\n        align-items: center;\n        overflow: hidden;\n        border-radius: ${radius}px;\n      `}\n      {...props}\n    >\n      <AppIconContent app={app} size={size} src={src} />\n    </div>\n  )\n})\n\nAppIcon.propTypes = {\n  app: PropTypes.object,\n  src: PropTypes.string,\n  radius: PropTypes.number,\n  size: PropTypes.number.isRequired,\n}\n\nAppIcon.defaultProps = {\n  app: null,\n  src: null,\n  radius: -1,\n  size: DEFAULT_SIZE,\n}\n\n// Disabling the ESLint prop-types check for internal components.\n/* eslint-disable react/prop-types */\n\nconst AppIconContent = React.memo(({ app, size, src }) => {\n  if (src) {\n    return <RemoteIcon src={src} size={size} />\n  }\n\n  if (app && KNOWN_ICONS.has(app.appId)) {\n    return <IconBase size={size} src={KNOWN_ICONS.get(app.appId)} />\n  }\n\n  return (\n    <RemoteIcon src={appIconUrl(app, size)} size={size}>\n      <RemoteIcon src={legacyAppIconUrl(app)} size={size} />\n    </RemoteIcon>\n  )\n})\n\n// Display a remote icon if found,\n// or the provided fallback, or the default icon.\nconst RemoteIcon = React.memo(({ src, size, children }) => {\n  const { exists, loading } = useImageExists(src)\n  const [displayFallback, setDisplayFallback] = useState(false)\n\n  useEffect(() => {\n    const timer = setTimeout(\n      () => setDisplayFallback(true),\n      DISPLAY_FALLBACK_DELAY\n    )\n    return () => clearTimeout(timer)\n  }, [])\n\n  // display fallback\n  if ((!exists && !loading) || (loading && displayFallback)) {\n    return children || <IconBase size={size} src={iconSvgDefault} />\n  }\n\n  return <IconBase size={size} src={src} />\n})\n\n// Base icon\nconst IconBase = React.memo(({ src, size, alt = '', ...props }) => (\n  <img {...props} src={src} width={size} height={size} alt={alt} />\n))\n\nexport default AppIcon\n","import React from 'react'\nimport AppIcon from './components/AppIcon/AppIcon'\n\nfunction staticApp(id, name, route = `/${id}`) {\n  const app = {\n    name,\n    appId: id,\n    instances: [{ instanceId: id }],\n  }\n\n  app.icon = <AppIcon app={app} />\n\n  return { app, route }\n}\n\nexport const staticApps = new Map(\n  Object.entries({\n    apps: staticApp('apps', 'App Center'),\n    console: staticApp('console', 'Console'),\n    home: staticApp('home', 'Home', ''),\n    organization: staticApp('organization', 'Organization'),\n    permissions: staticApp('permissions', 'Permissions'),\n  })\n)\n\nexport const isStaticApp = instanceId => {\n  for (const { app } in staticApps) {\n    if (app.appId === instanceId) {\n      return true\n    }\n  }\n  return false\n}\n","const methods = {\n  PAGE: 0,\n  IDENTIFY: 1,\n  EVENT: 2,\n}\n\nexport const events = {\n  DAO_CREATEBTN_CLICKED: 'dao_createBtn_clicked',\n  DAO_CREATED: 'dao_created',\n  DAO_CREATIONFAILED: 'dao_creationFailed',\n  WALLET_DISCONNECTED: 'wallet_disconnected',\n  DAO_CREATION_TEMPLATE_SELECTED: 'daoCreation_template_selected',\n\n  OPEN_ORGANIZATION_CLICKED: 'openOrganization_clicked',\n  CREATE_ORGANIZATION_CLICKED: 'createOrganization_clicked',\n  ORGANIZATION_LINK_CLICKED: 'organizationLink_clicked',\n  FAVORITE_ORGANIZATION_TOGGLED: 'favoriteOrganization_toggled',\n  USER_SETTINGS_CLICKED: 'userSettings_clicked',\n  USER_NETWORK_SETTINGS_SAVED: 'userNetworkSettings_saved',\n  CACHE_CLEARED: 'cache_cleared',\n  NAVIGATION_OPTION_SELECTED: 'navigation_option_selected',\n  DAO_CREATION_NEXT_CLICKED: 'daoCreation_next_clicked',\n  DAO_NOT_FOUND: 'dao_notFound',\n}\n\n/**\n * This private method extracts the necessary method from the global window object.\n *\n * @param {methods} method Type of analyts to track\n * @returns {void} the corresponding analytics method\n */\nfunction getAnalyticsMethod(method) {\n  var windowAnalytics = window.rudderanalytics\n  if (!windowAnalytics) {\n    return\n  }\n  if (method === methods.PAGE) return windowAnalytics.page\n  if (method === methods.IDENTIFY) return windowAnalytics.identify\n  if (method === methods.EVENT) return windowAnalytics.track\n}\n/**\n * This method keeps track of certain events (like creation of proposals, etc.).\n *\n * @param {events} event name of the event to be tracked\n * @param {Object} eventData relating to tracked event\n * @returns {void}\n */\nexport function trackEvent(event, eventData) {\n  var trackerMethod = getAnalyticsMethod(methods.EVENT)\n  if (typeof trackerMethod !== 'function') {\n    return\n  }\n  trackerMethod(event, eventData)\n}\n\n/**\n * Sends analytics informations about the pages visited.\n *\n * @param {String} pathName (Dynamic) Path name as given by the router.\n * @returns {void}\n */\nexport function trackPage(pathName) {\n  var trackerMethod = getAnalyticsMethod(methods.PAGE)\n  if (typeof trackerMethod !== 'function') {\n    return\n  }\n  trackerMethod({\n    path: pathName,\n  })\n}\n\n/**\n * Sends analytics informations about the connected wallets.\n *\n * @param {String} account Wallet address\n * @param {String} networkType The network the wallet is connected to\n * @param {String} connector Wallet connector used by use-wallet library\n * @returns {void}\n */\nexport function identifyUser(account, networkType, connector) {\n  var trackerMethod = getAnalyticsMethod(methods.IDENTIFY)\n  if (typeof trackerMethod !== 'function') {\n    return\n  }\n  var walletData = {\n    wallet_address: account,\n    wallet_provider: connector,\n    network: networkType,\n  }\n  trackerMethod(walletData)\n}\n","import PropTypes from 'prop-types'\nimport React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n} from 'react'\nimport { createHashHistory as createHistory } from 'history'\nimport { log, addStartingSlash } from './util/utils'\nimport { staticApps } from './static-apps'\nimport { isAddress, isValidEnsName } from './util/web3'\n\nimport { trackPage } from './analytics'\nimport { useAPM, instrumentAPMRouts } from './contexts/elasticAPM'\n\nexport const ARAGONID_ENS_DOMAIN = 'aragonid.eth'\n\n// The locator represents the current route.\n// It contains a mode object, which represents one of the app modes.\n//\n// Locator {\n//   mode: // OrgMode or OnboardingMode (see below)\n//   preferences: {\n//     section    // preferences section name\n//     subsection // preferences subsection\n//     data       // section data\n//   }\n// }\n//\n// OrgMode {\n//   name = \"org\"\n//   orgAddress   // ENS domain or Ethereum address for the organization\n//   instanceId   // app proxy address or internal app identifier (apps, console, etc.)\n//   instancePath // app local path\n// }\n//\n// OnboardingMode {\n//   name = \"onboarding\"\n//   status       // \"open\" or \"create\"\n// }\n\n// Encode an app local path in a way that can be safely used in the URL\nfunction encodeAppPath(path) {\n  return addStartingSlash(\n    path\n      .split('/')\n      .map(v => encodeURIComponent(v))\n      .join('/')\n  )\n}\n\n// Decodes an app local path from the URL\nfunction decodeAppPathParts(pathParts) {\n  return pathParts.map(v => decodeURIComponent(v)).join('/')\n}\n\n// Parse a path and a search query and return a locator object.\nexport function parsePath(pathname, search = '') {\n  const [, ...parts] = pathname.split('/')\n\n  const baseLocator = {\n    preferences: parsePreferences(search),\n  }\n\n  // Onboarding\n  if (!parts[0] || parts[0] === 'open' || parts[0] === 'create') {\n    return {\n      ...baseLocator,\n      mode: {\n        name: 'onboarding',\n        status: parts[0] || 'welcome',\n      },\n    }\n  }\n\n  let [orgAddress] = parts\n  const validAddress = isAddress(orgAddress)\n  const validDomain = isValidEnsName(orgAddress)\n\n  // Assume .aragonid.eth if not given a valid address or a valid ENS domain\n  if (!validAddress && !validDomain) {\n    orgAddress += `.${ARAGONID_ENS_DOMAIN}`\n  }\n\n  const [, instanceId, ...instancePathParts] = parts\n\n  // The local path of an app (internal or external)\n  const instancePath = `/${\n    instancePathParts ? decodeAppPathParts(instancePathParts) : ''\n  }`\n\n  return {\n    ...baseLocator,\n    mode: {\n      name: 'org',\n      instanceId: instanceId || 'home',\n      instancePath: instancePath || '',\n      orgAddress: orgAddress || '',\n    },\n  }\n}\n\n// Return a path string from a locator updater.\nexport function getPath({ mode, preferences } = {}) {\n  // Preferences\n  const search = getPreferencesSearch(preferences)\n\n  // Fallback if no expected path was found\n  const fallbackPath = `/${search}`\n\n  if (!mode) {\n    return fallbackPath\n  }\n\n  if (mode.name === 'onboarding') {\n    const { status } = mode\n    return `/${!status || status === 'welcome' ? '' : status}${search}`\n  }\n\n  if (mode.name === 'org') {\n    let { orgAddress } = mode\n\n    if (!orgAddress) {\n      log(\n        \"Routing(path): 'orgAddress' is a required component for 'org' mode. \" +\n          `Defaulted to '${fallbackPath}'.`\n      )\n      return fallbackPath\n    }\n\n    // Only keep the full address if it ends in aragonid.eth\n    if (orgAddress.endsWith(ARAGONID_ENS_DOMAIN)) {\n      orgAddress = orgAddress.substr(\n        0,\n        orgAddress.indexOf(ARAGONID_ENS_DOMAIN) - 1\n      )\n    }\n\n    // Either the address of an app instance or the path of an internal app.\n    const { instanceId = '' } = mode\n    const instancePart = staticApps.has(instanceId)\n      ? staticApps.get(instanceId).route\n      : instanceId\n      ? `/${instanceId}`\n      : ''\n\n    let { instancePath = '' } = mode\n    if (instancePath && !instanceId) {\n      log(\n        \"Routing(path): 'instancePath' can only be provided if an \" +\n          `'instanceId' is provided in 'org' mode. Ignored '${instancePath}'.`\n      )\n      instancePath = ''\n    }\n\n    return (\n      '/' + orgAddress + instancePart + encodeAppPath(instancePath) + search\n    )\n  }\n\n  log(\n    `Routing(path): invalid mode '${mode.name}' set. Defaulted to '${fallbackPath}'.`\n  )\n\n  return fallbackPath\n}\n\n// Preferences\nexport function parsePreferences(search = '') {\n  const searchParams = new URLSearchParams(search)\n  const path = searchParams.get('preferences') || ''\n  // Ignore labels if search does not contain a preferences path\n  const labels = searchParams.has('preferences')\n    ? searchParams.get('labels')\n    : ''\n\n  const [, section = '', subsection = ''] = path.split('/')\n\n  const data = {}\n\n  if (labels) {\n    data.labels = labels\n  }\n\n  return { section, subsection, data }\n}\n\n// For preferences, get the â€œsearchâ€ part of the path (?=something)\n// This function will probably be unified with parsePath() later.\nexport function getPreferencesSearch({ section, subsection, data = {} } = {}) {\n  if (!section) {\n    if (subsection) {\n      log(\n        \"Routing(preferences): 'subsection' can only be provided if 'section' \" +\n          `is provided. Ignored '${subsection}'.`\n      )\n    }\n    return ''\n  }\n\n  const params = new URLSearchParams()\n\n  params.append(\n    'preferences',\n    `/${section}${subsection ? `/${subsection}` : ''}`\n  )\n\n  if (data.labels) {\n    params.append('labels', data.labels)\n  }\n\n  const search = decodeURIComponent(params.toString())\n  return search ? `?${search}` : ''\n}\n\nconst RoutingContext = React.createContext()\n\nexport function RoutingProvider({ children }) {\n  const history = useRef(null)\n\n  const [{ locator, previousLocator }, updateLocator] = useReducer(\n    ({ locator, previousLocator }, newLocator) => ({\n      previousLocator: locator,\n      locator: newLocator,\n    }),\n    null,\n    () => ({ locator: parsePath('/'), previousLocator: null })\n  )\n\n  // Change the URL if needed\n  const updatePath = useCallback(path => {\n    const location = history.current && history.current.location\n    if (location && path !== location.pathname + location.search) {\n      history.current.push(path)\n    }\n  }, [])\n\n  const getPathFromLocator = useCallback(\n    locatorUpdate => {\n      if (typeof locatorUpdate === 'function') {\n        locatorUpdate = locatorUpdate(locator) || {}\n      }\n      return getPath(locatorUpdate)\n    },\n    [locator]\n  )\n\n  const updatePathFromLocator = useCallback(\n    locatorUpdate => {\n      updatePath(getPathFromLocator(locatorUpdate))\n    },\n    [getPathFromLocator, updatePath]\n  )\n\n  const handleLocation = useCallback(({ pathname, search, state = {} }) => {\n    if (state.alreadyParsed) {\n      return\n    }\n\n    const locator = parsePath(pathname, search)\n\n    // Replace URL with non-aragonid.eth version\n    if (\n      locator.orgAddress &&\n      locator.orgAddress.endsWith(ARAGONID_ENS_DOMAIN)\n    ) {\n      history.current.replace({\n        pathname: locator.pathname.replace(`.${ARAGONID_ENS_DOMAIN}`, ''),\n        search: locator.search,\n        state: { alreadyParsed: true },\n      })\n    }\n\n    updateLocator(locator)\n  }, [])\n\n  const back = useCallback(() => {\n    if (!history.current) {\n      return\n    }\n    if (previousLocator) {\n      history.current.goBack()\n    } else {\n      updatePath('/')\n    }\n  }, [previousLocator, updatePath])\n\n  useEffect(() => {\n    history.current = createHistory()\n\n    handleLocation(history.current.location)\n\n    // analytics\n    history.current.listen(change => {\n      trackPage(change.pathname)\n    })\n\n    // history.current.listen() returns a function to stop listening.\n    return history.current.listen(handleLocation)\n  }, [handleLocation])\n\n  const routing = useMemo(\n    () => ({\n      back,\n      locator,\n      mode: locator.mode,\n      path: getPathFromLocator,\n      preferences: locator.preferences,\n      update: updatePathFromLocator,\n    }),\n    [back, getPathFromLocator, locator, updatePathFromLocator]\n  )\n\n  const { apm } = useAPM()\n  useEffect(() => {\n    instrumentAPMRouts(apm, routing.mode)\n  }, [apm, routing.mode])\n\n  return (\n    <RoutingContext.Provider value={routing}>\n      {children}\n    </RoutingContext.Provider>\n  )\n}\n\nRoutingProvider.propTypes = { children: PropTypes.node }\n\nexport function useRouting() {\n  return useContext(RoutingContext)\n}\n","import { iOS, isSafari } from '../util/utils'\n\n// See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe for details about sandbox\n// `sandbox` works like a whitelist: by default, almost every functionality is restricted.\nexport const appIframeSandbox = [\n  // Allows downloads to be initiated by the user\n  // Required for Chrome 83+ (see https://www.chromestatus.com/feature/5706745674465280)\n  'allow-downloads',\n\n  // Allow forms to be submitted\n  'allow-forms',\n\n  // Allows new browsing contexts to be created (window.open, target=\"_blank\").\n  'allow-popups',\n\n  // Allows new browsing contexts (e.g. new windows or tabs) generated by the\n  // iframe to escape the sandbox restrictions. Otherwise, new contexts would\n  // share the same restrictions as their originating iframe (in our case, the\n  // new contexts would only have the ability to run JavaScript).\n  'allow-popups-to-escape-sandbox',\n\n  // Gotta run 'em all!\n  'allow-scripts',\n\n  // Note that we haven't enabled:\n  //   - 'allow-same-origin':\n  //       The most important security setting: leaving this disabled lets the\n  //       iframe be considered as coming from a unique, orphan origin. This\n  //       means that the page won't have access to any cookies, local/session\n  //       storage, or access to open pages (e.g. the parent window, this Dapp).\n  //\n  //       However, this does force some restrictions:\n  //         - `window.postMessage()` must use `*` as an origin to communicate\n  //           with this iframe\n  //         - React devtools can't be hooked in from the browser, so you have\n  //           to use the native `react-devtools` electron app for debugging\n  //\n  //  - 'allow-top-navigation':\n  //       Leaving this disabled disallows the iframe from navigating the\n  //       Dapp's context (e.g. to a malicious page)\n].join(' ')\n\nexport const workerFrameSandbox = [\n  // Needed to run the script that starts the WebWorker in the iframe\n  'allow-scripts',\n\n  // Note that we haven't enabled 'allow-same-origin' as this is what creates\n  // the opaque origin for the WebWorkers\n].join(' ')\n\n// The sandbox is disabled because macOS Safari and iOS browsers do not allow\n// blobs to be read in sandboxed iframes: https://bugs.webkit.org/show_bug.cgi?id=170075\nexport const workerFrameSandboxDisabled = iOS || isSafari\n","import { getParsedAppLocator } from '../environment'\nimport { getIpfsGateway } from '../local-settings'\nimport { appendTrailingSlash } from './utils'\n\n/*\n * Supported locations:\n *   ipfs:{IPFS_HASH}\n *   http:{HOST}\n *   http:{HOST}:{PORT}\n *   http:{HOST}:{PORT}/{PATH}\n *   http:http(s)://{HOST}\n *   http:http(s)://{HOST}:{PORT}\n *   http:http(s)://{HOST}:{PORT}/{PATH}\n */\nfunction contentBaseUrl(content, gateway) {\n  if (!content) {\n    return ''\n  }\n\n  const { provider, location } = content\n  if (provider === 'ipfs') {\n    return `${gateway}/${location}/`\n  }\n  if (provider === 'http') {\n    return /^https?:\\/\\//.test(location)\n      ? appendTrailingSlash(location)\n      : `http://${location}/`\n  }\n  return ''\n}\n\nexport function appBaseUrl(app, networkType) {\n  const appLocator = getParsedAppLocator(networkType)\n  // Support overriding app URLs, see network-config.js\n  if (appLocator[app.appId]) {\n    return appLocator[app.appId]\n  }\n\n  const gateway = getIpfsGateway()\n  return contentBaseUrl(app.content, gateway)\n}\n\nexport function repoBaseUrl(appId, repoVersion, networkType) {\n  const appLocator = getParsedAppLocator(networkType)\n  const gateway = getIpfsGateway()\n\n  // Support overriding app URLs, see network-config.js\n  if (appLocator[appId]) {\n    return appLocator[appId]\n  }\n\n  return contentBaseUrl(\n    // The version's content is the artifact.json and manifest.json, so we need to\n    // look up content again for the actual content location\n    repoVersion.content && repoVersion.content.content,\n    gateway\n  )\n}\n\n// Removes the HTTP protocol of a URL, and the final slash.\nexport function stripUrlProtocol(url = '') {\n  return url.replace(/^https?:\\/\\//, '').replace(/\\/$/, '')\n}\n\nconst CODE_REPO_SERVICES = [\n  ['GitHub', /^(?:https?:\\/\\/)?github\\.com/i],\n  ['GitLab', /^(?:https?:\\/\\/)?gitlab\\.com/i],\n  ['Bitbucket', /^(?:https?:\\/\\/)?bitbucket\\.com/i],\n]\n\n// Return the name of a repository service based on a URL,\n// with or without the HTTP protocol prefix.\nexport function sanitizeCodeRepositoryUrl(url) {\n  for (const [name, re] of CODE_REPO_SERVICES) {\n    if (re.test(url)) {\n      return name\n    }\n  }\n  return url\n}\n","/*! (c) Andrea Giammarchi - ISC */\nvar self = this || /* istanbul ignore next */ {};\ntry {\n  self.EventTarget = (new EventTarget).constructor;\n} catch(EventTarget) {\n  (function (Object, wm) {\n    var create = Object.create;\n    var defineProperty = Object.defineProperty;\n    var proto = EventTarget.prototype;\n    define(proto, 'addEventListener', function (type, listener, options) {\n      for (var\n        secret = wm.get(this),\n        listeners = secret[type] || (secret[type] = []),\n        i = 0, length = listeners.length; i < length; i++\n      ) {\n        if (listeners[i].listener === listener)\n          return;\n      }\n      listeners.push({target: this, listener: listener, options: options});\n    });\n    define(proto, 'dispatchEvent', function (event) {\n      var secret = wm.get(this);\n      var listeners = secret[event.type];\n      if (listeners) {\n        define(event, 'target', this);\n        define(event, 'currentTarget', this);\n        listeners.slice(0).forEach(dispatch, event);\n        delete event.currentTarget;\n        delete event.target;\n      }\n      return true;\n    });\n    define(proto, 'removeEventListener', function (type, listener) {\n      for (var\n        secret = wm.get(this),\n        listeners = secret[type] || (secret[type] = []),\n        i = 0, length = listeners.length; i < length; i++\n      ) {\n        if (listeners[i].listener === listener) {\n          listeners.splice(i, 1);\n          return;\n        }\n      }\n    });\n    self.EventTarget = EventTarget;\n    function EventTarget() {'use strict';\n      wm.set(this, create(null));\n    }\n    function define(target, name, value) {\n      defineProperty(\n        target,\n        name,\n        {\n          configurable: true,\n          writable: true,\n          value: value\n        }\n      );\n    }\n    function dispatch(info) {\n      var options = info.options;\n      if (options && options.once)\n        info.target.removeEventListener(this.type, info.listener);\n      if (typeof info.listener === 'function')\n        info.listener.call(info.target, this);\n      else\n        info.listener.handleEvent(this);\n    }\n  }(Object, new WeakMap));\n}\nexport default self.EventTarget;\n","import EventTarget from '@ungap/event-target'\nimport {\n  workerFrameSandbox,\n  workerFrameSandboxDisabled,\n} from '../security/configuration'\n\n/**\n * A few notes on WebWorker security, and why this \"sandboxed\" version is\n * necessary:\n *\n * As we run untrusted code in WebWorkers, we want to make them isolated and\n * sandboxed from the parent application (i.e. the code you're reading) and any\n * other code it may have loaded (e.g. other untrusted applications).\n *\n * WebWorkers, by default, have no DOM or localStorage access. They were mostly\n * designed to run background jobs, listening to its parent for instructions.\n * This default allows WebWorkers to be \"mostly\" sandboxed, such that there is\n * already a limited attack surface for malicious scripts to target.\n *\n * **Unforunately**, one of those exposed, attackable surfaces is the indexedDB\n * storage API. WebWorkers have unconstrained access to any indexedDB databases\n * available in the same origin (note that WebWorkers are also only able to load\n * scripts from the same origin). For a full listing of the methods and APIs\n * available, see https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers.\n *\n * As we store a lot of information in indexedDB (due to its feature set over\n * localStorage), this means Bad Things could happen if we loaded a malicious\n * script that manipulated some indexedDB databases.\n *\n * One way to solve this problem is to use a data URL instead of a string or\n * object URL. WebWorkers created with data URLs are created with opaque\n * (\"orphaned\") origins (see https://html.spec.whatwg.org/multipage/workers.html#dom-worker)\n * and this negates the same-origin access.\n *\n * However, consuming and processing data URLs was found to be hugely\n * inefficient and resulted in severe performance degradation upon the initial\n * load of a script.\n *\n * Thus, we instead chose to \"wrap\" these WebWorkers with an iframe, using the\n * iframe to create the opaque origin (unless disabled; see Safari bug).\n */\n\nclass SandboxedWorker extends EventTarget {\n  constructor(scriptUrl, { name } = {}) {\n    super()\n\n    this.name = name\n    this.iframe = document.createElement('iframe')\n    if (!workerFrameSandboxDisabled) {\n      this.iframe.sandbox = workerFrameSandbox\n    }\n    this.iframe.style = `\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 0;\n      height: 0;\n      opacity: 0;\n      border: 0;\n    `\n\n    const source = `\n      <script>\n        const fetchScriptUrlAsBlob = async url => {\n          // In the future, we might support IPFS protocols in addition to http\n          const res = await fetch(url, {\n            method: 'GET',\n            mode: 'cors',\n          })\n          // If status is not a 2xx (based on Response.ok), assume it's an error\n          // See https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch\n          if (!(res && res.ok)) {\n            throw res\n          }\n          return res.blob()\n        }\n        async function getObjectUrlForScript(scriptUrl) {\n          const blob = await fetchScriptUrlAsBlob(scriptUrl)\n          return URL.createObjectURL(blob)\n        }\n        const init = async () => {\n          // WebWorkers can only load scripts from the local origin, so we\n          // have to fetch the script (from an IPFS gateway) and process it locally.\n          const workerUrl = await getObjectUrlForScript('${scriptUrl}')\n\n          const worker = new Worker(workerUrl, { name: '${name}' })\n\n          // Must use '*' for origin as we've sandboxed the iframe's origin\n          worker.addEventListener('message', event => window.parent.postMessage({ from: '${name}', msg: event.data }, '*'), false)\n          worker.addEventListener(\n            'error',\n            error => {\n              console.error('Error from worker for ${name} (loaded from ${scriptUrl}):', error.message, error)\n              window.parent.postMessage(\n                {\n                  from: '${name}',\n                  error: {\n                    filename: error.filename,\n                    message: error.message,\n                    lineno: error.lineno,\n                  },\n                },\n                '*'\n              )\n            },\n            false\n            )\n          window.addEventListener('message', ({ data, source }) => {\n            if (source === window.parent) {\n              worker.postMessage(data)\n            }\n          })\n\n          window.addEventListener('unload', () => {\n            // Clean up the url we created to spawn the worker when the iframe is unloaded\n            // Note that we **NEED** to do this late, as Chrome 83+ appears to have\n            // introduced a race condition with starting workers using object URLs,\n            // preventing us from synchronously revoking this object URL immediately.\n            URL.revokeObjectURL(workerUrl)\n          })\n        }\n\n        init()\n          .catch(err => {\n            console.error(\"Failed to load ${name}'s script (${scriptUrl}): \", err)\n          })\n      </script>\n    `\n    this.iframe.srcdoc = source\n    document.body.appendChild(this.iframe)\n\n    window.addEventListener('message', this.handleIframeMessage, false)\n  }\n\n  postMessage(msg) {\n    if (this.iframe) {\n      // Must use '*' for origin as we've sandboxed the iframe's origin\n      this.iframe.contentWindow.postMessage(msg, '*')\n    }\n  }\n\n  terminate() {\n    window.removeEventListener('message', this.handleIframeMessage)\n    if (this.iframe) {\n      this.iframe.remove()\n    }\n    this.iframe = null\n  }\n\n  handleIframeMessage = event => {\n    const {\n      source,\n      data: { from, error, msg },\n    } = event\n    if (source === this.iframe.contentWindow && from === this.name) {\n      this.dispatchEvent(\n        new MessageEvent(error ? 'error' : 'message', {\n          data: error || msg,\n        })\n      )\n    }\n  }\n}\n\nexport default SandboxedWorker\n","class WorkerSubscriptionPool {\n  workers = new Map()\n  addWorker({ app, connection, worker }) {\n    this.workers.set(app.proxyAddress, { app, connection, worker })\n  }\n  hasWorker(proxyAddress) {\n    return this.workers.has(proxyAddress)\n  }\n  async removeWorker(proxyAddress, { clearCache } = {}) {\n    if (this.hasWorker(proxyAddress)) {\n      const { connection, worker } = this.workers.get(proxyAddress)\n      this.workers.delete(proxyAddress)\n\n      worker.terminate()\n\n      if (clearCache) {\n        await connection.shutdownAndClearCache()\n      } else {\n        connection.shutdown()\n      }\n    }\n  }\n  unsubscribe() {\n    this.workers.forEach(({ connection, worker }) => {\n      // TODO: ask worker to nicely terminate itself first\n      worker.terminate()\n      connection.shutdown()\n    })\n\n    // Reset pool\n    this.workers.clear()\n  }\n}\n\nexport default WorkerSubscriptionPool\n","import { networkConfigs } from '../network-config'\nimport { getLocalStorageKey } from '../util/utils'\n\nconst getGraphEndpoint = networkType => {\n  return networkConfigs[networkType].connectGraphEndpoint\n}\n\nconst query = `query Organizations($id: ID!) {\n    organizations(where: {id: $id},  orderBy: createdAt, orderDirection: desc){ \n      id\n      address\n      createdAt\n    }\n  }`\n\nconst ORGANIZATION_INFO = 'ORGANIZATION_INFO&'\n\nexport async function getOrganizationByAddress(networkType, daoAddress) {\n  const LOCAL_STORAGE_KEY = getLocalStorageKey(\n    `${ORGANIZATION_INFO}${daoAddress}`,\n    networkType\n  )\n  if (localStorage.getItem(LOCAL_STORAGE_KEY)) {\n    return JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY))\n  }\n\n  const graphEndpoint = getGraphEndpoint(networkType)\n  if (!graphEndpoint) {\n    // some network do not have subgraph (i.e. polygon)\n    return null\n  }\n\n  const data = await fetch(graphEndpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n    },\n    body: JSON.stringify({\n      query,\n      variables: { id: daoAddress.toLowerCase() },\n    }),\n  })\n\n  if (data.ok) {\n    const json = await data.json()\n    if (\n      json &&\n      json.data.organizations &&\n      json.data.organizations.length === 1\n    ) {\n      const organization = json.data.organizations[0]\n      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(organization))\n      return json.data.organizations[0]\n    }\n  }\n  return null\n}\n","import resolvePathname from 'resolve-pathname'\nimport Aragon, {\n  apm,\n  ensResolve,\n  getRecommendedGasLimit,\n  providers,\n} from '@aragon/wrapper'\nimport { appOverrides, sortAppsPair } from './environment'\nimport { NoConnection, DAONotFound } from './errors'\nimport { getEthSubscriptionEventDelay, getIpfsGateway } from './local-settings'\nimport { workerFrameSandboxDisabled } from './security/configuration'\nimport { appBaseUrl } from './util/url'\nimport { noop, removeStartingSlash, pollEvery } from './util/utils'\nimport {\n  getGasPrice,\n  getWeb3,\n  isEmptyAddress,\n  isValidEnsName,\n} from './util/web3'\nimport SandboxedWorker from './worker/SandboxedWorker'\nimport WorkerSubscriptionPool from './worker/WorkerSubscriptionPool'\nimport { getOrganizationByAddress } from './services/gql'\nimport { getNetworkConfig } from './network-config'\nimport { chains } from 'use-wallet'\nimport { getChainId, getNetworkSettings } from './util/network'\n\nconst POLL_DELAY_CONNECTIVITY = 2000\n\nconst applyAppOverrides = apps =>\n  apps.map(app => ({ ...app, ...(appOverrides[app.appId] || {}) }))\n\n// Sort apps, apply URL overrides, and attach data useful to the frontend\nconst prepareAppsForFrontend = (apps, daoAddress, networkType) => {\n  const hasWebApp = app => Boolean(app['start_url'])\n\n  const getAPMRegistry = ({ appName = '' }) =>\n    appName.substr(appName.indexOf('.') + 1) // everything after the first '.'\n\n  const getAppTags = app => {\n    const apmRegistry = getAPMRegistry(app)\n\n    const tags = []\n    if (app.status) {\n      tags.push(app.status)\n    }\n    if (apmRegistry && apmRegistry !== 'aragonpm.eth') {\n      tags.push(`${apmRegistry} registry`)\n    }\n    if (!hasWebApp(app)) {\n      tags.push('contract-only')\n    }\n\n    return tags\n  }\n\n  return applyAppOverrides(apps)\n    .map(app => {\n      const baseUrl = appBaseUrl(app, networkType)\n      // Remove the starting slash from the start_url field\n      // so the absolute path can be resolved from baseUrl.\n      const startUrl = removeStartingSlash(app['start_url'] || '')\n      const src = baseUrl ? resolvePathname(startUrl, baseUrl) : ''\n\n      return {\n        ...app,\n        src,\n        baseUrl,\n        apmRegistry: getAPMRegistry(app),\n        hasWebApp: hasWebApp(app),\n        tags: getAppTags(app),\n      }\n    })\n    .sort(sortAppsPair)\n}\n\nexport const pollConnectivity = pollEvery((providers = [], onConnectivity) => {\n  let lastFound = null\n  return {\n    request: async () => {\n      try {\n        await Promise.all(\n          providers.map(p => getWeb3(p).eth.net.getNetworkType())\n        )\n        return true\n      } catch (err) {\n        return false\n      }\n    },\n    onResult: connected => {\n      if (connected !== lastFound) {\n        lastFound = connected\n        onConnectivity(connected)\n      }\n    },\n  }\n  // web.eth.net.isListening()\n}, POLL_DELAY_CONNECTIVITY)\n\nexport const resolveEnsDomain = async (networkType, provider, domain) => {\n  try {\n    const registryAddress = getNetworkConfig(networkType).addresses.ensRegistry\n    return await ensResolve(domain, {\n      provider,\n      registryAddress,\n    })\n  } catch (err) {\n    if (err.message === 'ENS name not defined.') {\n      return ''\n    }\n    throw err\n  }\n}\n\nexport const isEnsDomainAvailable = async (networkType, provider, name) => {\n  const addr = await resolveEnsDomain(networkType, provider, name)\n  return addr === '' || isEmptyAddress(addr)\n}\n\nexport const fetchApmArtifact = async (provider, repoAddress, ipfsGateway) => {\n  return apm(getWeb3(provider), {\n    ipfsGateway,\n  }).fetchLatestRepoContent(repoAddress)\n}\n\nexport const performTransactionPaths = async (wrapper, transactionPaths) => {\n  if (Array.isArray(transactionPaths) && transactionPaths.length) {\n    for (const transaction of transactionPaths) {\n      await wrapper.performTransactionPath(transaction)\n    }\n  } else {\n    await wrapper.performTransactionPath([])\n  }\n}\n\n// Subscribe to aragon.js observables\nconst subscribe = (\n  wrapper,\n  {\n    onAppIdentifiers,\n    onApps,\n    onForwarders,\n    onIdentityIntent,\n    onInstalledRepos,\n    onPermissions,\n    onRequestPath,\n    onSignatures,\n    onTransaction,\n  },\n  { networkType }\n) => {\n  const {\n    appIdentifiers,\n    apps,\n    forwarders,\n    identityIntents,\n    installedRepos,\n    pathIntents,\n    permissions,\n    signatures,\n    transactions,\n  } = wrapper\n\n  const workerSubscriptionPool = new WorkerSubscriptionPool()\n\n  const subscriptions = {\n    appIdentifiers: appIdentifiers.subscribe(onAppIdentifiers),\n    connectedApp: null,\n    connectedWorkers: workerSubscriptionPool,\n    forwarders: forwarders.subscribe(onForwarders),\n    identityIntents: identityIntents.subscribe(onIdentityIntent),\n    installedRepos: installedRepos.subscribe(onInstalledRepos),\n    pathIntents: pathIntents.subscribe(onRequestPath),\n    permissions: permissions.subscribe(onPermissions),\n    signatures: signatures.subscribe(onSignatures),\n    transactions: transactions.subscribe(onTransaction),\n\n    apps: apps.subscribe(apps => {\n      onApps(\n        prepareAppsForFrontend(apps, wrapper.kernelProxy.address, networkType)\n      )\n    }),\n    workers: apps.subscribe(apps => {\n      // Asynchronously launch webworkers for each new or updated app that has\n      // a background script defined\n      applyAppOverrides(apps)\n        .filter(app => app.script)\n        .filter(\n          ({ proxyAddress, updated }) =>\n            updated || !workerSubscriptionPool.hasWorker(proxyAddress)\n        )\n        .forEach(async app => {\n          const { name, proxyAddress, script, updated } = app\n          const workerName = `${name}(${proxyAddress})`\n          const baseUrl = appBaseUrl(app, networkType)\n\n          // If the app URL is empty, the script canâ€™t be retrieved\n          if (!baseUrl) {\n            return\n          }\n\n          // Remove the starting slash from the script field to force it to\n          // load relative to the app's base url\n          const scriptUrl = resolvePathname(\n            removeStartingSlash(script),\n            baseUrl\n          )\n\n          const connectApp = await wrapper.runApp(proxyAddress)\n\n          // If the app has been updated, reset its cache and restart its worker\n          if (updated && workerSubscriptionPool.hasWorker(proxyAddress)) {\n            await workerSubscriptionPool.removeWorker(proxyAddress, {\n              clearCache: true,\n            })\n          }\n\n          // If another execution context already loaded this app's worker\n          // before we got to it here, let's short circuit\n          if (!workerSubscriptionPool.hasWorker(proxyAddress)) {\n            const worker = new SandboxedWorker(scriptUrl, { name: workerName })\n\n            const provider = new providers.MessagePortMessage(worker)\n            workerSubscriptionPool.addWorker({\n              app,\n              worker,\n              connection: connectApp(provider),\n            })\n          }\n        })\n    }),\n  }\n\n  return subscriptions\n}\n\nconst initWrapper = async (\n  dao,\n  {\n    networkType,\n    guiStyle = null,\n    onAppIdentifiers = noop,\n    onApps = noop,\n    onDaoAddress = noop,\n    onForwarders = noop,\n    onIdentityIntent = noop,\n    onInstalledRepos = noop,\n    onPermissions = noop,\n    onRequestPath = noop,\n    onSignatures = noop,\n    onTransaction = noop,\n    provider,\n    walletAccount = null,\n  } = {}\n) => {\n  const ipfsConf = { gateway: getIpfsGateway() }\n  const isDomain = isValidEnsName(dao)\n  const daoAddress = isDomain\n    ? await resolveEnsDomain(networkType, provider, dao)\n    : dao\n\n  if (!daoAddress) {\n    throw new DAONotFound(dao)\n  }\n\n  const daoData = {\n    address: daoAddress,\n    domain: dao,\n    networkType,\n  }\n\n  const data = await getOrganizationByAddress(networkType, daoAddress)\n  if (data?.createdAt) {\n    // transform into ml seconds\n    daoData.createdAt = parseInt(data.createdAt) * 1000\n  }\n\n  onDaoAddress(daoData)\n\n  const wrapper = new Aragon(daoAddress, {\n    provider,\n    // Let web3 provider handle gas estimations on mainnet\n    defaultGasPriceFn: () =>\n      getGasPrice(networkType, { mainnet: { disableEstimate: true } }),\n    apm: {\n      ensRegistryAddress: getNetworkConfig(networkType).addresses.ensRegistry,\n      ipfs: ipfsConf,\n    },\n    cache: {\n      // If the worker's origin sandbox is disabed, it has full access to IndexedDB.\n      // We force a downgrade to localStorage to avoid using IndexedDB.\n      forceLocalStorage: workerFrameSandboxDisabled,\n      prefix: networkType,\n    },\n    events: {\n      // Infura hack: delay event processing for specified number of ms\n      subscriptionEventDelay: getEthSubscriptionEventDelay(),\n      blockSizeLimit: getNetworkSettings(networkType).events?.blockSizeLimit,\n    },\n  })\n\n  try {\n    const network = chains.getChainInformation(getChainId(networkType))\n    await wrapper.init({\n      network,\n      accounts: {\n        providedAccounts: walletAccount ? [walletAccount] : [],\n      },\n      guiStyle,\n    })\n  } catch (err) {\n    if (err.message === 'Provided daoAddress is not a DAO') {\n      throw new DAONotFound(dao)\n    }\n    if (err.message === 'connection not open') {\n      throw new NoConnection('No blockchain connection detected')\n    }\n\n    throw err\n  }\n\n  const subscriptions = subscribe(\n    wrapper,\n    {\n      onAppIdentifiers,\n      onApps,\n      onForwarders,\n      onIdentityIntent,\n      onInstalledRepos,\n      onPermissions,\n      onRequestPath,\n      onSignatures,\n      onTransaction,\n    },\n    { networkType }\n  )\n\n  wrapper.connectAppIFrame = async (iframeElt, proxyAddress) => {\n    const provider = new providers.WindowMessage(iframeElt.contentWindow)\n    const appContext = (await wrapper.runApp(proxyAddress))(provider)\n\n    if (subscriptions.connectedApp) {\n      subscriptions.connectedApp.unsubscribe()\n    }\n    subscriptions.connectedApp = {\n      unsubscribe: appContext.shutdown,\n    }\n    return appContext\n  }\n\n  wrapper.cancel = () => {\n    Object.values(subscriptions).forEach(subscription => {\n      if (subscription) {\n        subscription.unsubscribe()\n      }\n    })\n  }\n\n  return wrapper\n}\n\nexport { getRecommendedGasLimit }\nexport default initWrapper\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the numb€€