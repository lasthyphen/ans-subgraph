
Š€€€ wrapped in a PermissionsContext (see end of file)\nclass AssignPermissionPanel extends React.PureComponent {\n  static propTypes = {\n    apps: PropTypes.arrayOf(AppType).isRequired,\n    grantPermission: PropTypes.func.isRequired,\n    getAppRoles: PropTypes.func.isRequired,\n    onClose: PropTypes.func.isRequired,\n    opened: PropTypes.bool.isRequired,\n    wrapper: AragonType,\n  }\n\n  state = {\n    ...DEFAULT_STATE,\n  }\n\n  handleAppChange = index => {\n    this.setState({ appIndex: index || -1, roleIndex: -1 })\n  }\n\n  handleRoleChange = index => {\n    this.setState({ roleIndex: index || -1 })\n  }\n\n  getNamedApps() {\n    const { apps } = this.props\n    return apps.filter(app => Boolean(app.name))\n  }\n\n  getRoles() {\n    const { getAppRoles } = this.props\n    const app = this.getSelectedApp()\n    const appRoles = app ? getAppRoles(app) : []\n    return appRoles.map(({ role }) => role)\n  }\n\n  appsLabels() {\n    return this.getNamedApps().map(app => (\n      <AppInstanceLabel app={app} proxyAddress={app.proxyAddress} />\n    ))\n  }\n\n  getAppsItems() {\n    return ['Select an app', ...this.appsLabels()]\n  }\n\n  getRolesItems() {\n    const roles = this.getRoles()\n    const names = roles.map(\n      role =>\n        (role && role.name) ||\n        `Unknown action (${(role && role.id) || 'no ID'})`\n    )\n    return ['Select an action', ...names]\n  }\n\n  getSelectedApp() {\n    // -1 for the â€œselect an appâ€ entry\n    return this.getNamedApps()[this.state.appIndex - 1]\n  }\n\n  canSubmit() {\n    const { assignEntityAddress, roleIndex } = this.state\n\n    if (!isAddress(assignEntityAddress)) {\n      return false\n    }\n\n    if (isEmptyAddress(assignEntityAddress)) {\n      return false\n    }\n\n    // No role selected\n    if (roleIndex === 0) {\n      return false\n    }\n\n    return true\n  }\n\n  handleSubmit = event => {\n    event.preventDefault()\n\n    const { roleIndex, assignEntityAddress } = this.state\n    const { grantPermission, onClose } = this.props\n\n    if (!this.canSubmit()) {\n      return\n    }\n\n    const selectedApp = this.getSelectedApp()\n    // const rolesItems = this.getRolesItems()\n\n    const role = this.getRoles()[roleIndex - 1]\n    if (!role) {\n      return\n    }\n\n    grantPermission({\n      appAddress: selectedApp.proxyAddress,\n      entityAddress: assignEntityAddress,\n      roleBytes: role.bytes,\n    })\n\n    onClose()\n  }\n\n  handlePanelTransitionEnd = () => {\n    if (!this.props.opened) {\n      this.setState(DEFAULT_STATE)\n    }\n  }\n\n  handleEntityChange = ({ index, address }) => {\n    this.setState({\n      assignEntityIndex: index || -1,\n      assignEntityAddress: address,\n    })\n  }\n\n  render() {\n    const { opened, onClose, wrapper } = this.props\n    const { assignEntityIndex, appIndex, roleIndex } = this.state\n\n    const appsItems = this.getAppsItems()\n    const selectedApp = this.getSelectedApp()\n    const rolesItems = this.getRolesItems()\n\n    return (\n      <SidePanel\n        title={'Add permission'}\n        opened={opened}\n        onClose={onClose}\n        onTransitionEnd={this.handlePanelTransitionEnd}\n      >\n        <form\n          onSubmit={this.handleSubmit}\n          css={`\n            margin-top: ${3 * GU}px;\n          `}\n        >\n          <Field label=\"On app\">\n            <DropDown\n              placeholder=\"Select an app\"\n              items={appsItems}\n              selected={appIndex}\n              onChange={this.handleAppChange}\n              wide\n            />\n          </Field>\n\n          <EntitySelector\n            includeAnyEntity\n            apps={this.getNamedApps()}\n            label=\"Assign to entity\"\n            labelCustomAddress=\"Grant permission to\"\n            selectedIndex={assignEntityIndex}\n            onChange={this.handleEntityChange}\n            wrapper={wrapper}\n          />\n\n          {selectedApp && (\n            <Field label=\"Action\">\n              <DropDown\n                placeholder=\"Select an action\"\n                items={rolesItems}\n                selected={roleIndex}\n                onChange={this.handleRoleChange}\n                wide\n              />\n            </Field>\n          )}\n\n          <Button\n            type=\"submit\"\n            mode=\"strong\"\n            onClick={this.handleSubmit}\n            disabled={!this.canSubmit()}\n            wide\n          >\n            {'Add permission'}\n          </Button>\n\n          {this.state.assignEntityAddress === ANY_ENTITY && (\n            <Info\n              mode=\"warning\"\n              css={`\n                margin-top: ${3 * GU}px;\n              `}\n            >\n              Be aware that assigning the permission to this address will let\n              anyone perform this action.\n            </Info>\n          )}\n\n          <Info\n            title=\"Adding the permission might create a vote\"\n            css={`\n              margin-top: ${3 * GU}px;\n            `}\n          >\n            The Voting app will automatically create a new vote if granting the\n            permission requires a vote to pass.\n          </Info>\n        </form>\n      </SidePanel>\n    )\n  }\n}\n\nexport default props => (\n  <PermissionsConsumer>\n    {({ getAppRoles, grantPermission }) => (\n      <AssignPermissionPanel\n        getAppRoles={getAppRoles}\n        grantPermission={grantPermission}\n        {...props}\n      />\n    )}\n  </PermissionsConsumer>\n)\n","import React, { useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { Card, Tag, textStyle, unselectable, GU } from '@aragon/ui'\nimport { AppType } from '../../prop-types'\nimport { shortenAddress } from '../../util/web3'\nimport AppIcon from '../AppIcon/AppIcon'\n\nconst AppCard = React.memo(function AppCard({ onOpen, app }) {\n  const {\n    name,\n    identifier,\n    isAragonOsInternalApp,\n    hasWebApp,\n    proxyAddress,\n  } = app\n\n  const onClick = useCallback(() => {\n    onOpen(proxyAddress)\n  }, [onOpen, proxyAddress])\n\n  const instanceTitle = `Address: ${proxyAddress}`\n  const instanceLabel = isAragonOsInternalApp\n    ? 'System App'\n    : !hasWebApp\n    ? 'Background App'\n    : identifier || shortenAddress(proxyAddress)\n\n  return (\n    <Card\n      onClick={onClick}\n      css={`\n        position: relative;\n        overflow: hidden;\n        display: flex;\n        flex-direction: column;\n        justify-content: flex-start;\n        padding-top: ${3 * GU}px;\n        cursor: pointer;\n        ${unselectable};\n      `}\n    >\n      <div\n        css={`\n          margin-bottom: ${1 * GU}px;\n        `}\n      >\n        <AppIcon app={app} size={7 * GU} />\n      </div>\n      <p\n        css={`\n          display: flex;\n          justify-content: center;\n          max-width: 100%;\n          padding: 0 ${1 * GU}px ${1 * GU}px;\n          span {\n            display: block;\n            white-space: nowrap;\n            overflow: hidden;\n            text-overflow: ellipsis;\n          }\n          ${textStyle('body2')}\n        `}\n      >\n        <span>{name || 'Unknown'}</span>\n      </p>\n      <div\n        css={`\n          max-width: 100%;\n          padding: 0 ${2 * GU}px;\n        `}\n      >\n        <Tag mode=\"identifier\" label={instanceLabel} title={instanceTitle} />\n      </div>\n    </Card>\n  )\n})\n\nAppCard.propTypes = {\n  app: AppType.isRequired,\n  onOpen: PropTypes.func.isRequired,\n}\n\nexport default AppCard\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { CardLayout } from '@aragon/ui'\nimport { AppType } from '../../../prop-types'\nimport AppCard from '../../../components/AppCard/AppCard'\nimport EmptyBlock from '../EmptyBlock'\n\nfunction Apps({ apps, loading, onOpenApp }) {\n  if (loading) {\n    return <EmptyBlock>Loading appsâ€¦</EmptyBlock>\n  }\n\n  if (apps.length === 0) {\n    return <EmptyBlock>No apps installed.</EmptyBlock>\n  }\n\n  return (\n    <CardLayout rowHeight={170}>\n      {apps.map(app => (\n        <AppCard key={app.proxyAddress} app={app} onOpen={onOpenApp} />\n      ))}\n    </CardLayout>\n  )\n}\n\nApps.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  loading: PropTypes.bool.isRequired,\n  onOpenApp: PropTypes.func.isRequired,\n}\n\nexport default Apps\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Link, GU, textStyle, useTheme } from '@aragon/ui'\nimport noResultsPng from '../../assets/no-results.png'\n\nfunction EmptyFilteredPermissions({ onClear }) {\n  const theme = useTheme()\n\n  return (\n    <div\n      css={`\n        margin-top: ${4 * GU}px;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      `}\n    >\n      <img\n        css={`\n          margin: ${4 * GU}px 0;\n          height: 176px;\n        `}\n        src={noResultsPng}\n        alt=\"No results\"\n      />\n      <h3\n        css={`\n          font-size: 28px;\n          color: ${theme.content};\n        `}\n      >\n        No results found.\n      </h3>\n      <div\n        css={`\n          max-width: 270px;\n          text-align: center;\n          margin-top: ${1 * GU}px;\n          margin-bottom: ${4 * GU}px;\n          color: ${theme.surfaceContentSecondary};\n          ${textStyle('body2')}\n        `}\n      >\n        There are no permissions matching your search criteria.{' '}\n        <Link onClick={onClear}>Clear filters</Link>\n      </div>\n    </div>\n  )\n}\n\nEmptyFilteredPermissions.propTypes = {\n  onClear: PropTypes.func.isRequired,\n}\n\nexport default React.memo(EmptyFilteredPermissions)\n","import React, { useCallback, useEffect, useMemo, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  DropDown,\n  GU,\n  SearchInput,\n  textStyle,\n  useLayout,\n  useTheme,\n} from '@aragon/ui'\nimport debounce from 'lodash.debounce'\nimport EmptyBlock from '../EmptyBlock'\nimport EmptyFilteredPermission from '../EmptyFilteredPermissions'\nimport PermissionsView from '../PermissionsView'\n\nconst ENTITY_TYPES = ['All entities', 'Accounts', 'Apps']\n\nfunction AllPermissions({\n  loading,\n  onAssignPermission,\n  onManageRole,\n  permissions,\n}) {\n  const [selectedEntityType, setSelectedEntityType] = useState(-1)\n  const [searchTerms, setSearchTerms] = useState('')\n  const [page, setPage] = useState(0)\n  const { layoutName } = useLayout()\n\n  const permissionsKey = permissions\n    .map(permission => `${permission.app.proxyAddress}-${permission.role.id}`)\n    .join(',')\n\n  useEffect(() => {\n    setPage(0)\n  }, [permissionsKey])\n\n  const handleEntityTypeChange = useCallback(entity => {\n    setPage(0)\n    setSelectedEntityType(entity)\n  }, [])\n\n  const handlSearchTermsChange = useCallback(terms => {\n    setPage(0)\n    setSearchTerms(terms)\n  }, [])\n\n  const filteredPermissions = useMemo(() => {\n    return (\n      permissions\n\n        // Filter by search terms\n        .filter(permission => {\n          const preparedSearchTerms = searchTerms.trim().toLowerCase()\n          if (preparedSearchTerms === '') {\n            return true\n          }\n          const appName = permission.app.name.toLowerCase()\n          const roleName = permission.role.name.toLowerCase()\n          const roleId = permission.role.id.toLowerCase()\n          return (\n            appName.includes(preparedSearchTerms) ||\n            roleName.includes(preparedSearchTerms) ||\n            roleId.includes(preparedSearchTerms)\n          )\n        })\n\n        // Filter by account types\n        .filter(permission => {\n          // accounts\n          if (selectedEntityType === 1) {\n            return permission.entities.some(entity => entity.type !== 'app')\n          }\n\n          // apps\n          if (selectedEntityType === 2) {\n            return permission.entities.some(entity => entity.type === 'app')\n          }\n\n          return true\n        })\n    )\n  }, [searchTerms, permissions, selectedEntityType])\n\n  if (loading) {\n    return <EmptyBlock>Loading permissionsâ€¦</EmptyBlock>\n  }\n\n  if (permissions.length === 0) {\n    return <EmptyBlock>No permissions have been assigned yet.</EmptyBlock>\n  }\n\n  return (\n    <PermissionsView\n      permissions={filteredPermissions}\n      onAssignPermission={onAssignPermission}\n      onManageRole={onManageRole}\n      page={page}\n      onPageChange={setPage}\n      heading={\n        layoutName === 'large' && (\n          <Heading\n            emptyFilter={Boolean(\n              !filteredPermissions.length && permissions.length\n            )}\n            selectedEntityType={selectedEntityType}\n            onEntityTypeChange={handleEntityTypeChange}\n            searchTerms={searchTerms}\n            onSearchTermsChange={handlSearchTermsChange}\n          />\n        )\n      }\n      showApps\n    />\n  )\n}\n\nAllPermissions.propTypes = {\n  loading: PropTypes.bool.isRequired,\n  onAssignPermission: PropTypes.func.isRequired,\n  onManageRole: PropTypes.func.isRequired,\n  permissions: PropTypes.array.isRequired,\n}\n\nfunction Heading({\n  emptyFilter,\n  selectedEntityType,\n  onEntityTypeChange,\n  searchTerms,\n  onSearchTermsChange,\n}) {\n  const theme = useTheme()\n  const [searchTermsInputValue, setSearchTermsInputValue] = useState(\n    searchTerms\n  )\n\n  const debouncedSearchTermsUpdate = useCallback(\n    debounce(value => onSearchTermsChange(value), 300),\n    [onSearchTermsChange]\n  )\n\n  const handleEntityDropDownChange = useCallback(\n    index => {\n      onEntityTypeChange(index || -1)\n    },\n    [onEntityTypeChange]\n  )\n\n  const handleSearchInputChange = useCallback(\n    value => {\n      // immediately update the text field\n      setSearchTermsInputValue(value)\n      // but debounce the external update\n      debouncedSearchTermsUpdate(value)\n    },\n    [debouncedSearchTermsUpdate]\n  )\n\n  const handleOnClear = useCallback(() => {\n    onEntityTypeChange(-1)\n    onSearchTermsChange('')\n    setSearchTermsInputValue('')\n  }, [onEntityTypeChange, onSearchTermsChange])\n\n  return (\n    <React.Fragment>\n      <div\n        css={`\n          display: flex;\n          width: 100%;\n          justify-content: space-between;\n          align-items: center;\n        `}\n      >\n        <div\n          css={`\n            white-space: nowrap;\n            ${textStyle('body1')}\n          `}\n        >\n          All assigned permissions\n        </div>\n        <div>\n          <label\n            css={`\n              margin-right: ${2 * GU}px;\n              color: ${theme.surfaceContentSecondary};\n            `}\n          >\n            <DropDown\n              header=\"Entity\"\n              placeholder=\"Entity\"\n              items={ENTITY_TYPES}\n              selected={selectedEntityType}\n              onChange={handleEntityDropDownChange}\n              css={`\n                min-width: ${16 * GU}px;\n              `}\n            />\n          </label>\n          <SearchInput\n            css={`\n              width: ${38 * GU}px;\n            `}\n            onChange={handleSearchInputChange}\n            placeholder=\"Search by app or role\"\n            value={searchTermsInputValue}\n          />\n        </div>\n      </div>\n      {emptyFilter && <EmptyFilteredPermission onClear={handleOnClear} />}\n    </React.Fragment>\n  )\n}\n\nHeading.propTypes = {\n  emptyFilter: PropTypes.bool,\n  selectedEntityType: PropTypes.number.isRequired,\n  onEntityTypeChange: PropTypes.func.isRequired,\n  searchTerms: PropTypes.string.isRequired,\n  onSearchTermsChange: PropTypes.func.isRequired,\n}\n\nexport default AllPermissions\n","import React, { useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { Tabs } from '@aragon/ui'\nimport { AppType } from '../../../prop-types'\nimport { usePermissionsByRole } from '../../../contexts/PermissionsContext'\nimport Apps from './Apps'\nimport AllPermissions from './AllPermissions'\n\nfunction Home({\n  apps,\n  appsLoading,\n  onAssignPermission,\n  onChangeTab,\n  onManageRole,\n  onOpenApp,\n  permissionsLoading,\n  tabs,\n  selectedTab,\n}) {\n  const permissions = usePermissionsByRole()\n\n  const internalAppsOnly = selectedTab === 1\n\n  const appsFiltered = apps.filter(\n    app => Boolean(app.isAragonOsInternalApp) === internalAppsOnly\n  )\n\n  const permissionsFiltered = useMemo(\n    () =>\n      permissions.filter(\n        permission =>\n          permission.app &&\n          (permission.entities.length > 0 ||\n            permission.manager.type !== 'unassigned') &&\n          Boolean(permission.app.isAragonOsInternalApp) === internalAppsOnly\n      ),\n    [permissions, internalAppsOnly]\n  )\n\n  return (\n    <React.Fragment>\n      <Tabs items={tabs} selected={selectedTab} onChange={onChangeTab} />\n      <Apps apps={appsFiltered} loading={appsLoading} onOpenApp={onOpenApp} />\n      <AllPermissions\n        permissions={permissionsFiltered}\n        loading={appsLoading || permissionsLoading}\n        onAssignPermission={onAssignPermission}\n        onManageRole={onManageRole}\n      />\n    </React.Fragment>\n  )\n}\n\nHome.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  appsLoading: PropTypes.bool.isRequired,\n  permissionsLoading: PropTypes.bool.isRequired,\n  onAssignPermission: PropTypes.func.isRequired,\n  onManageRole: PropTypes.func.isRequired,\n  onOpenApp: PropTypes.func.isRequired,\n  onChangeTab: PropTypes.func.isRequired,\n  tabs: PropTypes.arrayOf(PropTypes.string).isRequired,\n  selectedTab: PropTypes.number.isRequired,\n}\n\nexport default Home\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\nimport {\n  Button,\n  DropDown,\n  Field,\n  Info,\n  SidePanel,\n  GU,\n  breakpoint,\n} from '@aragon/ui'\nimport { PermissionsConsumer } from '../../contexts/PermissionsContext'\nimport { ANY_ENTITY, isBurnEntity } from '../../permissions'\nimport { AppType, AragonType } from '../../prop-types'\nimport { isAddress, isEmptyAddress } from '../../util/web3'\nimport LocalLabelAppBadge from '../../components/LocalLabelAppBadge/LocalLabelAppBadge'\nimport EntitySelector from './EntitySelector'\nimport PermissionsIdentityBadge from './PermissionsIdentityBadge'\n\nconst CREATE_PERMISSION = Symbol('CREATE_PERMISSION')\nconst VIEW_PERMISSION = Symbol('VIEW_PERMISSION')\nconst NO_UPDATE_ACTION = Symbol('NO_UPDATE_ACTION')\nconst SET_PERMISSION_MANAGER = Symbol('SET_PERMISSION_MANAGER')\nconst REMOVE_PERMISSION_MANAGER = Symbol('REMOVE_PERMISSION_MANAGER')\n\nconst UPDATE_ACTIONS = new Map([\n  [NO_UPDATE_ACTION, { label: 'Select an update', message: null }],\n  [\n    SET_PERMISSION_MANAGER,\n    {\n      label: 'Change the manager',\n      message: `\n        The new manager will be the only entity allowed to grant or revoke\n        the permission, and make further changes to the manager.\n      `,\n    },\n  ],\n  [\n    REMOVE_PERMISSION_MANAGER,\n    {\n      label: 'Remove the manager',\n      message: `\n        After having removed its manager, the permission can only be granted or\n        revoked if it is initialized again (requiring the â€œCreate permissionâ€\n        action on the ACL app).\n      `,\n    },\n  ],\n])\n\nconst ACTIONS = new Map([\n  ...UPDATE_ACTIONS,\n  [\n    CREATE_PERMISSION,\n    {\n      label: null,\n      message: `\n        As part of the initialization process for a permission, a manager must\n        also be set. Be careful with this setting: the manager is the only\n        entity afterwards who can grant or revoke this permisison!\n      `,\n    },\n  ],\n  [\n    VIEW_PERMISSION,\n    {\n      label: null,\n      message: `\n        This permission's manager has been discarded to an unrecoverable address.\n        No further management actions can be taken on the permission, making it\n        effectively frozen.\n      `,\n    },\n  ],\n])\n\nconst DEFAULT_STATE = {\n  assignEntityIndex: -1,\n  assignEntityAddress: '',\n  updateAction: NO_UPDATE_ACTION,\n  assignManagerIndex: -1,\n  newRoleManagerValue: '',\n}\n\n// The role manager panel, wrapped in a PermissionsContext (see end of file)\nclass ManageRolePanel extends React.PureComponent {\n  static propTypes = {\n    app: AppType,\n    apps: PropTypes.arrayOf(AppType).isRequired,\n    createPermission: PropTypes.func.isRequired,\n    getRoleManager: PropTypes.func.isRequired,\n    onClose: PropTypes.func.isRequired,\n    opened: PropTypes.bool.isRequired,\n    removePermissionManager: PropTypes.func.isRequired,\n    role: PropTypes.object,\n    setPermissionManager: PropTypes.func.isRequired,\n    wrapper: AragonType,\n  }\n\n  state = {\n    ...DEFAULT_STATE,\n  }\n\n  handleUpdateActionChange = index => {\n    this.setState({\n      updateAction: this.getUpdateAction(index) || null,\n    })\n  }\n\n  getCurrentAction() {\n    const { updateAction } = this.state\n    const manager = this.getManager()\n    return isEmptyAddress(manager.address)\n      ? CREATE_PERMISSION\n      : isBurnEntity(manager.address)\n      ? VIEW_PERMISSION\n      : updateAction\n  }\n\n  getUpdateAction(index) {\n    return [...UPDATE_ACTIONS.keys()][index]\n  }\n\n  getUpdateActionIndex() {\n    const { updateAction } = this.state\n    return [...UPDATE_ACTIONS.keys()].indexOf(updateAction)\n  }\n\n  getUpdateActionsItems() {\n    return [...UPDATE_ACTIONS.values()].map(({ label }) => label)\n  }\n\n  getManager() {\n    const { getRoleManager, app, role } = this.props\n    return getRoleManager(app, role && role.bytes)\n  }\n\n  getNamedApps() {\n    const { apps } = this.props\n    return apps.filter(app => Boolean(app.name))\n  }\n\n  getMessage(action) {\n    const data = ACTIONS.get(action)\n    return (data && data.message) || ''\n  }\n\n  // Filter and validate the role manager value. Returns false if invalid.\n  filterNewRoleManager(value) {\n    const address = (value && value.trim()) || ''\n    return isAddress(address) ? address : false\n  }\n\n  canSubmit() {\n    const { newRoleManagerValue, assignEntityAddress } = this.state\n    const action = this.getCurrentAction()\n\n    if (action === REMOVE_PERMISSION_MANAGER) {\n      return true\n    }\n\n    if (action === SET_PERMISSION_MANAGER) {\n      return this.filterNewRoleManager(newRoleManagerValue) !== false\n    }\n\n    if (action === CREATE_PERMISSION) {\n      if (!isAddress(assignEntityAddress)) {\n        return false\n      }\n\n      if (isEmptyAddress(assignEntityAddress)) {\n        return false\n      }\n\n      return this.filterNewRoleManager(newRoleManagerValue) !== false\n    }\n\n    return false\n  }\n\n  handleSubmit = event => {\n    event.preventDefault()\n\n    const { newRoleManagerValue, assignEntityAddress } = this.state\n    const {\n      app,\n      onClose,\n      createPermission,\n      removePermissionManager,\n      setPermissionManager,\n      role,\n    } = this.props\n\n    const action = this.getCurrentAction()\n\n    if (!this.canSubmit()) {\n      return\n    }\n\n    if (action === REMOVE_PERMISSION_MANAGER) {\n      removePermissionManager({\n        appAddress: app.proxyAddress,\n        roleBytes: role.bytes,\n      })\n    }\n\n    if (action === SET_PERMISSION_MANAGER) {\n      setPermissionManager({\n        appAddress: app.proxyAddress,\n        entityAddress: this.filterNewRoleManager(newRoleManagerValue),\n        roleBytes: role.bytes,\n      })\n    }\n\n    if (action === CREATE_PERMISSION) {\n      createPermission({\n        appAddress: app.proxyAddress,\n        entityAddress: assignEntityAddress,\n        roleBytes: role.bytes,\n        manager: this.filterNewRoleManager(newRoleManagerValue),\n      })\n    }\n\n    onClose()\n  }\n\n  handlePanelTransitionEnd = () => {\n    if (!this.props.opened) {\n      this.setState(DEFAULT_STATE)\n    }\n  }\n\n  handleRoleManagerChange = ({ index, address }) => {\n    this.setState({\n      assignManagerIndex: index || -1,\n      newRoleManagerValue: address,\n    })\n  }\n\n  handleEntityChange = ({ index, address }) => {\n    this.setState({\n      assignEntityIndex: index || -1,\n      assignEntityAddress: address,\n    })\n  }\n\n  renderManager = () => {\n    const manager = this.getManager()\n    const emptyManager = isEmptyAddress(manager.address)\n    if (emptyManager) {\n      return 'No manager'\n    }\n    if (manager.type === 'app') {\n      return <LocalLabelAppBadge app={manager.app} apps={[]} noIdentifier />\n    }\n    return <PermissionsIdentityBadge entity={manager.address} />\n  }\n\n  render() {\n    const { opened, onClose, app, role, wrapper } = this.props\n    const { assignManagerIndex, assignEntityIndex } = this.state\n\n    const updateActionsItems = this.getUpdateActionsItems()\n    const updateActionIndex = this.getUpdateActionIndex()\n\n    const action = this.getCurrentAction()\n    const isUpdateAction = UPDATE_ACTIONS.has(action)\n    const message = this.getMessage(action)\n\n    return (\n      <SidePanel\n        title={\n          action === CREATE_PERMISSION\n            ? 'Initialize permission'\n            : action === VIEW_PERMISSION\n            ? 'View permission'\n            : 'Manage permission'\n        }\n        opened={opened}\n        onClose={onClose}\n        onTransitionEnd={this.handlePanelTransitionEnd}\n      >\n        <form\n          onSubmit={this.handleSubmit}\n          css={`\n            margin-top: ${3 * GU}px;\n          `}\n        >\n          <Field label=\"On app\">\n            {app && <LocalLabelAppBadge app={app} apps={[]} noIdentifier />}\n          </Field>\n\n          <Field label=\"Action\">\n            {(role && role.name) || 'Unnamed permission'}\n          </Field>\n\n          {(action === VIEW_PERMISSION || isUpdateAction) && (\n            <Field label=\"Managed by\">\n              <FlexRow>{this.renderManager()}</FlexRow>\n            </Field>\n          )}\n\n          {isUpdateAction && (\n            <Field label=\"Update\">\n              <DropDown\n                items={updateActionsItems}\n                selected={updateActionIndex}\n                onChange={this.handleUpdateActionChange}\n                wide\n              />\n            </Field>\n          )}\n\n          {action === SET_PERMISSION_MANAGER && (\n            <EntitySelector\n              label=\"New manager\"\n              labelCustomAddress=\"Address for new manager\"\n              selectedIndex={assignManagerIndex}\n              apps={this.getNamedApps()}\n              onChange={this.handleRoleManagerChange}\n              wrapper={wrapper}\n            />\n          )}\n\n          {action === CREATE_PERMISSION && (\n            <React.Fragment>\n              <EntitySelector\n                includeAnyEntity\n                label=\"Grant permission to\"\n                labelCustomAddress=\"Grant permission to\"\n                selectedIndex={assignEntityIndex}\n                apps={this.getNamedApps()}\n                onChange={this.handleEntityChange}\n                wrapper={wrapper}\n              />\n              <EntitySelector\n                label=\"Manager\"\n                labelCustomAddress=\"Address for manager\"\n                selectedIndex={assignManagerIndex}\n                apps={this.getNamedApps()}\n                onChange={this.handleRoleManagerChange}\n                wrapper={wrapper}\n              />\n            </React.Fragment>\n          )}\n\n          {(isUpdateAction || action === CREATE_PERMISSION) && (\n            <Button\n              mode=\"strong\"\n              onClick={this.handleSubmit}\n              disabled={!this.canSubmit()}\n              wide\n            >\n              {isUpdateAction ? 'Update permission' : 'Initialize permission'}\n            </Button>\n          )}\n\n          {(this.state.newRoleManagerValue === ANY_ENTITY ||\n            this.state.assignEntityAddress === ANY_ENTITY) && (\n            <Info\n              mode=\"warning\"\n              css={`\n                margin-top: ${3 * GU}px;\n              `}\n            >\n              Be aware that assigning the permission or manager role to this\n              address will let anyone perform this action or manage this\n              permission.\n            </Info>\n          )}\n\n          {message && (\n            <Info\n              title=\"Info\"\n              css={`\n                margin-top: ${3 * GU}px;\n              `}\n            >\n              {message}\n            </Info>\n          )}\n        </form>\n      </SidePanel>\n    )\n  }\n}\n\nconst FlexRow = styled.div`\n  display: inline-flex;\n  align-items: center;\n\n  ${breakpoint(\n    'medium',\n    `\n      display: flex;\n    `\n  )}\n`\n\nexport default props => (\n  <PermissionsConsumer>\n    {({\n      createPermission,\n      getRoleManager,\n      removePermissionManager,\n      setPermissionManager,\n    }) => (\n      <ManageRolePanel\n        {...props}\n        {...{\n          createPermission,\n          getRoleManager,\n          removePermissionManager,\n          setPermissionManager,\n        }}\n      />\n    )}\n  </PermissionsConsumer>\n)\n","import React, { useEffect, useCallback, useRef, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport { AppType, AragonType } from '../../prop-types'\nimport { Button, GU, Header, IconPlus, useLayout } from '@aragon/ui'\nimport { removeStartingSlash } from '../../util/utils'\nimport { addressesEqual, isAddress } from '../../util/web3'\nimport { usePermissions } from '../../contexts/PermissionsContext'\nimport LocalLabelAppBadge from '../../components/LocalLabelAppBadge/LocalLabelAppBadge'\nimport AppPermissions from './AppPermissions'\nimport AssignPermissionPanel from './AssignPermissionPanel'\nimport Home from './Home/Home'\nimport ManageRolePanel from './ManageRolePanel'\n\nconst HOME_TABS = ['App permissions', 'System permissions']\n\nfunction getAppByProxyAddress(proxyAddress, apps) {\n  if (!proxyAddress) {\n    return null\n  }\n  return apps.find(app => addressesEqual(app.proxyAddress, proxyAddress))\n}\n\nfunction getLocation(localPath, apps) {\n  const home = { screen: 'home' }\n\n  if (!localPath) {\n    return home\n  }\n\n  const [\n    screen,\n    data = null,\n    secondaryScreen = null,\n    secondaryData = null,\n  ] = removeStartingSlash(localPath).split('/')\n\n  if (screen === 'app' && isAddress(data)) {\n    return {\n      screen,\n      app: getAppByProxyAddress(data, apps),\n      secondaryScreen,\n      secondaryData,\n    }\n  }\n\n  if (screen === 'role') {\n    const appAddress = (data || '').slice(0, 42)\n    const roleBytes = (data || '').slice(42)\n    if (isAddress(appAddress)) {\n      return {\n        screen: 'home',\n        app: getAppByProxyAddress(appAddress, apps),\n        secondaryScreen: 'role',\n        secondaryData: roleBytes,\n      }\n    }\n  }\n\n  return home\n}\n\nfunction Permissions({\n  apps,\n  appsLoading,\n  onPathRequest,\n  localPath,\n  permissionsLoading,\n  wrapper,\n}) {\n  const { layoutName } = useLayout()\n  const [showAssignPermissionPanel, setShowAssignPermissionPanel] = useState(\n    false\n  )\n  const { resolveRole } = usePermissions()\n  const scrollTopElement = useRef(null)\n\n  const [homeTab, setHomeTab] = useState(0)\n\n  // `localPath` should change every time we navigate into and out of a detailed\n  // permissions view, so this ensures the user starts at the top of the screen\n  // on every navigation change.\n  useEffect(() => {\n    // The `false` is only here as a quick fix to prevent the top banner to\n    // disappear when present. It will get removed once the issue with the top\n    // banner is identified and fixed.\n    scrollTopElement.current.scrollIntoView(false)\n  }, [localPath])\n\n  const location = getLocation(localPath, apps)\n\n  const openHome = useCallback(() => {\n    onPathRequest('/')\n  }, [onPathRequest])\n\n  const openApp = useCallback(\n    proxyAddress => {\n      onPathRequest(`/app/${proxyAddress}`)\n    },\n    [onPathRequest]\n  )\n\n  const manageRole = useCallback(\n    (proxyAddress, roleBytes) => {\n      onPathRequest(\n        location.screen === 'app'\n          ? `/app/${proxyAddress}/role/${roleBytes}`\n          : `/role/${proxyAddress}${roleBytes}`\n      )\n    },\n    [onPathRequest, location]\n  )\n\n  const createPermission = useCallback(() => {\n    setShowAssignPermissionPanel(true)\n  }, [])\n\n  const closeAssignPermissionPanel = useCallback(() => {\n    setShowAssignPermissionPanel(false)\n  }, [])\n\n  const closeManageRolePanel = useCallback(() => {\n    const location = getLocation(localPath, apps)\n    const openedApp = location.screen === 'app' ? location.app : null\n    if (openedApp) {\n      openApp(openedApp.proxyAddress)\n    } else {\n      openHome()\n    }\n  }, [apps, localPath, openApp, openHome])\n\n  const managedRole =\n    location.app && location.secondaryScreen === 'role'\n      ? resolveRole(location.app.proxyAddress, location.secondaryData)\n      : null\n\n  return (\n    <React.Fragment>\n      <div\n        css={`\n          // This element is only used to reset\n          // the view scroll using scrollIntoView()\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 1px;\n          height: 1px;\n        `}\n        ref={scrollTopElement}\n      />\n\n      <Header\n        primary={\n          location.screen === 'app' && location.app ? (\n            <Header.Title>\n              <div\n                css={`\n                  display: flex;\n                  align-items: center;\n                `}\n              >\n                <div\n                  css={`\n                    overflow: hidden;\n                    text-overflow: ellipsis;\n                    margin-right: ${2 * GU}px;\n                  `}\n                >\n                  {`${location.app.name} permissions`}\n                </div>\n                <LocalLabelAppBadge app={location.app} apps={[]} noIdentifier />\n              </div>\n            </Header.Title>\n          ) : (\n            'Permissions'\n          )\n        }\n        secondary={\n          <Button\n            mode=\"strong\"\n            onClick={createPermission}\n            label=\"New permission\"\n            icon={<IconPlus />}\n            display={layoutName === 'small' ? 'icon' : 'label'}\n            disabled={appsLoading || permissionsLoading}\n          />\n        }\n      />\n\n      {location.screen === 'home' && (\n        <Home\n          apps={apps}\n          appsLoading={appsLoading}\n          onAssignPermission={createPermission}\n          onChangeTab={setHomeTab}\n          onManageRole={manageRole}\n          onOpenApp={openApp}\n          permissionsLoading={permissionsLoading}\n          selectedTab={homeTab}\n          tabs={HOME_TABS}\n        />\n      )}\n\n      {location.screen === 'app' && (\n        <AppPermissions\n          app={location.app}\n          loading={appsLoading}\n          onAssignPermission={createPermission}\n          onBack={openHome}\n          onManageRole={manageRole}\n        />\n      )}\n\n      <AssignPermissionPanel\n        apps={apps}\n        opened={showAssignPermissionPanel}\n        onClose={closeAssignPermissionPanel}\n        wrapper={wrapper}\n      />\n\n      <ManageRolePanel\n        app={location.app}\n        apps={apps}\n        opened={managedRole !== null}\n        onClose={closeManageRolePanel}\n        role={managedRole}\n        wrapper={wrapper}\n      />\n    </React.Fragment>\n  )\n}\n\nPermissions.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  appsLoading: PropTypes.bool.isRequired,\n  onPathRequest: PropTypes.func.isRequired,\n  localPath: PropTypes.string,\n  permissionsLoading: PropTypes.bool.isRequired,\n  wrapper: AragonType,\n}\n\nexport default Permissions\n","export { default as AppCenter } from './AppCenter/AppCenter'\nexport { default as Console } from './Console/Console'\nexport { default as Home } from './Home/Home'\nexport { default as Organization } from './Organization/Organization'\nexport { default as Permissions } from './Permissions/Permissions'\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { AppType } from '../../prop-types'\nimport { appIframeSandbox } from '../../security/configuration'\nimport { noop } from '../../util/utils'\n\nclass AppIFrame extends React.Component {\n  static propTypes = {\n    app: AppType.isRequired,\n    iframeRef: PropTypes.func,\n    onLoadingCancel: PropTypes.func,\n    onLoadingError: PropTypes.func,\n    onLoadingSuccess: PropTypes.func,\n    onLoadingStart: PropTypes.func,\n    onMessage: PropTypes.func,\n    onNavigate: PropTypes.func,\n  }\n  static defaultProps = {\n    iframeRef: noop,\n    onLoadingCancel: noop,\n    onLoadingError: noop,\n    onLoadingSuccess: noop,\n    onLoadingStart: noop,\n    onMessage: noop,\n    onNavigate: noop,\n  }\n  state = {\n    isLoading: false,\n  }\n  componentDidMount() {\n    window.addEventListener('message', this.handleReceiveMessage, false)\n    this.navigateIFrame(this.props.app.src)\n  }\n  componentWillReceiveProps(nextProps) {\n    const { app: nextApp } = nextProps\n    if (\n      nextApp.src !== this.props.app.src ||\n      // Also navigate when it's the same app, but a different instance\n      nextApp.proxyAddress !== this.props.app.proxyAddress\n    ) {\n      this.navigateIFrame(nextApp.src)\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener('message', this.handleReceiveMessage, false)\n    if (this.state.isLoading) {\n      this.props.onLoadingCancel()\n    }\n  }\n  loadingStart() {\n    if (this.state.isLoading) {\n      this.props.onLoadingCancel()\n    }\n    this.props.onLoadingStart()\n    this.setState({ isLoading: true })\n  }\n  isHidden = () => {\n    const { app } = this.props\n    return !app || !app.src\n  }\n  // To be called from outside\n  reloadIframe = () => {\n    this.loadingStart()\n  }\n  navigateIFrame = src => {\n    // Rather than load src=undefined, this component hides itself. That way,\n    // if the user later navigates back to the same src, we don't have to\n    // reload the iframe.\n    if (!src) return\n\n    // Cache src to avoid cases where the iframe would load the same page as\n    // before\n    this.src = src\n\n    // Detach the iframe from the DOM before setting the src to avoid adding\n    // history state\n    const containerNode = this.iframe.parentNode\n    this.iframe.remove()\n    this.iframe.src = src\n    containerNode.appendChild(this.iframe)\n\n    this.loadingStart()\n\n    this.props.onNavigate(this.props.app)\n  }\n  sendMessage = data => {\n    // Must use '*' for origin as we've sandboxed the iframe's origin\n    this.iframe.contentWindow.postMessage(data, '*')\n  }\n  handleOnLoad = event => {\n    this.setState({ isLoading: false })\n    this.props.onLoadingSuccess({ iframeElement: event.target })\n  }\n  handleReceiveMessage = event => {\n    const { onMessage } = this.props\n    if (\n      // Make sure the event actually came from the iframe window\n      // We can't use event.origin as it's always null due to the origin sandboxing\n      event.source === this.iframe.contentWindow\n    ) {\n      onMessage(event)\n    }\n  }\n  handleIFrameRef = iframe => {\n    const { iframeRef } = this.props\n    iframeRef(iframe)\n    this.iframe = iframe\n  }\n  render() {\n    const { ...props } = this.props\n    const show = !this.isHidden()\n\n    // Remove the props managed by AppIframe, so we can pass everything else to\n    // the <iframe> element.\n    Object.keys(AppIFrame.propTypes).forEach(name => {\n      delete props[name]\n    })\n\n    // Also remove the `src` prop as we manage the src ourselves to avoid\n    // adding duplicate history entries every time the src changes (see\n    // `navigateIFrame()`)\n    delete props.src\n\n    return (\n      <iframe\n        name=\"AppIFrame\"\n        allow=\"camera *; microphone *\"\n        frameBorder=\"0\"\n        onLoad={this.handleOnLoad}\n        ref={this.handleIFrameRef}\n        sandbox={appIframeSandbox}\n        css={`\n          display: ${show ? 'block' : 'none'};\n          height: 100%;\n          width: 100%;\n        `}\n        {...props}\n      />\n    )\n  }\n}\n\nexport default AppIFrame\n","import { useContext } from 'react'\nimport { AppWidthContext } from '../components/OrgView/OrgView'\n\nexport default function useAppWidth() {\n  return useContext(AppWidthContext)\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Layout, Root, ScrollView } from '@aragon/ui'\nimport useAppWidth from '../../apps/useAppWidth'\n\nconst RootProvider = Root.Provider\n\nfunction AppInternal({ children }) {\n  const appWidth = useAppWidth()\n  return (\n    <RootProvider css=\"height: 100%\">\n      <ScrollView>\n        <Layout parentWidth={appWidth}>{children}</Layout>\n      </ScrollView>\n    </RootProvider>\n  )\n}\n\nAppInternal.propTypes = {\n  children: PropTypes.node,\n}\n\nexport default AppInternal\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { keyframes } from 'styled-components'\nimport { useTheme } from '@aragon/ui'\n\nconst PATH = `\n  M75 19a161.38 161.38 0 0 0-7.37 2.68 214.8 214.8 0 0 0-14.98 6.5\n  C38.81 34.8 25.92 42.74 15 52\n  c.59 2.94 1.49 6.6 2.78 10.86\n  a136.54 136.54 0 0 0 8.39 21.24\n  c5.17 10.43 11.44 19.48 18.64 26.95\n  A80.72 80.72 0 0 0 75 131\n  a80.86 80.86 0 0 0 30.18-19.98\n  c7.18-7.44 13.46-16.53 18.65-27\n  a138.28 138.28 0 0 0 8.38-21.2\n  c1.29-4.24 2.2-7.9 2.79-10.82-10.92-9.25-23.81-17.18-37.67-23.82\n  a215.66 215.66 0 0 0-14.99-6.5\n  A161.55 161.55 0 0 0 75 19z\n`\n\nconst STROKE_WIDTH = 3\nconst LOOP_DURATION = 1800\nconst DONE_TRANSITION_DURATION = 400\nconst DASH_ARRAY = 348.5 // circumference, found by manually incrementing it :o\nconst GRADIENT_COLOR_START = '#2CF4E1'\nconst GRADIENT_COLOR_STOP = '#2CB2E1'\nconst ANIM_FUNCTION = 'cubic-bezier(0.7, 0, 0.3, 1)'\nconst GRADIENT_ID = 'loading-screen-logo-gradient'\n\nconst animGradient = keyframes`\n  0% { stroke-dashoffset: ${DASH_ARRAY} }\n  60%, 100% { stroke-dashoffset: 0 }\n`\n\nconst animMask = keyframes`\n  0%, 10% { stroke-dashoffset: ${DASH_ARRAY} }\n  90%, 100% { stroke-dashoffset: 0 }\n`\n\nconst AnimatedLogo = React.memo(function AnimatedLogo({ done }) {\n  return (\n    <svg width={150} height={150} fill=\"none\">\n      <Outline />\n      <Outline\n        gradient\n        css={`\n          stroke-dasharray: ${DASH_ARRAY};\n          stroke-dashoffset: ${DASH_ARRAY};\n          animation: ${LOOP_DURATION}ms ${ANIM_FUNCTION} infinite\n            ${animGradient};\n        `}\n        style={{\n          animationPlayState: done ? 'paused' : 'running',\n        }}\n      />\n      <Outline\n        css={`\n          stroke-dasharray: ${DASH_ARRAY};\n          stroke-dashoffset: ${DASH_ARRAY};\n          animation: ${LOOP_DURATION}ms ${ANIM_FUNCTION} infinite ${animMask};\n        `}\n        style={{\n          animationPlayState: done ? 'paused' : 'running',\n        }}\n      />\n      <Outline\n        gradient\n        css={`\n          transition: opacity ${DONE_TRANSITION_DURATION}ms ease-out;\n        `}\n        style={{ opacity: Number(done) }}\n      />\n      <defs>\n        <linearGradient\n          id={GRADIENT_ID}\n          x1={6.898}\n          y1={75.052}\n          x2={143.077}\n          y2={75.052}\n          gradientUnits=\"userSpaceOnUse\"\n        >\n          <stop offset={0} stopColor={GRADIENT_COLOR_START} />\n          <stop offset={1} stopColor={GRADIENT_COLOR_STOP} />\n        </linearGradient>\n      </defs>\n    </svg>\n  )\n})\n\nAnimatedLogo.propTypes = {\n  done: PropTypes.bool,\n}\n\nAnimatedLogo.defaultProps = {\n  done: false,\n}\n\nconst Outline = ({ gradient = false, ...props }) => {\n  const theme = useTheme()\n  return (\n    <path\n      d={PATH}\n      stroke={gradient ? `url(#${GRADIENT_ID})` : theme.border}\n      strokeWidth={STROKE_WIDTH}\n      {...props}\n    />\n  )\n}\nOutline.propTypes = {\n  gradient: PropTypes.bool,\n}\n\nexport default AnimatedLogo\n","import React, { useEffect, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport { springs, useTheme } from '@aragon/ui'\nimport { Transition, animated } from 'react-spring'\nimport AnimatedLogo from './AnimatedLogo'\n\nconst HIDE_DELAY = 500\n\nconst LoadingScreen = React.memo(function LoadingScreen({\n  title,\n  progress,\n  ...props\n}) {\n  const [visible, setVisible] = useState(true)\n  const theme = useTheme()\n\n  // Update `visible` based on the current progress\n  useEffect(() => {\n    let timer = null\n    if (progress === 1 && visible) {\n      timer = setTimeout(() => setVisible(false), HIDE_DELAY)\n    } else if (progress !== 1 && !visible) {\n      setVisible(true)\n    }\n    return () => clearTimeout(timer)\n  }, [progress, visible])\n\n  return (\n    <Transition\n      items={visible}\n      initial={{ opacity: 1 }}\n      from={{ opacity: 0 }}\n      enter={{ opacity: 1 }}\n      leave={{ opacity: 0 }}\n      config={springs.instant}\n      native\n    >\n      {visible =>\n        visible &&\n        /* eslint-disable react/prop-types */\n        (({ opacity }) => (\n          <animated.div\n            style={{\n              position: 'absolute',\n              width: '100%',\n              height: '100%',\n              opacity,\n            }}\n            {...props}\n          >\n            <div\n              aria-busy=\"true\"\n              aria-live=\"polite\"\n              css={`\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                flex-direction: column;\n                width: 100%;\n                height: 100%;\n                background: ${theme.background};\n              `}\n            >\n              <AnimatedLogo done={progress === 1} />\n              <div\n                css={`\n                  font-size: 18px;\n                `}\n              >\n                {title}\n              </div>\n            </div>\n          </animated.div>\n        ))\n      /* eslint-enable react/prop-types */\n      }\n    </Transition>\n  )\n})\n\nLoadingScreen.propTypes = {\n  progress: PropTypes.number,\n  title: PropTypes.string,\n}\n\nLoadingScreen.defaultProps = {\n  progress: -1,\n  title: 'Loadingâ€¦',\n}\n\nexport default LoadingScreen\n","import React, { useState, useEffect } from 'react'\nimport PropTypes from 'prop-types'\nimport { isStaticApp } from '../../static-apps'\nimport LoadingScreen from '../LoadingScreen/LoadingScreen'\n\nconst LOADING_ORG = 'Loading organizationâ€¦'\nconst LOADING_APPS = 'Loading appsâ€¦'\nconst LOADING_APP = 'Loading {APP}â€¦'\nconst LOADING_READY = 'Ready.'\n\n// Pick the loading steps depending on what is being loaded (permissions, internal\n// app, external app, â€¦). `steps` must contain the strings used to represent\n// the different steps, while `stepIndex` must return the index of the current\n// step, based on the passed values.\nconst LOADING_STEPS_INTERNAL = {\n  steps: [LOADING_ORG, LOADING_APPS, LOADING_READY],\n  stepIndex: ({ daoLoading, appsLoading }) =>\n    [daoLoading, appsLoading, true].findIndex(v => v),\n}\n\nconst LOADING_STEPS_ORGANIZATION = {\n  steps: [LOADING_ORG, LOADING_READY],\n  stepIndex: ({ daoLoading }) => [daoLoading, true].findIndex(v => v),\n}\n\nconst LOADING_STEPS_EXTERNAL = {\n  steps: [LOADING_ORG, LOADING_APPS, LOADING_APP, LOADING_READY],\n  stepIndex: ({ daoLoading, appsLoading, appLoading }) =>\n    [daoLoading, appsLoading, appLoading, true].findIndex(v => v),\n}\n\nfunction getLoadingSteps(instanceId) {\n  // Organization app\n  if (instanceId === 'organization') {\n    return LOADING_STEPS_ORGANIZATION\n  }\n  // Internal app\n  if (isStaticApp(instanceId)) {\n    return LOADING_STEPS_INTERNAL\n  }\n  // External app\n  return LOADING_STEPS_EXTERNAL\n}\n\nfunction useLoadingStatus({\n  appLoading,\n  appsLoading,\n  currentAppName,\n  daoLoading,\n  instanceId,\n}) {\n  const [{ label, progress }, setStatus] = useState({ label: '', progress: 0 })\n\n  const loadingSteps = getLoadingSteps(instanceId)\n\n  // Update the step index\n  useEffect(() => {\n    const stepIndex = loadingSteps.stepIndex({\n      daoLoading,\n      appsLoading,\n      appLoading,\n    })\n\n    const label = loadingSteps.steps[stepIndex].replace(\n      /\\{APP\\}/,\n      currentAppName || instanceId || 'App'\n    )\n    const progress = stepIndex / (loadingSteps.steps.length - 1)\n\n    setStatus({ label, progress })\n  }, [\n    appLoading,\n    appsLoading,\n    daoLoading,\n    loadingSteps,\n    currentAppName,\n    instanceId,\n  ])\n\n  return { label, progress }\n}\n\nconst AppLoader = React.memo(function AppLoader({\n  appLoading,\n  appsLoading,\n  children,\n  currentAppName,\n  daoLoading,\n  instanceId,\n}) {\n  const loadingStatus = useLoadingStatus({\n    appLoading,\n    appsLoading,\n    currentAppName,\n    daoLoading,\n    instanceId,\n  })\n\n  return (\n    <div\n      css={`\n        position: relative;\n        width: 100%;\n        height: 100%;\n      `}\n    >\n      <div\n        css={`\n          position: absolute;\n          width: 100%;\n          height: 100%;\n          z-index: 1;\n        `}\n        style={{ opacity: Number(loadingStatus.progress === 1) }}\n      >\n        {children}\n      </div>\n      <LoadingScreen\n        title={loadingStatus.label}\n        progress={loadingStatus.progress}\n        css=\"z-index: 2\"\n      />\n    </div>\n  )\n})\n\nAppLoader.propTypes = {\n  appLoading: PropTypes.bool.isRequired,\n  appsLoading: PropTypes.bool.isRequired,\n  children: PropTypes.node,\n  currentAppName: PropTypes.string.isRequired,\n  daoLoading: PropTypes.bool.isRequired,\n  instanceId: PropTypes.string,\n}\n\nexport default AppLoader\n","import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport PropTypes from 'prop-types'\n\nimport App404 from '../App404/App404'\nimport { AppCenter, Console, Home, Organization, Permissions } from '../../apps'\nimport AppIFrame from '../App/AppIFrame'\nimport AppInternal from '../App/AppInternal'\nimport AppLoader from '../App/AppLoader'\nimport { useIdentity } from '../IdentityManager/IdentityManager'\nimport { useRouting } from '../../routing'\n\nimport { addressesEqual } from '../../util/web3'\n\nimport {\n  AppInstanceGroupType,\n  AppsStatusType,\n  AppType,\n  AragonType,\n  DaoAddressType,\n  DaoStatusType,\n  RepoType,\n} from '../../prop-types'\nimport { DAO_STATUS_LOADING, APPS_STATUS_LOADING } from '../../symbols'\n\nfunction OrgViewApp({ apps, appsStatus, daoStatus, wrapper, ...props }) {\n  const routing = useRouting()\n  const [appLoading, setAppLoading] = useState(false)\n\n  const { instanceId } = routing.mode\n\n  const currentApp = useMemo(\n    () => apps.find(app => addressesEqual(app.proxyAddress, instanceId)),\n    [apps, instanceId]\n  )\n\n  return (\n    <AppLoader\n      appLoading={appLoading}\n      appsLoading={!wrapper || appsStatus === APPS_STATUS_LOADING}\n      currentAppName={currentApp ? currentApp.name : ''}\n      daoLoading={daoStatus === DAO_STATUS_LOADING}\n      instanceId={instanceId}\n    >\n      <App\n        apps={apps}\n        appsStatus={appsStatus}\n        daoStatus={daoStatus}\n        setAppLoading={setAppLoading}\n        wrapper={wrapper}\n        {...props}\n      />\n    </AppLoader>\n  )\n}\n\nfunction App({\n  appInstanceGroups,\n  apps,\n  appsStatus,\n  canUpgradeOrg,\n  daoAddress,\n  historyBack,\n  onOpenApp,\n  onShowOrgUpgradePanel,\n  onUpgradeModalOpen,\n  permissionsLoading,\n  repos,\n  setAppLoading,\n  wrapper,\n}) {\n  const { identityEvents$ } = useIdentity()\n  const routing = useRouting()\n  const appIFrameRef = useRef(null)\n  const identitySubscription = useRef(null)\n\n  const { instanceId, instancePath } = routing.mode\n\n  const appsLoading = appsStatus === APPS_STATUS_LOADING\n  const reposLoading = appsLoading || Boolean(apps.length && !repos.length)\n\n  const handleAppIFrameRef = useCallback(appIFrame => {\n    appIFrameRef.current = appIFrame\n  }, [])\n\n  const handleAppIFrameLoadingStart = () => setAppLoading(true)\n  const handleAppIFrameLoadingCancel = () => setAppLoading(false)\n  const handleAppIFrameLoadingError = () => setAppLoading(false)\n\n  const handleAppIFrameLoadingSuccess = useCallback(\n    async ({ iframeElement }) => {\n      if (!wrapper) {\n        console.error(\n          `Attempted to connect app (${instanceId}) before aragonAPI was ready`\n        )\n        return\n      }\n      if (!apps.find(app => addressesEqual(app.proxyAddress, instanceId))) {\n        console.error(\n          `The requested app (${instanceId}) could not be found in the installed apps`\n        )\n        return\n      }\n\n      await wrapper.connectAppIFrame(iframeElement, instanceId)\n\n      appIFrameRef.current.sendMessage({\n        from: 'wrapper',\n        name: 'ready',\n        value: true,\n      })\n      setAppLoading(false)\n    },\n    [apps, instanceId, setAppLoading, wrapper]\n  )\n\n  const handleAppMessage = useCallback(\n    ({ data: { name } }) => {\n      if (name === 'ready') {\n        wrapper.setAppPath(instanceId, instancePath)\n      }\n    },\n    [instanceId, instancePath, wrapper]\n  )\n\n  // Update the local path of the current instance\n  const handlePathRequest = useCallback(\n    instancePath => {\n      onOpenApp(instanceId, { instancePath })\n    },\n    [instanceId, onOpenApp]\n  )\n\n  useEffect(() => {\n    identitySubscription.current = identityEvents$.subscribe(event => {\n      if (appIFrameRef.current) {\n        appIFrameRef.current.reloadIframe()\n      }\n    })\n\n    if (wrapper && instanceId && instancePath) {\n      wrapper.setAppPath(instanceId, instancePath)\n    }\n\n    return () => {\n      identitySubscription.current.unsubscribe()\n    }\n  }, [identityEvents$, instanceId, instancePath, wrapper])\n\n  if (instanceId === 'home') {\n    return (\n      <AppInternal>\n        <Home apps={apps} onOpenApp={onOpenApp} />\n      </AppInternal>\n    )\n  }\n\n  if (instanceId === 'permissions') {\n    return (\n      <AppInternal>\n        <Permissions\n          apps={apps}\n          appsLoading={appsLoading}\n          permissionsLoading={permissionsLoading}\n          localPath={instancePath}\n          onMessage={handleAppMessage}\n          onPathRequest={handlePathRequest}\n          wrapper={wrapper}\n        />\n      </AppInternal>\n    )\n  }\n\n  if (instanceId === 'apps') {\n    return (\n      <AppInternal>\n        <AppCenter\n          appInstanceGroups={appInstanceGroups}\n          daoAddress={daoAddress}\n          repos={repos}\n          canUpgradeOrg={canUpgradeOrg}\n          reposLoading={reposLoading}\n          onMessage={handleAppMessage}\n          onUpgradeAll={onShowOrgUpgradePanel}\n          localPath={instancePath}\n          onPathRequest={handlePathRequest}\n          wrapper={wrapper}\n        />\n      </AppInternal>\n    )\n  }\n\n  if (instanceId === 'organization') {\n    return (\n      <AppInternal>\n        <Organization\n          apps={apps}\n          appsLoading={appsLoading}\n          canUpgradeOrg={canUpgradeOrg}\n          daoAddress={daoAddress}\n          onMessage={handleAppMessage}\n          onOpenApp={onOpenApp}\n          onShowOrgVersionDetails={onUpgradeModalOpen}\n        />\n      </AppInternal>\n    )\n  }\n\n  if (instanceId === 'console') {\n    return (\n      <AppInternal>\n        <Console apps={apps} wrapper={wrapper} />\n      </AppInternal>\n    )\n  }\n\n  // AppLoader will display a loading screen in that case\n  if (!wrapper || appsLoading) {\n    return null\n  }\n\n  const app = apps.find(app => addressesEqual(app.proxyAddress, instanceId))\n\n  return app ? (\n    <AppIFrame\n      ref={handleAppIFrameRef}\n      app={app}\n      onLoadingCancel={handleAppIFrameLoadingCancel}\n      onLoadingError={handleAppIFrameLoadingError}\n      onLoadingStart={handleAppIFrameLoadingStart}\n      onLoadingSuccess={handleAppIFrameLoadingSuccess}\n      onMessage={handleAppMessage}\n    />\n  ) : (\n    <App404 onNavigateBack={historyBack} />\n  )\n}\n\nOrgViewApp.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  appInstanceGroups: PropTypes.arrayOf(AppInstanceGroupType).isRequired,\n  appsStatus: AppsStatusType.isRequired,\n  canUpgradeOrg: PropTypes.bool,\n  daoAddress: DaoAddressType.isRequired,\n  daoStatus: DaoStatusType.isRequired,\n  historyBack: PropTypes.func.isRequired,\n  permissionsLoading: PropTypes.bool,\n  repos: PropTypes.arrayOf(RepoType).isRequired,\n  wrapper: AragonType,\n}\n\nApp.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  appInstanceGroups: PropTypes.arrayOf(AppInstanceGroupType).isRequired,\n  appsStatus: AppsStatusType.isRequired,\n  canUpgradeOrg: PropTypes.bool,\n  daoAddress: DaoAddressType.isRequired,\n  historyBack: PropTypes.func.isRequired,\n  onOpenApp: PropTypes.func.isRequired,\n  onShowOrgUpgradePanel: PropTypes.func.isRequired,\n  onUpgradeModalOpen: PropTypes.func.isRequired,\n  permissionsLoading: PropTypes.bool,\n  repos: PropTypes.arrayOf(RepoType).isRequired,\n  setAppLoading: PropTypes.func.isRequired,\n  wrapper: AragonType,\n}\n\nexport default OrgViewApp\n","import PropTypes from 'prop-types'\nimport { blockExplorerUrl } from 'use-wallet'\nimport { EthereumAddressType } from '../../prop-types'\nimport { useWallet } from '../../contexts/wallet'\nimport { getChainId } from '../../util/network'\n\n// Render props component that injects an appropriate Etherscan url if possible\nconst EtherscanLink = ({ address, children }) => {\n  const { networkType } = useWallet()\n  const etherscanUrl = blockExplorerUrl(\n    'address',\n    address,\n    getChainId(networkType)\n  )\n  return children(etherscanUrl)\n}\nEtherscanLink.propTypes = {\n  address: EthereumAddressType,\n  children: PropTypes.func.isRequired,\n}\n\nexport default EtherscanLink\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Link } from '@aragon/ui'\nimport { EthereumAddressType } from '../../prop-types'\nimport EtherscanLink from '../Etherscan/EtherscanLink'\n\nconst AddressLink = ({ children, to }) =>\n  to ? (\n    <EtherscanLink address={to}>\n      {url =>\n        url ? (\n          <Link href={url} focusRingSpacing={[3, 2]}>\n            {children || to}\n          </Link>\n        ) : (\n          to\n        )\n      }\n    </EtherscanLink>\n  ) : (\n    'an address or app'\n  )\nAddressLink.propTypes = {\n  children: PropTypes.node,\n  to: EthereumAddressType,\n}\n\nexport default AddressLink\n","import styled from 'styled-components'\nimport { Button, GU } from '@aragon/ui'\n\nconst SignerButton = styled(Button).attrs({\n  mode: 'strong',\n  wide: true,\n})`\n  margin-top: ${3 * GU}px;\n`\n\nexport default SignerButton\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Info, Link, RadioList, GU, textStyle } from '@aragon/ui'\nimport LocalIdentityBadge from '../IdentityBadge/LocalIdentityBadge'\nimport { getProviderString } from 'use-wallet'\nimport { useRouting } from '../../routing'\nimport AddressLink from './AddressLink'\nimport SignerButton from './SignerButton'\n\nconst RADIO_ITEM_TITLE_LENGTH = 30\n\nclass ActionPathsContent extends React.Component {\n  static propTypes = {\n    direct: PropTypes.bool.isRequired,\n    intent: PropTypes.object.isRequired,\n    routing: PropTypes.object.isRequired,\n    onSign: PropTypes.func.isRequired,\n    paths: PropTypes.array.isRequired,\n    pretransaction: PropTypes.object,\n    signingEnabled: PropTypes.bool,\n    walletProviderId: PropTypes.string.isRequired,\n  }\n  state = {\n    selected: 0,\n  }\n  handleChange = selected => {\n    this.setState({ selected })\n  }\n  handleSign = () => {\n    const { intent, direct, paths, pretransaction, onSign } = this.props\n    const { selected } = this.state\n    // In non-direct paths, the first transaction (0) is the one we need to sign\n    // to kick off the forwarding path\n    onSign(\n      direct ? intent.transaction : paths[selected][0],\n      intent,\n      pretransaction\n    )\n  }\n  renderDescription(\n    showPaths,\n    { description, name, to, annotatedDescription }\n  ) {\n    const { routing } = this.props\n    return (\n      <React.Fragment>\n        <p>This transaction will {showPaths ? 'eventually' : ''} perform</p>\n        <div\n          css={`\n            margin: ${0.5 * GU}px 0 ${0.5 * GU}px ${1 * GU}px;\n            line-height: 1.6;\n          `}\n        >\n          {annotatedDescription\n            ? annotatedDescription.map(({ type, value }, index) => {\n                if (type === 'address' || type === 'any-account') {\n                  return (\n                    <span\n                      key={index}\n                      css={`\n                        display: inline-flex;\n                        vertical-align: middle;\n                        margin-right: 4px;\n                        position: relative;\n                        top: -1px;\n                      `}\n                    >\n                      <LocalIdentityBadge\n                        entity={type === 'any-account' ? 'Any account' : value}\n                        labelStyle={`\n                          ${textStyle('body3')}\n                        `}\n                        compact\n                      />\n                    </span>\n                  )\n                }\n                if (type === 'app') {\n                  return (\n                    <Link\n                      key={index}\n                      href={`#${routing.path(({ mode }) => ({\n                        mode: {\n                          ...mode,\n                          name: 'org',\n                          instanceId: 'permissions',\n                          instancePath: `/app/${value.proxyAddress}`,\n                        },\n                      }))}`}\n                      focusRingSpacing={[3, 2]}\n                      css=\"margin-right: 2px\"\n                    >\n                      {value.name}\n                    </Link>\n                  )\n                }\n                if (type === 'role' || type === 'kernelNamespace') {\n                  return (\n                    <span\n                      key={index}\n                      css={`\n                        margin-right: 4px;\n                        font-style: italic;\n                      `}\n                    >\n                      â€œ{value.name}â€\n                    </span>\n                  )\n                }\n                if (type === 'apmPackage') {\n                  return (\n                    <span\n                      key={index}\n                      css={`\n                        display: inline-flex;\n                        vertical-align: middle;\n                        margin-right: 4px;\n                      `}\n                    >\n                      <LocalIdentityBadge\n                        entity={value.name}\n                        labelStyle={`\n                          ${textStyle('body3')}\n                        `}\n                      />\n                    </span>\n                  )\n                }\n                return (\n                  <span key={index} css=\"margin-right: 4px\">\n                    {value}\n                  </span>\n                )\n              })\n            : description || 'an action'}\n        </div>\n        <p>\n          {' on '}\n          <AddressLink to={to}>{name}</AddressLink>.\n        </p>\n      </React.Fragment>\n    )\n  }\n  getPathRadioItem(path) {\n    // Slice off the intention (last transaction in the path)\n    path = path.slice(0, path.length - 1)\n\n    const titleElements = path.reduce((titleElements, { name }, index) => {\n      const shortName =\n        name.length > RADIO_ITEM_TITLE_LENGTH\n          ? name.slice(0, RADIO_ITEM_TITLE_LENGTH) + 'â€¦'\n          : name\n\n      if (titleElements.length) {\n        titleElements.push(' â†’ ')\n      }\n      titleElements.push(\n        <span key={index} title={name}>\n          {shortName}\n        </span>\n      )\n      return titleElements\n    }, [])\n    const title = <React.Fragment>{titleElements}</React.Fragment>\n\n    const descriptionElements =\n      path.length === 1\n        ? path[0].description\n        : path.map(({ name, description }, index) => (\n            <p key={index}>\n              {index + 1}. {name}: {description}\n            </p>\n          ))\n    const description = <React.Fragment>{descriptionElements}</React.Fragment>\n\n    return {\n      description,\n      title,\n    }\n  }\n  render() {\n    const {\n      direct,\n      intent,\n      paths,\n      pretransaction,\n      signingEnabled,\n      walletProviderId,\n    } = this.props\n    const { selected } = this.state\n    const showPaths = !direct\n    const radioItems = paths.map(this.getPathRadioItem)\n\n    const approveTransactionMessage =\n      intent.transaction &&\n      intent.transaction.token &&\n      intent.transaction.token.spender ? (\n        <React.Fragment>\n          The first will grant a token allowance to\n          <LocalIdentityBadge\n            entity={intent.transaction.token.spender}\n            labelStyle={`\n              ${textStyle('body3')}\n            `}\n            compact\n          />\n          {'. '}\n        </React.Fragment>\n      ) : null\n\n    return (\n      <React.Fragment>\n        {showPaths ? (\n          <div\n            css={`\n              margin-bottom: ${3 * GU}px;\n            `}\n          >\n            <Info mode=\"warning\" title=\"Permission note\">\n              You cannot directly perform this action. You do not have the\n              necessary permissions.\n            </Info>\n            <div\n              css={`\n                margin-top: ${4 * GU}px;\n              `}\n            >\n              <RadioList\n                title=\"Action Requirement\"\n                description={\n                  paths.length > 1\n                    ? 'Here are some options to perform this action:'\n                    : 'You can perform this action through:'\n                }\n                items={radioItems}\n                onChange={this.handleChange}\n                selected={selected}\n              />\n            </div>\n          </div>\n        ) : (\n          <h2\n            css={`\n              margin-bottom: ${2 * GU}px;\n            `}\n          >\n            You can directly perform this action:\n          </h2>\n        )}\n        <Info mode=\"description\" title=\"Action to be triggered\">\n          {this.renderDescription(showPaths, intent)}\n        </Info>\n        {intent.external && (\n          <div\n            css={`\n              margin-top: ${3 * GU}px;\n            `}\n          >\n            <Info mode=\"warning\" title=\"Warning\">\n              {intent.installed ? (\n                `Be aware that this is an attempt to execute a transaction on\n                 another app that is installed in this organization. You may\n                 want to double check that appâ€™s functionality before\n                 proceeding.`\n              ) : (\n                <span>\n                  Be aware that this is an attempt to execute a transaction on\n                  an <strong css=\"font-weight: 800\">external contract</strong>{' '}\n                  that may not have been reviewed or audited. This means that it\n                  might behave unexpectedly. Please{' '}\n                  <strong css=\"font-weight: 800\">\n                    make sure you trust the contract at\n                  </strong>{' '}\n                  <LocalIdentityBadge\n                    entity={intent.to}\n                    labelStyle={`\n                      ${textStyle('body3')}\n                    `}\n                    compact\n                  />{' '}\n                  before proceeding.\n                </span>\n              )}\n            </Info>\n          </div>\n        )}\n        {pretransaction && (\n          <Info\n            title=\"Two transactions required\"\n            mode=\"warning\"\n            css={`\n              margin-top: ${3 * GU}px;\n            `}\n          >\n            <p>\n              This action requires two transactions to be signed in{' '}\n              {getProviderString('your wallet', walletProviderId)}.{' '}\n              {approveTransactionMessage}\n              Please confirm them one after another.\n            </p>\n            <p\n              css={`\n                margin-top: ${1 * GU}px;\n              `}\n            >\n              In some situations,{' '}\n              {getProviderString('your wallet', walletProviderId)} may warn you\n              that the second transaction will fail.{' '}\n              <strong css=\"font-weight: 800\">Please ignore this warning</strong>\n              .\n            </p>\n          </Info>\n        )}\n        <SignerButton onClick={this.handleSign} disabled={!signingEnabled}>\n          Create transaction\n        </SignerButton>\n      </React.Fragment>\n    )\n  }\n}\n\nexport default props => {\n  const routing = useRouting()\n  return <ActionPathsContent routing={routing} {...props} />\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Info } from '@aragon/ui'\nimport AddressLink from './AddressLink'\nimport SignerButton from './SignerButton'\n\nconst ImpossibleAction = ({\n  error,\n  intent: { description, name, to },\n  onClose,\n}) => (\n  <React.Fragment>\n    <Info mode=\"warning\" title=\"Action impossible\">\n      The action {description && `â€œ${description}â€`} failed to execute\n      {name && (\n        <React.Fragment>\n          {' '}\n          on <AddressLink to={to}>{name}</AddressLink>\n        </React.Fragment>\n      )}\n      .{' '}\n      {error\n        ? 'An error occurred when we tried to find a path or send a transaction for this action.'\n        : 'You may not have the required permissions.'}\n    </Info>\n    <SignerButton onClick={onClose}>Close</SignerButton>\n  </React.Fragment>\n)\n\nImpossibleAction.propTypes = {\n  error: PropTypes.bool,\n  intent: PropTypes.object.isRequired,\n  onClose: PropTypes.func.isRequired,\n}\n\nexport default ImpossibleAction\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport ActionPathsContent from './ActionPathsContent'\nimport ImpossibleAction from './ImpossibleAction'\n\nfunction ConfirmTransaction({\n  direct,\n  intent,\n  onClose,\n  onSign,\n  paths,\n  pretransaction,\n  signError,\n  signingEnabled,\n  walletProviderId,\n}) {\n  const possible =\n    (direct || (Array.isArray(paths) && paths.length)) && !signError\n\n  return possible ? (\n    <ActionPathsContent\n      direct={direct}\n      intent={intent}\n      onSign={onSign}\n      paths={paths}\n      pretransaction={pretransaction}\n      signingEnabled={signingEnabled}\n      walletProviderId={walletProviderId}\n    />\n  ) : (\n    <ImpossibleAction error={signError} intent={intent} onClose={onClose} />\n  )\n}\n\nConfirmTransaction.propTypes = {\n  direct: PropTypes.bool.isRequired,\n  intent: PropTypes.object.isRequired,\n  onClose: PropTypes.func.isRequired,\n  onSign: PropTypes.func.isRequired,\n  paths: PropTypes.array.isRequired,\n  pretransaction: PropTypes.object,\n  signError: PropTypes.bool,\n  signingEnabled: PropTypes.bool,\n  walletProviderId: PropTypes.string.isRequired,\n}\n\nexport default ConfirmTransaction\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\nimport { IconDown, GU, springs, textStyle, useTheme } from '@aragon/ui'\nimport { Transition, animated } from 'react-spring'\n\nexport default class ToggleContent extends React.Component {\n  static propTypes = {\n    labelOpen: PropTypes.string.isRequired,\n    labelClosed: PropTypes.string.isRequired,\n    children: PropTypes.node.isRequired,\n  }\n\n  state = { opened: false }\n  handleClick = () => {\n    this.setState(({ opened }) => ({\n      opened: !opened,\n    }))\n  }\n  render() {\n    const { opened } = this.state\n    const { labelOpen, labelClosed, children } = this.props\n    return (\n      <div>\n        <Label onClick={this.handleClick}>\n          {opened ? labelOpen : labelClosed}{' '}\n          <div\n            css={`\n              display: flex;\n              align-items: center;\n              padding: 0 ${1 * GU}px;\n              transition: transform 150ms ease-in-out;\n              transform: rotate3d(0, 0, 1, ${opened ? 180 : 0}deg);\n            `}\n          >\n            <IconDown size=\"tiny\" />\n          </div>\n        </Label>\n\n        <Transition\n          items={opened}\n          config={springs.swift}\n          from={{ height: 0, opacity: 0 }}\n          enter={{ height: 'auto', opacity: 1 }}\n          leave={{ height: 0, opacity: 0 }}\n          native\n        >\n          {show =>\n            show && (props => <Content style={props}>{children}</Content>)\n          }\n        </Transition>\n      </div>\n    )\n  }\n}\n\nfunction Label(props) {\n  const theme = useTheme()\n  return (\n    <button\n      type=\"button\"\n      css={`\n        cursor: pointer;\n        background: none;\n        border: 0;\n        outline: 0;\n        padding: 0;\n        display: flex;\n        align-items: center;\n        ${textStyle('label2')}\n        color: ${theme.surfaceContentSecondary};\n        margin-bottom: ${2 * GU}px;\n      `}\n      {...props}\n    />\n  )\n}\n\nconst Content = styled(animated.div)`\n  max-height: 360px;\n  overflow: hidden;\n  overflow-y: scroll;\n`\n","import React, { useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { Info, GU, textStyle, useTheme } from '@aragon/ui'\nimport SignerButton from './SignerButton'\nimport ToggleContent from './ToggleContent'\nimport LocalIdentityBadge from '../IdentityBadge/LocalIdentityBadge'\nimport AppInstanceLabel from '../AppInstanceLabel'\nimport { AppType, EthereumAddressType } from '../../prop-types'\nimport { isHumanReadable } from '../../util/utils'\n\nconst SignMsgContent = ({ apps, account, intent, onSign, signingEnabled }) => {\n  const { message, requestingApp: requestingAppAddress } = intent\n\n  const requestingApp = useMemo(\n    () =>\n      apps.find(({ proxyAddress }) => proxyAddress === requestingAppAddress),\n    [apps, requestingAppAddress]\n  )\n  const humanReadableMessage = isHumanReadable(message)\n\n  return (\n    <React.Fragment>\n      <p\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        You are about to sign this message with the connected account{' '}\n        <LocalIdentityBadge entity={account} compact />.\n      </p>\n      <Label>Signature requested by</Label>\n      <div\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        <AppInstanceLabel\n          app={requestingApp}\n          proxyAddress={requestingAppAddress}\n          showIcon\n        />\n      </div>\n      {humanReadableMessage ? (\n        <React.Fragment>\n          <Label>Message</Label>\n          <Info mode=\"description\">{message}</Info>\n        </React.Fragment>\n      ) : (\n        <ToggleContent labelOpen=\"Hide message\" labelClosed=\"Show message\">\n          <Info mode=\"description\">{message}</Info>\n        </ToggleContent>\n      )}\n      <SignerButton onClick={onSign} disabled={!signingEnabled}>\n        Sign message\n      </SignerButton>\n    </React.Fragment>\n  )\n}\n\nSignMsgContent.propTypes = {\n  account: EthereumAddressType.isRequired,\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  intent: PropTypes.object.isRequired,\n  onSign: PropTypes.func.isRequired,\n  signingEnabled: PropTypes.bool,\n}\n\nfunction Label(props) {\n  const theme = useTheme()\n  return (\n    <div\n      css={`\n        ${textStyle('label2')}\n        color: ${theme.surfaceContentSecondary};\n        margin-bottom: ${2 * GU}px;\n      `}\n      {...props}\n    />\n  )\n}\n\nexport default SignMsgContent\n","import React, { Fragment } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { AppType, EthereumAddressType } from '../../prop-types'\nimport SignMsgContent from './SignMsgContent'\n\nconst ConfirmMsgSign = ({\n  account,\n  apps,\n  intent,\n  onClose,\n  onSign,\n  signingEnabled,\n}) => (\n  <Fragment>\n    <SignMsgContent\n      account={account}\n      apps={apps}\n      intent={intent}\n      onSign={onSign}\n      signingEnabled={signingEnabled}\n    />\n  </Fragment>\n)\n\nConfirmMsgSign.propTypes = {\n  account: EthereumAddressType.isRequired,\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  intent: PropTypes.object.isRequired,\n  onClose: PropTypes.func.isRequired,\n  onSign: PropTypes.func.isRequired,\n  signingEnabled: PropTypes.bool,\n}\n\nexport default ConfirmMsgSign\n","import PropTypes from 'prop-types'\n\n// The user need to confirm the transaction\nexport const STATUS_TX_CONFIRMING = Symbol('STATUS_TX_CONFIRMING')\n\n// The user need to sign the transaction in their wallet\nexport const STATUS_TX_SIGNING = Symbol('STATUS_TX_SIGNING')\n\n// The transaction has been successfully signed\nexport const STATUS_TX_SIGNED = Symbol('STATUS_TX_SIGNED')\n\n// An error happened while signing the transaction\nexport const STATUS_TX_ERROR = Symbol('STATUS_TX_ERROR')\n\n// The user need to confirm the message signature\nexport const STATUS_MSG_CONFIRMING = Symbol('STATUS_MSG_CONFIRMING')\n\n// The user need to sign the message in their wallet\nexport const STATUS_MSG_SIGNING = Symbol('STATUS_MSG_SIGNING')\n\n// The message has been successfully signed\nexport const STATUS_MSG_SIGNED = Symbol('STATUS_MSG_SIGNED')\n\n// An error happened while signing the message\nexport const STATUS_MSG_ERROR = Symbol('STATUS_MSG_ERROR')\n\n// Corresponding proptype\nexport const SignerStatusType = PropTypes.oneOf([\n  STATUS_TX_CONFIRMING,\n  STATUS_TX_SIGNING,\n  STATUS_TX_SIGNED,\n  STATUS_TX_ERROR,\n  STATUS_MSG_CONFIRMING,\n  STATUS_MSG_SIGNING,\n  STATUS_MSG_SIGNED,\n  STATUS_MSG_ERROR,\n])\n\nexport const isTxSignerStatus = status => {\n  const txStatuses = [\n    STATUS_TX_CONFIRMING,\n    STATUS_TX_SIGNING,\n    STATUS_TX_SIGNED,\n    STATUS_TX_ERROR,\n  ]\n  return txStatuses.indexOf(status) > -1\n}\n\nexport const isConfirmingSignature = status => {\n  const confirmingStatuses = [STATUS_TX_CONFIRMING, STATUS_MSG_CONFIRMING]\n  return confirmingStatuses.indexOf(status) > -1\n}\n\nexport const isSignatureSuccess = status => {\n  const successStatuses = [STATUS_TX_SIGNED, STATUS_MSG_SIGNED]\n  return successStatuses.indexOf(status) > -1\n}\n\nexport const isSignatureError = status => {\n  const signErrorStatuses = [STATUS_MSG_ERROR, STATUS_TX_ERROR]\n  return signErrorStatuses.indexOf(status) > -1\n}\n\n// includes success and error cases\nexport const isSignatureCompleted = status => {\n  return isSignatureSuccess(status) || isSignatureError(status)\n}\n\nexport const isSigning = status => {\n  const signatureProcessingStatuses = [STATUS_MSG_SIGNING, STATUS_TX_SIGNING]\n  return signatureProcessingStatuses.indexOf(status) > -1\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\nimport { Box, GU, Info, textStyle, useTheme } from '@aragon/ui'\nimport { getProviderString } from 'use-wallet'\nimport FeedbackIndicator from '../FeedbackIndicator/FeedbackIndicator'\nimport SignerButton from './SignerButton'\n\nimport {\n  STATUS_TX_ERROR,\n  STATUS_TX_SIGNED,\n  STATUS_TX_SIGNING,\n  SignerStatusType,\n  STATUS_MSG_SIGNING,\n  STATUS_MSG_SIGNED,\n  STATUS_MSG_ERROR,\n  isSignatureSuccess,\n  isSignatureError,\n  isSigning,\n  isSignatureCompleted,\n} from './signer-statuses'\n\n// Temporarily clean the error messages coming from Aragon.js and Metamask\nconst cleanErrorMessage = errorMsg =>\n  errorMsg\n    // Only use the first line if multiple lines are available.\n    // This makes sure we don't show the stack trace if it becomes part of the message.\n    .split('\\n')[0]\n    .replace(/^Returned error: /, '')\n    .replace(/^Error: /, '')\n\nclass SigningStatus extends React.Component {\n  static propTypes = {\n    onClose: PropTypes.func.isRequired,\n    status: SignerStatusType.isRequired,\n    signError: PropTypes.instanceOf(Error),\n    walletProviderId: PropTypes.string,\n    theme: PropTypes.object,\n  }\n  getLabel() {\n    const { status } = this.props\n    if (isSigning(status)) return 'Waiting for signatureâ€¦'\n    if (status === STATUS_TX_SIGNED) return 'Transaction signed!'\n    if (status === STATUS_MSG_SIGNED) return 'Message signed!'\n    if (status === STATUS_TX_ERROR) return 'Signing transaction failed!'\n    if (status === STATUS_MSG_ERROR) return 'Signing message failed!'\n  }\n  getInfo() {\n    const { status, walletProviderId } = this.props\n    if (status === STATUS_TX_SIGNING) {\n      return (\n        <p>\n          {`Open ${getProviderString(\n            'your wallet',\n            walletProviderId\n          )} to sign your transaction.`}\n        </p>\n      )\n    }\n    if (status === STATUS_MSG_SIGNING) {\n      return (\n        <p>{`Open ${getProviderString(\n          'your wallet',\n          walletProviderId\n        )} to sign your message.`}</p>\n      )\n    }\n    if (status === STATUS_TX_SIGNED) {\n      return (\n        <p>\n          Success! Your transaction has been sent to the network for processing.\n        </p>\n      )\n    }\n    if (status === STATUS_MSG_SIGNED) {\n      return <p>Success! Your message has been signed.</p>\n    }\n    if (status === STATUS_TX_ERROR) {\n      return this.getErrorMessage(\n        \"Your transaction wasn't signed and no tokens were sent.\"\n      )\n    }\n    if (status === STATUS_MSG_ERROR) {\n      return this.getErrorMessage(\"Your message wasn't signed.\")\n    }\n  }\n  getCloseButton() {\n    const { status, onClose } = this.props\n    if (isSignatureCompleted(status)) {\n      return <SignerButton onClick={onClose}>Close</SignerButton>\n    }\n    return null\n  }\n  getErrorMessage(warning) {\n    const { signError } = this.props\n    const cleanedErrorMessage = cleanErrorMessage(\n      (signError && signError.message) || ''\n    )\n    return (\n      <React.Fragment>\n        <p>{warning}</p>\n        {cleanedErrorMessage ? (\n          <p>Error: â€œ{cleanedErrorMessage}â€</p>\n        ) : (\n          <p>There may have been a problem with your wallet.</p>\n        )}\n      </React.Fragment>\n    )\n  }\n  render() {\n    const { theme, status } = this.props\n    return (\n      <div>\n        <Box\n          css={`\n            margin-bottom: ${3 * GU}px;\n          `}\n        >\n          <Status color={theme.surfaceContent}>\n            <FeedbackIndicator\n              status={\n                isSignatureSuccess(status)\n                  ? 'success'\n                  : isSignatureError(status)\n                  ? 'error'\n                  : 'pending'\n              }\n            />\n            <p\n              css={`\n                margin-top: ${2 * GU}px;\n                ${textStyle('body2')};\n              `}\n            >\n              {this.getLabel()}\n            </p>\n          </Status>\n        </Box>\n        <Info>{this.getInfo()}</Info>\n        {this.getCloseButton()}\n      </div>\n    )\n  }\n}\n\nconst Status = styled.div`\n  height: ${38 * GU}px;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  color: ${({ color }) => color};\n`\n\nexport default props => {\n  const theme = useTheme()\n  return <SigningStatus {...props} theme={theme} />\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Info, Link, GU } from '@aragon/ui'\n\nimport AddressLink from './AddressLink'\nimport SignerButton from './SignerButton'\nimport { getProviderString } from 'use-wallet'\nimport { isElectron } from '../../util/utils'\n\nfunction Web3ProviderError({\n  intent: { description, name, to },\n  onClose,\n  neededText,\n  actionText,\n}) {\n  return (\n    <React.Fragment>\n      <Info mode=\"description\" title=\"You canâ€™t perform any action\">\n        {neededText} in order to perform{' '}\n        {description ? `â€œ${description}â€` : 'this action'}\n        {name && (\n          <React.Fragment>\n            {' '}\n            on <AddressLink to={to}>{name}</AddressLink>\n          </React.Fragment>\n        )}\n        .\n        <p\n          css={`\n            margin-top: ${2 * GU}px;\n          `}\n        >\n          {actionText}\n        </p>\n      </Info>\n      <SignerButton onClick={onClose}>Close</SignerButton>\n    </React.Fragment>\n  )\n}\n\nWeb3ProviderError.propTypes = {\n  actionText: PropTypes.node.isRequired,\n  intent: PropTypes.object.isRequired,\n  neededText: PropTypes.string.isRequired,\n  onClose: PropTypes.func.isRequired,\n}\n\nexport function NoWeb3Provider({ intent, onClose }) {\n  const onElectron = isElectron()\n  const neededText = onElectron\n    ? 'You need to have Frame installed and enabled'\n    : 'You need to have a wallet installed and enabled'\n\n  const actionText = (\n    <span>\n      Please install and enable{' '}\n      <Link\n        href={onElectron ? 'https://frame.sh/' : 'https://metamask.io/'}\n        css=\"font-weight: 600\"\n      >\n        {onElectron ? 'Frame' : 'Metamask'}\n      </Link>\n      .\n    </span>\n  )\n\n  return (\n    <Web3ProviderError\n      intent={intent}\n      onClose={onClose}\n      neededText={neededText}\n      actionText={actionText}\n    />\n  )\n}\n\nNoWeb3Provider.propTypes = {\n  intent: PropTypes.object.isRequired,\n  onClose: PropTypes.func.isRequired,\n}\n\nexport function AccountLocked({ intent, onClose, walletProviderId }) {\n  const providerMessage = getProviderString('your wallet', walletProviderId)\n  return (\n    <Web3ProviderError\n      intent={intent}\n      onClose={onClose}\n      neededText={`You need to unlock and enable ${providerMessage}`}\n      actionText={<span>Please connect your account.</span>}\n    />\n  )\n}\n\nAccountLocked.propTypes = {\n  intent: PropTypes.object.isRequired,\n  onClose: PropTypes.func.isRequired,\n  walletProviderId: PropTypes.string.isRequired,\n}\n\nexport function WrongNetwork({\n  intent,\n  networkType,\n  onClose,\n  walletProviderId,\n}) {\n  return (\n    <Web3ProviderError\n      intent={intent}\n      onClose={onClose}\n      neededText={`\n      You need to be connected to the ${networkType} network\n    `}\n      actionText={`\n      Please connect ${getProviderString(\n        'your wallet',\n        walletProviderId\n      )} to the ${networkType} network.\n    `}\n    />\n  )\n}\n\nWrongNetwork.propTypes = {\n  intent: PropTypes.object.isRequired,\n  networkType: PropTypes.string.isRequired,\n  onClose: PropTypes.func.isRequired,\n  walletProviderId: PropTypes.string.isRequired,\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { useWallet } from '../../contexts/wallet'\nimport { NoWeb3Provider, AccountLocked } from './Web3Errors'\n\nfunction ValidateWalletWeb3({\n  children,\n  hasWeb3,\n  intent,\n  onClose,\n  walletProviderId,\n}) {\n  const wallet = useWallet()\n\n  if (!hasWeb3) {\n    return <NoWeb3Provider intent={intent} onClose={onClose} />\n  }\n\n  if (!wallet.connected) {\n    return (\n      <AccountLocked\n        intent={intent}\n        onClose={onClose}\n        walletProviderId={walletProviderId}\n      />\n    )\n  }\n\n  return children\n}\n\nValidateWalletWeb3.propTypes = {\n  children: PropTypes.node.isRequired,\n  hasWeb3: PropTypes.bool.isRequired,\n  intent: PropTypes.object.isRequired,\n  onClose: PropTypes.func.isRequired,\n  walletProviderId: PropTypes.string.isRequired,\n}\n\nexport default ValidateWalletWeb3\n","import React, { useContext } from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\nimport { SidePanel, GU, springs } from '@aragon/ui'\nimport { Transition, animated } from 'react-spring'\nimport { useWallet } from '../../contexts/wallet'\nimport { ActivityContext } from '../../contexts/ActivityContext'\nimport { AppType, EthereumAddressType } from '../../prop-types'\nimport { addressesEqual } from '../../util/web3'\nimport ConfirmTransaction from './ConfirmTransaction'\nimport ConfirmMsgSign from './ConfirmMsgSign'\nimport SigningStatus from './SigningStatus'\nimport ValidateWalletWeb3 from './ValidateWalletWeb3'\nimport {\n  STATUS_TX_CONFIRMING,\n  STATUS_TX_SIGNING,\n  STATUS_TX_SIGNED,\n  STATUS_TX_ERROR,\n  STATUS_MSG_CONFIRMING,\n  STATUS_MSG_SIGNING,\n  STATUS_MSG_SIGNED,\n  STATUS_MSG_ERROR,\n  isTxSignerStatus,\n  isConfirmingSignature,\n  isSignatureSuccess,\n} from './signer-statuses'\n\nconst INITIAL_STATE = {\n  actionPaths: [],\n  directPath: false,\n  intent: {},\n  panelOpened: false,\n  pretransaction: null,\n  signError: null,\n  status: STATUS_TX_CONFIRMING, // initially default to rendering the tx signing panel\n}\n\nconst RECIEPT_ERROR_STATUS = '0x0'\nconst WEB3_TX_OBJECT_KEYS = new Set([\n  'from',\n  'to',\n  'value',\n  'gas',\n  'gasPrice',\n  'data',\n  'nonce',\n])\n\nconst getAppName = (apps, proxyAddress) => {\n  const app = apps.find(app => addressesEqual(app.proxyAddress, proxyAddress))\n  return (app && app.name) || ''\n}\n\nconst getPretransactionDescription = intent =>\n  `Allow ${intent.name} to ${intent.description.slice(0, 1).toLowerCase() +\n    intent.description.slice(1)}`\n\n// Clean up a transaction object removing all non-standard transaction parameters\n// https://web3js.readthedocs.io/en/v1.2.0/web3-eth.html#sendtransaction\nconst sanitizeTxObject = tx =>\n  Object.keys(tx)\n    .filter(key => WEB3_TX_OBJECT_KEYS.has(key))\n    .reduce((newTx, key) => ({ ...newTx, [key]: tx[key] }), {})\n\nclass SignerPanel extends React.PureComponent {\n  static propTypes = {\n    apps: PropTypes.arrayOf(AppType).isRequired,\n    account: EthereumAddressType,\n    addTransactionActivity: PropTypes.func.isRequired,\n    setActivityConfirmed: PropTypes.func.isRequired,\n    setActivityFailed: PropTypes.func.isRequired,\n    setActivityNonce: PropTypes.func.isRequired,\n    transactionBag: PropTypes.object,\n    signatureBag: PropTypes.object,\n    walletWeb3: PropTypes.object,\n    web3: PropTypes.object.isRequired,\n    walletProviderId: PropTypes.string.isRequired,\n  }\n\n  state = { ...INITIAL_STATE }\n\n  componentDidUpdate(prevProps, prevState) {\n    const { status } = this.state\n    const { transactionBag, signatureBag } = this.props\n\n    // Received a new transaction to sign\n    if (transactionBag && transactionBag !== prevProps.transactionBag) {\n      this.transactionBagUpdate(transactionBag)\n    }\n\n    // Received a new message to sign\n    if (signatureBag && signatureBag !== prevProps.signatureBag) {\n      this.signatureBagUpdate(signatureBag)\n    }\n\n    if (prevState.status !== status && !isSignatureSuccess(status)) {\n      clearTimeout(this._closeTimer)\n    }\n  }\n\n  transactionBagUpdate(transactionBag) {\n    this.setState({\n      ...INITIAL_STATE,\n      panelOpened: true,\n      status: STATUS_TX_CONFIRMING,\n\n      // When Aragon.js starts returning the new format (see\n      // stateFromTransactionBag), we can simply search and replace this\n      // function with `transactionBag`.\n      ...this.stateFromTransactionBag(transactionBag),\n    })\n  }\n\n  signatureBagUpdate(signatureBag) {\n    this.setState({\n      ...INITIAL_STATE,\n      panelOpened: true,\n      status: STATUS_MSG_CONFIRMING,\n      ...this.stateFromMsgSigBag(signatureBag),\n    })\n  }\n\n  // This is a temporary method to reshape the transaction bag\n  // to the future format we expect from Aragon.js\n  stateFromTransactionBag(bag) {\n    const { path, transaction } = bag\n    const decoratedPaths = path.map(path => ({\n      ...path,\n      name: getAppName(this.props.apps, path.to),\n    }))\n\n    return {\n      intent: (transaction && this.transactionIntent(bag)) || {},\n      directPath: decoratedPaths.length === 1,\n      actionPaths: decoratedPaths.length ? [decoratedPaths] : [],\n      pretransaction: (transaction && transaction.pretransaction) || null,\n    }\n  }\n\n  stateFromMsgSigBag({ requestingApp, message }) {\n    const messageToSign = message || ''\n    return {\n      intent: {\n        description:\n          'You are about to sign this message with the connected account',\n        message: messageToSign,\n        requestingApp,\n      },\n    }\n  }\n\n  transactionIntent({ external, path, transaction = {} }) {\n    const { apps } = this.props\n\n    // If the path includes forwarders, the intent is always the last node\n    // Otherwise, it's the direct transaction\n    const targetIntent = path.length > 1 ? path[path.length - 1] : transaction\n    const { annotatedDescription, description, to } = targetIntent\n    const name = getAppName(apps, to)\n    const installed = apps.some(\n      ({ proxyAddress }) => proxyAddress === transaction.to\n    )\n\n    return {\n      annotatedDescription,\n      description,\n      external,\n      installed,\n      name,\n      to,\n      transaction,\n    }\n  }\n\n  signTransaction(transaction, intent, isPretransaction = false) {\n    const {\n      addTransactionActivity,\n      walletWeb3,\n      web3,\n      setActivityConfirmed,\n      setActivityFailed,\n      setActivityNonce,\n    } = this.props\n\n    return new Promise((resolve, reject) => {\n      walletWeb3.eth\n        .sendTransaction(sanitizeTxObject(transaction))\n        .on('transactionHash', transactionHash => {\n          resolve(transactionHash)\n          // Get account count/nonce for the transaction and update the activity item.\n          // May be useful in case there are multiple pending transactions to detect when\n          // a pending transaction with a lower nonce was manually re-sent by the user\n          // (most likely done through their Ethereum wallet directly with a different\n          // gas price or transaction data that results in a different transaction hash).\n\n          web3.eth\n            .getTransaction(transactionHash)\n            .then(({ nonce }) => setActivityNonce({ transactionHash, nonce }))\n            .catch(console.error)\n\n          // Pretransactions are for so the app can get approval\n          const description = isPretransaction\n            ? getPretransactionDescription(intent)\n            : intent.description\n\n          const hasForwarder = intent.to !== intent.transaction.to\n\n          // Create new activiy\n          addTransactionActivity({\n            transactionHash,\n            from: intent.transaction.from,\n            targetAppProxyAddress: intent.to,\n            forwarderProxyAddress: hasForwarder ? intent.transaction.to : '',\n            description,\n          })\n        })\n        .on('receipt', receipt => {\n          if (receipt.status === RECIEPT_ERROR_STATUS) {\n            // Faliure based on EIP 658\n            setActivityFailed(receipt.transactionHash)\n          } else {\n            setActivityConfirmed(receipt.transactionHash)\n          }\n        })\n        .on('error', err => {\n          // Called when signing failed\n          err && err.transactionHash && setActivityFailed(err.transactionHash)\n          reject(err)\n        })\n    })\n  }\n\n  handleSign = async (transaction, intent, pretransaction) => {\n    const { transactionBag } = this.props\n\n    this.setState({ status: STATUS_TX_SIGNING })\n\n    try {\n      if (pretransaction) {\n        await this.signTransaction(pretransaction, intent, true)\n      }\n\n      const transactionHash = await this.signTransaction(\n        transaction,\n        intent,\n        false\n      )\n\n      transactionBag.resolve(transactionHash)\n      this.setState({ signError: null, status: STATUS_TX_SIGNED })\n      this.startClosing()\n    } catch (err) {\n      transactionBag.reject(err)\n      // Display an error in the panel if the transaction failed\n      this.setState({ signError: err, status: STATUS_TX_ERROR })\n    }\n  }\n\n  handleMsgSign = async () => {\n    const { account, signatureBag, walletWeb3 } = this.props\n\n    this.setState({ status: STATUS_MSG_SIGNING })\n    try {\n      const signature = await walletWeb3.eth.personal.sign(\n        signatureBag.message,\n        account\n      )\n\n      signatureBag.resolve(signature)\n      this.setState({ signError: null, status: STATUS_MSG_SIGNED })\n      this.startClosing()\n    } catch (err) {\n      signatureBag.reject(err)\n      this.setState({\n        signError: err,\n        status: STATUS_MSG_ERROR,\n      })\n    }\n  }\n\n  startClosing = () => {\n    this._closeTimer = setTimeout(() => {\n      if (isSignatureSuccess(this.state.status)) {\n        this.handleSignerClose()\n      }\n    }, 3000)\n  }\n\n  handleSignerClose = () => {\n    const { transactionBag, signatureBag } = this.props\n    const { status } = this.state\n\n    // Panel was closed manually by user to cancel the signing, so we need to\n    // send feedback back to the apps\n    if (status === STATUS_TX_CONFIRMING) {\n      transactionBag.reject(new Error('User cancelled signing'))\n    } else if (status === STATUS_MSG_CONFIRMING) {\n      signatureBag.reject(new Error('User cancelled signing'))\n    }\n\n    this.setState({ panelOpened: false })\n  }\n\n  handleSignerTransitionEnd = opened => {\n    // Reset signer state only after it has finished transitioning out\n    if (!opened) {\n      this.setState({ ...INITIAL_STATE })\n    }\n  }\n\n  render() {\n    const { account, apps, walletProviderId, walletWeb3 } = this.props\n\n    const {\n      actionPaths,\n      directPath,\n      intent,\n      panelOpened,\n      pretransaction,\n      signError,\n      status,\n    } = this.state\n\n    const isTransaction = isTxSignerStatus(status)\n\n    return (\n      <SidePanel\n        onClose={this.handleSignerClose}\n        onTransitionEnd={this.handleSignerTransitionEnd}\n        opened={panelOpened}\n        title={isTransaction ? 'Create transaction' : 'Sign Message'}\n      >\n        <Main>\n          <Transition\n            items={isConfirmingSignature(status)}\n            from={{ enterProgress: 1 }}\n            enter={{ enterProgress: 0 }}\n            initial={{ enterProgress: 0 }}\n            leave={{ enterProgress: -1 }}\n            config={springs.lazy}\n            native\n          >\n            {confirming =>\n              confirming\n                ? ({ enterProgress }) => (\n                    <ScreenWrapper\n                      style={{\n                        transform: enterProgress.interpolate(\n                          v => `translate3d(${100 * v}%, 0, 0)`\n                        ),\n                      }}\n                    >\n                      <Screen>\n                        <ValidateWalletWeb3\n                          intent={intent}\n                          hasWeb3={Boolean(walletWeb3)}\n                          onClose={this.handleSignerClose}\n                          walletProviderId={walletProviderId}\n                        >\n                          {isTransaction ? (\n                            <ConfirmTransaction\n                              direct={directPath}\n                              intent={intent}\n                              onClose={this.handleSignerClose}\n                              onSign={this.handleSign}\n                              paths={actionPaths}\n                              pretransaction={pretransaction}\n                              signError={Boolean(signError)}\n                              signingEnabled={status === STATUS_TX_CONFIRMING}\n                              walletProviderId={walletProviderId}\n                            />\n                          ) : (\n                            <ConfirmMsgSign\n                              account={account}\n                              apps={apps}\n                              onClose={this.handleSignerClose}\n                              intent={intent}\n                              onSign={this.handleMsgSign}\n                              signingEnabled={status === STATUS_MSG_CONFIRMING}\n                            />\n                          )}\n                        </ValidateWalletWeb3>\n                      </Screen>\n                    </ScreenWrapper>\n                  )\n                : ({ enterProgress }) => (\n                    <ScreenWrapper\n                      style={{\n                        transform: enterProgress.interpolate(\n                          v => `translate3d(${100 * v}%, 0, 0)`\n                        ),\n                      }}\n                    >\n                      <Screen>\n                        <SigningStatus\n                          status={status}\n                          signError={signError}\n                          onClose={this.handleSignerClose}\n                          walletProviderId={walletProviderId}\n                        />\n                      </Screen>\n                    </ScreenWrapper>\n                  )\n            }\n          </Transition>\n        </Main>\n      </SidePanel>\n    )\n  }\n}\n\nconst Main = styled.div`\n  position: relative;\n  margin: 0 -${SidePanel.HORIZONTAL_PADDING}px;\n  overflow-x: hidden;\n  min-height: 0;\n  flex-grow: 1;\n`\n\nconst ScreenWrapper = styled(animated.div)`\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  padding: 0 ${SidePanel.HORIZONTAL_PADDING}px;\n  display: flex;\n  min-height: 100%;\n`\n\nconst Screen = styled.div`\n  width: 100%;\n  margin-top: ${3 * GU}px;\n`\n\nexport default function SignerPanelWrapper(props) {\n  const wallet = useWallet()\n\n  const {\n    addTransactionActivity,\n    setActivityConfirmed,\n    setActivityFailed,\n    setActivityNonce,\n  } = useContext(ActivityContext)\n\n  return (\n    <SignerPanel\n      {...props}\n      account={wallet.account}\n      addTransactionActivity={addTransactionActivity}\n      setActivityConfirmed={setActivityConfirmed}\n      setActivityFailed={setActivityFailed}\n      setActivityNonce={setActivityNonce}\n      walletProviderId={wallet.providerInfo.id}\n      walletWeb3={wallet.web3}\n    />\n  )\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { ButtonIcon, IconCross, GU } from '@aragon/ui'\n\nexport const BANNER_HEIGHT = 38\n\nfunction Banner({ text, textColor, button, color, height, compact, onClose }) {\n  return (\n    <div\n      color={color}\n      css={`\n        display: flex;\n        height: ${height}px;\n        background: ${({ color }) => color};\n        ${compact\n          ? `\n            flex-flow: column nowrap;\n            align-items: flex-start;\n            justify-content: flex-start;\n            padding: ${0.5 * GU}px ${2 * GU}px;\n          `\n          : `\n            flex-wrap: nowrap;\n            align-items: center;\n            justify-content: center;\n            padding: ${0.5 * GU}px ${1 * GU}px;\n        `};\n      `}\n    >\n      <div\n        css={`\n          white-space: nowrap;\n          color: ${textColor};\n        `}\n      >\n        {text}\n      </div>\n      <div\n        css={`\n          display: flex;\n          ${compact\n            ? `\n              justify-content: flex-start;\n            `\n            : `\n              justify-content: center;\n              margin-left: ${1 * GU}px;\n          `};\n        `}\n      >\n        {button}\n      </div>\n      {onClose && (\n        <ButtonIcon\n          label=\"Close\"\n          onClick={onClose}\n          css={`\n            position: absolute;\n            z-index: 2;\n            top: ${0.5 * GU}px;\n            right: ${2 * GU}px;\n            color: #f6f9fc;\n          `}\n        >\n          <IconCross />\n        </ButtonIcon>\n      )}\n    </div>\n  )\n}\n\nBanner.propTypes = {\n  button: PropTypes.node,\n  color: PropTypes.string,\n  text: PropTypes.node,\n  textColor: PropTypes.string,\n  height: PropTypes.number,\n  compact: PropTypes.bool,\n  onClose: PropTypes.func,\n}\n\nBanner.defaultProps = {\n  height: BANNER_HEIGHT,\n  compact: false,\n}\n\nexport default Banner\n","import large1 from './highlights/large/1.png'\nimport large2 from './highlights/large/2.png'\nimport large3 from './highlights/large/3.png'\nimport large4 from './highlights/large/4.png'\nimport large5 from './highlights/large/5.png'\nimport large6 from './highlights/large/6.png'\nimport large7 from './highlights/large/7.png'\n\nimport small1 from './highlights/small/1.png'\nimport small2 from './highlights/small/2.png'\nimport small3 from './highlights/small/3.png'\nimport small4 from './highlights/small/4.png'\nimport small5 from './highlights/small/5.png'\nimport small6 from './highlights/small/6.png'\nimport small7 from './highlights/small/7.png'\n\nexport const banner = {\n  text: {\n    large: 'Upgrade your organization to the 0.8 Camino release! ðŸŽ‰',\n    small: 'Upgrade to 0.8 Camino! ðŸŽ‰',\n  },\n  button: 'More info',\n}\n\nconst highlights = {}\nhighlights['latest'] = [\n  {\n    title: {\n      small: null,\n      large: 'Streamlined  setup flow',\n    },\n    description: {\n      small: null,\n      large: `\n        Featuring redesigned organization templates to\n        match your needs. Start a company, membership,\n        or reputation-based organization in just a few\n        clicks.\n      `,\n    },\n    visual: {\n      small: small1,\n      large: large1,\n      color: 'linear-gradient(135.76deg, #65AAFF 8.69%, #5D21D4 103.74%)',\n    },\n  },\n  {\n    title: {\n      small: null,\n      large: 'Enhanced voting transparency',\n    },\n    description: {\n      small: null,\n      large: `\n        The Voting app has been redesigned to make\n        governance more accessible. Easily find and\n        understand the details of a vote.\n      `,\n    },\n    visual: {\n      small: small2,\n      large: large2,\n      color: 'linear-gradient(141.36deg, #A8ED2F -9.7%, #68DFB1 93.28%)',\n    },\n  },\n  {\n    title: {\n      small: null,\n      large: 'Stay up to date with email notifications',\n    },\n    description: {\n      small: null,\n      large: `\n        Whether it's a new vote, financial transfer,\n        or permissions change, subscribe to the events\n        that matter to you.\n      `,\n    },\n    visual: {\n      small: small3,\n      large: large3,\n      color: 'linear-gradient(324.69deg, #FFF886 -112.1%, #FF4E78 91.91%)',\n    },\n  },\n  {\n    title: {\n      small: null,\n      large: 'Better financial visibility',\n    },\n    description: {\n      small: null,\n      large: `\n        View and sort your organizationâ€™s finances for\n        greater clarity and insight. Now with more\n        powerful filters.\n      `,\n    },\n    visual: {\n      small: small4,\n      large: large4,\n      color: 'linear-gradient(135.76deg, #65AAFF 8.69%, #5D21D4 103.74%)',\n    },\n  },\n  {\n    title: {\n      small: null,\n      large: 'Modern governance',\n    },\n    description: {\n      small: null,\n      large: `\n        Simplified permissions management that\n        makes it easier to understand who\n        has authority in your organization.\n      `,\n    },\n    visual: {\n      small: small5,\n      large: large5,\n      color: 'linear-gradient(131.84deg, #FF9372 -58.49%, #FFD770 100%)',\n    },\n  },\n  {\n    title: {\n      small: null,\n      large: 'One app, endless possibilities',\n    },\n    description: {\n      small: null,\n      large: `\n        Aragon Agent enables organizations to interact\n        directly with any Ethereum application. Access\n        Web3 like never before.\n      `,\n    },\n    visual: {\n      small: small6,\n      large: large6,\n      color: 'linear-gradient(126.55deg, #C4E5DF 6.11%, #D4EFE6 96.84%);',\n    },\n  },\n  {\n    title: {\n      small: null,\n      large: 'Organizations reimagined',\n    },\n    description: {\n      small: null,\n      large: `\n        A glimpse into the future of organizations that\n        you can use today.\n      `,\n    },\n    visual: {\n      small: small7,\n      large: large7,\n      color:\n        'linear-gradient(296.62deg, #95BBCE -14.74%, #C5D0E6 38.16%, #E7E4F6 99.41%)',\n    },\n    upgrade: {\n      small: 'Discover 0.8 Camino',\n      large: 'Discover 0.8 Camino',\n    },\n  },\n]\n\nhighlights['0.6'] = [...highlights['latest']]\nhighlights['0.6'][6] = {\n  title: {\n    small: null,\n    large: 'What else is new?',\n  },\n  description: {\n    small: null,\n    large: `\n      A mobile-friendly UI, custom labels for apps\n      and addresses, an activity panel that keeps you\n      informed about the status of pending\n      transactions, and much more!\n    `,\n  },\n  visual: {\n    small: small7,\n    large: large7,\n    color:\n      'linear-gradient(296.62deg, #95BBCE -14.74%, #C5D0E6 38.16%, #E7E4F6 99.41%)',\n  },\n  upgrade: {\n    small: 'Upgrade to 0.8 Camino',\n    large: 'Upgrade to 0.8 Camino',\n  },\n}\n\nexport { highlights }\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Transition, animated } from 'react-spring'\nimport { Button, springs, useViewport } from '@aragon/ui'\nimport Banner, { BANNER_HEIGHT } from '../Banner/Banner'\nimport { banner } from './content'\n\nconst UpgradeBanner = React.memo(({ visible, onMoreInfo }) => {\n  const { width } = useViewport()\n\n  return (\n    <React.Fragment>\n      <Transition\n        items={visible}\n        from={{ height: 0 }}\n        enter={{ height: BANNER_HEIGHT }}\n        leave={{ height: 0 }}\n        config={springs.smooth}\n        native\n      >\n        {visible =>\n          visible &&\n          /* eslint-disable react/prop-types */\n          (({ height }) => (\n            <animated.div style={{ overflow: 'hidden', height }}>\n              <Banner\n                text={width > 500 ? banner.text.large : banner.text.small}\n                button={\n                  <Button onClick={onMoreInfo} mode=\"normal\" size=\"mini\">\n                    More info\n                  </Button>\n                }\n                color=\"rgba(37, 49, 77, .75)\"\n                textColor=\"#FFFFFF\"\n              />\n            </animated.div>\n          ))\n        /* eslint-enable react/prop-types */\n        }\n      </Transition>\n    </React.Fragment>\n  )\n})\n\nUpgradeBanner.propTypes = {\n  onMoreInfo: PropTypes.func.isRequired,\n  visible: PropTypes.bool,\n}\n\nexport default UpgradeBanner\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { ButtonBase, IconRight, IconLeft, springs } from '@aragon/ui'\nimport { useSpring, animated } from 'react-spring/hooks'\n\nconst buttonTransitionStyles = show => ({\n  opacity: Number(show),\n  transform: `translate3d(0, ${show ? 0 : 2}px, 0)`,\n  config: springs.swift,\n  pointerEvents: show ? 'auto' : 'none',\n})\n\nfunction Navigation({ step, steps, onPrev, onNext }) {\n  const showPrev = step > 0\n  const showNext = step < steps - 1\n\n  const prevTransitionStyles = useSpring(buttonTransitionStyles(showPrev))\n  const nextTransitionStyles = useSpring(buttonTransitionStyles(showNext))\n\n  return (\n    <div\n      css={`\n        position: absolute;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        padding: 20px;\n        display: flex;\n        align-items: center;\n      `}\n    >\n      <div css=\"flex-shrink: 0\">\n        <animated.div style={prevTransitionStyles}>\n          <NavButton onClick={onPrev} type=\"prev\" />\n        </animated.div>\n      </div>\n      <div\n        css={`\n          width: 100%;\n          text-align: center;\n          height: 100%;\n        `}\n      >\n        {step + 1} of {steps}\n      </div>\n      <div css=\"flex-shrink: 0\">\n        <animated.div style={nextTransitionStyles}>\n          <NavButton onClick={onNext} type=\"next\" />\n        </animated.div>\n      </div>\n    </div>\n  )\n}\n\nNavigation.propTypes = {\n  step: PropTypes.number.isRequired,\n  steps: PropTypes.number.isRequired,\n  onPrev: PropTypes.func.isRequired,\n  onNext: PropTypes.func.isRequired,\n}\n\nfunction NavButton({ type, ...props }) {\n  const icon = type === 'next' ? <IconRight /> : <IconLeft />\n\n  return (\n    <ButtonBase {...props}>\n      <div\n        css={`\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          height: 53px;\n          width: 53px;\n          border-radius: 50%;\n          background: rgba(0, 0, 0, 0.03);\n          &:active {\n            background: rgba(0, 0, 0, 0.1);\n          }\n        `}\n      >\n        {icon}\n      </div>\n    </ButtonBase>\n  )\n}\n\nNavButton.propTypes = {\n  type: PropTypes.oneOf(['next', 'prev']),\n}\n\nexport default Navigation\n","import React, { useEffect, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport { Button, springs, useImageExists, useTheme } from '@aragon/ui'\nimport { Transition, animated } from 'react-spring'\nimport { ReactSpringStateType } from '../../prop-types'\n\n// Ratios based on the the design files\nexport const RATIO_LEFT = 500 / 1055\nexport const RATIO_TOP = 560 / 950\n\nconst TRANSLATE_VALUE_TITLE = 20\nconst TRANSLATE_VALUE_HEADING = 40\nconst TRANSLATE_VALUE_CONTENT = 60\n\n// Helping the styled-components `css` preprocessor\n// by using non-nested components.\nconst { div: AnimDiv, h1: AnimH1, p: AnimP } = animated\n\nconst HighlightScreen = ({\n  compactMode,\n  description,\n  onUpgrade,\n  enterProgress,\n  showProgress,\n  state,\n  title,\n  upgrade,\n  verticalMode,\n  visual,\n}) => {\n  const [leaving, setLeaving] = useState(false)\n  const theme = useTheme()\n  const visualSrc = compactMode && visual.small ? visual.small : visual.large\n  const { exists: visualSrcExists } = useImageExists(visualSrc)\n\n  useEffect(() => {\n    if (state === 'leave') {\n      setLeaving(true)\n    }\n  }, [state])\n  return (\n    <div\n      css={`\n        overflow: hidden;\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        flex-shrink: 0;\n        width: 100%;\n        height: ${verticalMode ? 'auto' : '100%'};\n        display: flex;\n        flex-direction: ${verticalMode ? 'column-reverse' : 'row'};\n        justify-content: ${verticalMode ? 'flex-end' : 'flex-start'};\n        align-items: center;\n        text-align: ${verticalMode ? 'center' : 'left'};\n      `}\n    >\n      <AnimDiv\n        css={`\n          overflow: ${verticalMode ? 'visible' : 'hidden'};\n          flex-shrink: 0;\n          width: ${verticalMode ? 'auto' : `${RATIO_LEFT * 100}%`};\n          height: ${verticalMode ? 'auto' : '100%'};\n          padding: ${verticalMode ? '30px 20px 90px' : `10vh 40px 90px`};\n          max-width: ${verticalMode ? '420px' : 'none'};\n          display: flex;\n          flex-direction: column;\n          position: relative;\n          z-index: 1;\n        `}\n        style={{\n          opacity: showProgress.interpolate(v =>\n            // Make content disappear faster than appearing\n            leaving ? v * v : v\n          ),\n        }}\n      >\n        <AnimP\n          css={`\n            color: ${theme.contentSecondary};\n            text-transform: uppercase;\n            font-size: ${compactMode ? 12 : 16}px;\n          `}\n          style={{\n            transform: enterProgress.interpolate(\n              v => `translate3d(${v * TRANSLATE_VALUE_TITLE}%, 0, 0)`\n            ),\n          }}\n        >\n          New Camino 0.8\n        </AnimP>\n        <AnimH1\n          css={`\n            font-size: ${compactMode ? 30 : 42}px;\n            line-height: 1.6;\n            margin: 10px 0 10px;\n          `}\n          style={{\n            transform: enterProgress.interpolate(\n              v => `translate3d(${v * TRANSLATE_VALUE_HEADING}%, 0, 0)`\n            ),\n          }}\n        >\n          {(compactMode && title.small) || title.large}\n        </AnimH1>\n        <AnimDiv\n          style={{\n            transform: enterProgress.interpolate(\n              v => `translate3d(${v * TRANSLATE_VALUE_CONTENT}%, 0, 0)`\n            ),\n          }}\n        >\n          <p\n            css={`\n              line-height: 1.8;\n              font-size: ${compactMode ? 16 : 18}px;\n              color: ${compactMode ? theme.contentSecondary : theme.content};\n            `}\n          >\n            {compactMode && description.small\n              ? description.small\n              : description.large}\n          </p>\n          {upgrade && (\n            <div css=\"margin-top: 30px\">\n              <Button\n                wide\n                mode=\"strong\"\n                onClick={onUpgrade}\n                css={`\n                  height: 56px;\n                  font-size: 18px;\n                  font-weight: 600;\n                `}\n              >\n                {compactMode && upgrade.small ? upgrade.small : upgrade.large}\n              </Button>\n            </div>\n          )}\n        </AnimDiv>\n      </AnimDiv>\n\n      <AnimDiv\n        css={`\n          overflow: hidden;\n          position: relative;\n          z-index: 2;\n          flex-shrink: 1;\n          width: 100%;\n          height: ${verticalMode ? `${RATIO_TOP * 100}%` : '100%'};\n          background: ${visual.color};\n        `}\n        style={{ opacity: leaving ? 0 : 1 }}\n      >\n        <Transition\n          native\n          items={visualSrcExists}\n          from={{ opacity: 0 }}\n          enter={{ opacity: 1 }}\n          leave={{ opacity: 0 }}\n          config={springs.lazy}\n        >\n          {exists =>\n            exists &&\n            /* eslint-disable react/prop-types */\n            (({ opacity }) => (\n              <AnimDiv\n                css={`\n                  position: absolute;\n                  top: 0;\n                  left: 0;\n                  right: 0;\n                  bottom: 0;\n                  background: ${`\n                        url(${visualSrc})\n                        ${verticalMode ? '50% 40%' : '0 50%'} / cover\n                        no-repeat,\n                        ${visual.color};\n                      `};\n                `}\n                style={{ opacity }}\n              />\n            ))\n          /* eslint-enable react/prop-types */\n          }\n        </Transition>\n      </AnimDiv>\n    </div>\n  )\n}\n\nHighlightScreen.propTypes = {\n  compactMode: PropTypes.bool,\n  description: PropTypes.shape({\n    small: PropTypes.string,\n    large: PropTypes.string.isRequired,\n  }),\n  enterProgress: PropTypes.object,\n  onUpgrade: PropTypes.func.isRequired,\n  showProgress: PropTypes.object,\n  state: ReactSpringStateType.isRequired,\n  title: PropTypes.shape({\n    small: PropTypes.string,\n    large: PropTypes.string.isRequired,\n  }),\n  upgrade: PropTypes.shape({\n    small: PropTypes.string,\n    large: PropTypes.string.isRequired,\n  }),\n  verticalMode: PropTypes.bool,\n  visual: PropTypes.shape({\n    small: PropTypes.string,\n    large: PropTypes.string.isRequired,\n    color: PropTypes.string.isRequired,\n  }).isRequired,\n}\n\nexport default HighlightScreen\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\nimport { animated, useSpring } from 'react-spring/hooks'\nimport { springs } from '@aragon/ui'\n\nconst ProgressBar = ({ value }) => {\n  const transitionStyles = useSpring({\n    config: springs.lazy,\n    to: { transform: `scale3d(${value}, 1, 1)` },\n  })\n  return <Bar style={transitionStyles} />\n}\n\nProgressBar.propTypes = {\n  value: PropTypes.number.isRequired,\n}\n\nconst Bar = styled(animated.div)`\n  position: absolute;\n  top: 0;\n  z-index: 2;\n  // prevents engines rounding issues\n  left: -1px;\n  right: -1px;\n  height: 8px;\n  background: linear-gradient(90deg, #00dbe2, #01bfe3);\n  transform-origin: 0 0;\n`\n\nexport default ProgressBar\n","import React, { useEffect } from 'react'\nimport PropTypes from 'prop-types'\nimport { ButtonIcon, Modal, Viewport, springs } from '@aragon/ui'\nimport { Transition } from 'react-spring'\nimport { useArrows, useSteps } from '../../hooks'\nimport { highlights } from './content'\nimport Navigation from './Navigation'\nimport HighlightScreen, { RATIO_LEFT } from './HighlightScreen'\nimport ProgressBar from './ProgressBar'\n\nimport closeSvg from './assets/close.svg'\n\nconst UpgradeModal = React.memo(\n  ({ visible, onUpgrade, onClose, canUpgradeOrg }) => {\n    const content = highlights[canUpgradeOrg ? '0.6' : 'latest']\n    const steps = content.length\n    const { step, next, prev, setStep, direction } = useSteps(steps)\n\n    // Keyboard navigation\n    useArrows(visible ? { onLeft: prev, onRight: next } : {})\n\n    useEffect(() => {\n      if (visible) {\n        setStep(0)\n      }\n    }, [setStep, visible])\n\n    return (\n      <Viewport>\n        {({ width, height }) => {\n          const verticalMode = width < 900\n          const compactMode = width < 500 || height < 400\n          return (\n            <Modal\n              padding={0}\n              width={Math.min(1055, width - 40)}\n              visible={visible}\n              onClose={onClose}\n              css={`\n                z-index: 4;\n              `}\n            >\n              <div\n                css=\"position: relative\"\n                style={{\n                  height: verticalMode\n                    ? `${height - 40}px`\n                    : `${Math.max(500, Math.min(620, height - 40))}px`,\n                }}\n              >\n                <ProgressBar value={(step + 1) / steps} />\n\n                <ButtonIcon\n                  label=\"Close\"\n                  onClick={onClose}\n                  css={`\n                    position: absolute;\n                    top: 17px;\n                    right: 17px;\n                    z-index: 2;\n                  `}\n                >\n                  <img src={closeSvg} alt=\"\" />\n                </ButtonIcon>\n\n                <div\n                  css={`\n                    position: relative;\n                    z-index: 1;\n                    width: 100%;\n                    height: 100%;\n                    overflow: hidden;\n                    display: flex;\n                  `}\n                >\n                  <Transition\n                    native\n                    items={step}\n                    from={{\n                      enterProgress: 1 * direction,\n                      showProgress: 0,\n                    }}\n                    initial={{\n                      enterProgress: 0,\n                      showProgress: 1,\n                    }}\n                    enter={{\n                      enterProgress: 0,\n                      showProgress: 1,\n                    }}\n                    leave={{\n                      enterProgress: -1 * direction,\n                      showProgress: 0,\n                    }}\n                    config={springs.smooth}\n                  >\n                    {(index, state) =>\n                      /* eslint-disable react/prop-types */\n                      ({ enterProgress, showProgress, status }) => (\n                        <HighlightScreen\n                          compactMode={compactMode}\n                          onUpgrade={onUpgrade}\n                          verticalMode={verticalMode}\n                          enterProgress={enterProgress}\n                          showProgress={showProgress}\n                          state={state}\n                          {...content[index]}\n                        />\n                      )\n                    /* eslint-enable react/prop-types */\n                    }\n                  </Transition>\n                </div>\n\n                <div\n                  css={`\n                    position: relative;\n                    z-index: 2;\n                  `}\n                  style={{\n                    width: verticalMode ? '100%' : `${RATIO_LEFT * 100}%`,\n                  }}\n                >\n                  <Navigation\n                    step={step}\n                    steps={steps}\n                    onPrev={prev}\n                    onNext={next}\n                  />\n                </div>\n              </div>\n            </Modal>\n          )\n        }}\n      </Viewport>\n    )\n  }\n)\n\nUpgradeModal.propTypes = {\n  onClose: PropTypes.func.isRequired,\n  onUpgrade: PropTypes.func.isRequired,\n  visible: PropTypes.bool.isRequired,\n  canUpgradeOrg: PropTypes.bool,\n}\n\nexport default UpgradeModal\n","const KNOWN_REPOS = new Set([\n  '0xbf8491150dafc5dcaee5b861414dca922de09ccffa344964ae167212e8c673ae',\n  '0x6b20a3010614eeebf2138ccec99f028a61c811b3b1a3343b6ff635985c75c91f',\n  '0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1',\n  '0x9fa3927f639745e587912d4b0fea7ef9013bf93fb907d29faeab57417ba6e1d4',\n])\n\nexport function isKnownRepo(appId) {\n  return KNOWN_REPOS.has(appId)\n}\n","import React, { useCallback, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\nimport {\n  Button,\n  Link,\n  Info,\n  SidePanel,\n  SidePanelSeparator,\n  SidePanelSplit,\n  GU,\n  textStyle,\n  useTheme,\n} from '@aragon/ui'\nimport {\n  AragonType,\n  DaoAddressType,\n  ReposListType,\n  RepoVersionType,\n} from '../../prop-types'\nimport { KERNEL_APP_BASE_NAMESPACE } from '../../util/aragonos'\nimport { isKnownRepo } from '../../util/repo'\nimport RepoBadge from '../../components/RepoBadge/RepoBadge'\nimport { sanitizeCodeRepositoryUrl } from '../../util/url'\n\nconst VERSION = '0.8 Camino'\nconst SOURCE = [\n  'github.com/aragon/aragon-apps',\n  'https://github.com/aragon/aragon-apps',\n]\nconst REGISTRY = ['aragonpm.eth', 'https://etherscan.io/address/aragonpm.eth']\n\nconst UpgradeOrganizationPanel = React.memo(\n  ({ repos = [], opened, onClose, daoAddress, wrapper }) => {\n    const theme = useTheme()\n    const knownUpgradableRepos = useMemo(\n      () => repos.filter(repo => isKnownRepo(repo.appId)),\n      [repos]\n    )\n\n    const handleUpgradeAll = useCallback(async () => {\n      const upgradeIntents = knownUpgradableRepos.map(({ appId, versions }) => {\n        const newContractAddress = versions[versions.length - 1].contractAddress\n        return [\n          daoAddress.address,\n          'setApp',\n          [KERNEL_APP_BASE_NAMESPACE, appId, newContractAddress],\n        ]\n      })\n\n      // Close the panel early, to allow the SignerPanel to open\n      // The animation helps us a little bit with the lag on calculating the path\n      onClose()\n\n      const {\n        path,\n        transactions,\n      } = await wrapper.getTransactionPathForIntentBasket(upgradeIntents, {\n        checkMode: 'single',\n      })\n\n      if (Array.isArray(path) && path.length) {\n        // We can use the power of calls scripts to do a single transaction!\n        await wrapper.performTransactionPath(path)\n      } else if (Array.isArray(transactions) && transactions.length) {\n        // User has direct access, so we need to send these intents one by one\n        for (const transaction of transactions) {\n          await wrapper.performTransactionPath([transaction])\n        }\n      } else {\n        // The user just can't perform this action, show the signing panel's error screen\n        await wrapper.performTransactionPath([])\n      }\n    }, [knownUpgradableRepos, daoAddress, onClose, wrapper])\n\n    return (\n      <SidePanel\n        title={`Upgrade to ${VERSION}`}\n        opened={opened}\n        onClose={onClose}\n      >\n        <SidePanelSplit\n          css={`\n            border-bottom: 1px solid ${theme.border};\n            ${textStyle('body2')};\n          `}\n        >\n          <div>\n            <Heading2 theme={theme}>Current version</Heading2>\n            {knownUpgradableRepos.map(repo => (\n              <AppVersion\n                key={repo.appId}\n                latestVersion={repo.latestVersion}\n                version={repo.currentVersion}\n              />\n            ))}\n          </div>\n          <div>\n            <Heading2 theme={theme}>New version</Heading2>\n            {knownUpgradableRepos.map(repo => (\n              <AppVersion\n                key={repo.appId}\n                latestVersion={repo.latestVersion}\n                version={repo.latestVersion}\n              />\n            ))}\n          </div>\n        </SidePanelSplit>\n\n        <Part>\n          <Heading2 theme={theme}>Source code</Heading2>\n          <p>\n            <Link external href={SOURCE[1]}>\n              {sanitizeCodeRepositoryUrl(SOURCE[0])}\n            </Link>\n          </p>\n\n          <Heading2 theme={theme}>Aragon official registry</Heading2>\n          <p>\n            <Link external href={REGISTRY[1]}>\n              {REGISTRY[0]}\n            </Link>\n          </p>\n        </Part>\n\n        <SidePanelSeparator />\n\n        <Part>\n          <div\n            css={`\n              margin: ${2 * GU}px 0;\n            `}\n          >\n            <Button mode=\"strong\" wide onClick={handleUpgradeAll}>\n              Upgrade your organization\n            </Button>\n          </div>\n          <div\n            css={`\n              margin: ${2 * GU}px 0;\n            `}\n          >\n            <Info>\n              <p\n                css={`\n                  margin-top: ${GU}px;\n                  font-size: 15px;\n                `}\n              >\n                All your app instances will be upgraded to Aragon {VERSION}.\n              </p>\n            </Info>\n          </div>\n        </Part>\n      </SidePanel>\n    )\n  }\n)\n\nUpgradeOrganizationPanel.propTypes = {\n  opened: PropTypes.bool,\n  onClose: PropTypes.func.isRequired,\n  repos: ReposListType,\n  daoAddress: DaoAddressType.isRequired,\n  wrapper: AragonType,\n}\n\nconst AppVersion = ({ latestVersion, version }) => {\n  return (\n    <div\n      css={`\n        display: inline-grid;\n        grid-template-columns: 4ch auto;\n        grid-gap: ${2 * GU}px;\n        align-items: center;\n        margin: ${0.5 * GU}px 0;\n      `}\n    >\n      <div>{version.version}</div>\n      <RepoBadge displayVersion={version} latestVersion={latestVersion} />\n    </div>\n  )\n}\n\nAppVersion.propTypes = {\n  latestVersion: RepoVersionType.isRequired,\n  version: RepoVersionType.isRequired,\n}\n\nconst Heading2 = styled.h2`\n  color: ${({ theme }) => theme.contentSecondary};\n  ${textStyle('label2')};\n  white-space: nowrap;\n  margin-bottom: ${2 * GU}px;\n`\n\nconst Part = styled.div`\n  ${textStyle('body2')};\n  padding: ${GU}px 0 ${3 * GU}px;\n  h2 {\n    margin: ${2 * GU}px 0 ${GU}px;\n  }\n`\n\nexport default UpgradeOrganizationPanel\n","import React, { useCallback, useEffect, useMemo, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  ButtonIcon,\n  GU,\n  IconMenu,\n  springs,\n  useTheme,\n  useViewport,\n} from '@aragon/ui'\nimport { Transition, animated } from 'react-spring'\nimport {\n  AppType,\n  AppsStatusType,\n  AragonType,\n  DaoAddressType,\n  DaoStatusType,\n  RepoType,\n} from '../../prop-types'\nimport styled from 'styled-components'\n\nimport { DAO_STATUS_LOADING } from '../../symbols'\nimport { iOS, isSafari } from '../../util/utils'\nimport { useClientTheme } from '../../client-theme'\nimport { useRouting } from '../../routing'\nimport ActivityButton from './ActivityButton/ActivityButton'\nimport AccountModule from '../AccountModule/AccountModule'\nimport GlobalPreferencesButton from './GlobalPreferencesButton/GlobalPreferencesButton'\nimport MenuPanel, { MENU_PANEL_WIDTH } from '../MenuPanel/MenuPanel'\nimport OrgViewApp from './OrgViewApp'\nimport OrganizationSwitcher from '../MenuPanel/OrganizationSwitcher/OrganizationSwitcher'\nimport SignerPanel from '../SignerPanel/SignerPanel'\nimport UpgradeBanner from '../Upgrade/UpgradeBanner'\nimport UpgradeModal from '../Upgrade/UpgradeModal'\nimport UpgradeOrganizationPanel from '../Upgrade/UpgradeOrganizationPanel'\nimport { NetworkIndicator } from '../NetworkIndicator/NetworkIndicator'\nimport { NetworkSwitchModal } from '../Modals'\nimport { trackEvent, events } from '../../analytics'\nimport { useWallet } from '../../contexts/wallet'\n\n// Remaining viewport width after the menu panel is factored in\nconst AppWidthContext = React.createContext(0)\n\nconst AnimatedDiv = animated.div\n\nfunction OrgView({\n  apps,\n  appsStatus,\n  canUpgradeOrg,\n  daoAddress,\n  daoStatus,\n  historyBack,\n  repos,\n  permissionsLoading,\n  signatureBag,\n  transactionBag,\n  visible,\n  web3,\n  wrapper,\n}) {\n  const { networkType } = useWallet()\n  const theme = useTheme()\n  const routing = useRouting()\n  const { appearance } = useClientTheme()\n  const { width, below } = useViewport()\n  const autoClosingPanel = below('medium')\n\n  const [menuPanelOpen, setMenuPanelOpen] = useState(!autoClosingPanel)\n  const [orgUpgradePanelOpened, setOrgUpgradePanelOpened] = useState(false)\n  const [networkModalOpened, setNetworkModalOpened] = useState(false)\n  const [upgradeModalOpened, setUpgradeModalOpened] = useState(false)\n\n  const appInstanceGroups = useMemo(\n    () =>\n      apps.reduce((groups, app) => {\n        const group = groups.find(({ appId }) => appId === app.appId)\n\n        const {\n          // This is not technically fully true, but let's assume that only these\n          // aspects are different between multiple instances of the same app\n          codeAddress: instanceCodeAddress,\n          identifier: instanceIdentifier,\n          proxyAddress: instanceProxyAddress,\n          ...sharedAppInfo\n        } = app\n\n        const instance = {\n          codeAddress: instanceCodeAddress,\n          identifier: instanceIdentifier,\n          instanceId: instanceProxyAddress,\n          proxyAddress: instanceProxyAddress,\n        }\n\n        // Append the instance to the existing app group\n        if (group) {\n          group.instances.push(instance)\n          return groups\n        }\n\n        return groups.concat([\n          {\n            app: sharedAppInfo,\n            appId: app.appId,\n            name: app.name,\n            instances: [instance],\n            hasWebApp: app.hasWebApp,\n            repoName: app.appName,\n          },\n        ])\n      }, []),\n    [apps]\n  )\n\n  const openApp = useCallback(\n    (instanceId, { instancePath } = {}) => {\n      routing.update(({ mode }) => ({\n        mode: { ...mode, instanceId, instancePath },\n      }))\n    },\n    [routing]\n  )\n\n  const handleCloseMenuPanel = useCallback(() => setMenuPanelOpen(false), [])\n\n  const hideOrgUpgradePanel = useCallback(() => {\n    setOrgUpgradePanelOpened(false)\n  }, [])\n\n  const handleOpenApp = useCallback(\n    (...args) => {\n      if (autoClosingPanel) {\n        handleCloseMenuPanel()\n      }\n\n      openApp(...args)\n\n      // analytics\n      // if an installed app clicked inside apps,\n      // this handler will be re triggered,\n      // but analytics is not required for apps' installed sub-page\n      if (args.length === 1) {\n        trackEvent(events.NAVIGATION_OPTION_SELECTED, {\n          dao_identifier: daoAddress.domain || daoAddress.address,\n          network: networkType,\n          option:\n            apps.find(obj => obj.proxyAddress === args[0])?.name || args[0],\n        })\n      }\n    },\n    [\n      autoClosingPanel,\n      handleCloseMenuPanel,\n      openApp,\n      daoAddress,\n      networkType,\n      apps,\n    ]\n  )\n\n  const openNetworkModal = useCallback(() => setNetworkModalOpened(true), [])\n\n  const closeNetworkSwitchModal = () => setNetworkModalOpened(false)\n\n  const handleUpgradeModalOpen = useCallback(() => {\n    setUpgradeModalOpened(true)\n  }, [])\n\n  const handleUpgradeModalClose = useCallback(() => {\n    setUpgradeModalOpened(false)\n  }, [])\n\n  const showOrgUpgradePanel = useCallback(() => {\n    // Only open the upgrade panel if the org can be upgraded\n    setOrgUpgradePanelOpened(canUpgradeOrg)\n    setUpgradeModalOpened(false)\n  }, [canUpgradeOrg])\n\n  const toggleMenuPanel = useCallback(\n    () => setMenuPanelOpen(opened => !opened),\n    []\n  )\n\n  useEffect(() => {\n    setMenuPanelOpen(!autoClosingPanel)\n  }, [autoClosingPanel])\n\n  const [showAppOverlay, setShowAppOverlay] = useState(false)\n\n  useEffect(() => {\n    setShowAppOverlay(true)\n\n    const timer = setTimeout(() => {\n      setShowAppOverlay(false)\n    }, 0)\n\n    return () => {\n      clearTimeout(timer)\n      setShowAppOverlay(false)\n    }\n  }, [appearance])\n\n  return (\n    <div\n      css={`\n        display: ${visible ? 'flex' : 'none'};\n        flex-direction: column;\n        position: relative;\n        z-index: 0;\n        height: 100vh;\n        min-width: ${45 * GU}px;\n      `}\n    >\n      <div\n        css={`\n          position: relative;\n          z-index: 1;\n          flex-shrink: 0;\n        `}\n      >\n        <UpgradeBanner\n          visible={canUpgradeOrg}\n          onMoreInfo={handleUpgradeModalOpen}\n        />\n      </div>\n      <AppWidthContext.Provider\n        value={autoClosingPanel ? width : width - MENU_PANEL_WIDTH}\n      >\n        <div\n          css={`\n            display: flex;\n            flex-direction: column;\n            position: relative;\n            height: 100%;\n            width: 100%;\n            background: ${theme.background};\n          `}\n        >\n          <TopbarContainer\n            iosMenuPane={menuPanelOpen && iOS}\n            bgColor={theme.surface}\n          >\n            {autoClosingPanel ? (\n              <ButtonIcon\n                label=\"Open menu\"\n                onClick={toggleMenuPanel}\n                css={`\n                  position: relative;\n                  top: ${2 * GU}px;\n                  left: ${2 * GU}px;\n                `}\n              >\n                <IconMenu />\n              </ButtonIcon>\n            ) : (\n              <OrganizationSwitcher\n                loading={daoStatus === DAO_STATUS_LOADING}\n                currentDao={{\n                  name: daoAddress.domain,\n                  address: daoAddress.address,\n                }}\n              />\n            )}\n            <RightButtonContainer>\n              <NetworkIndicator clickHandler={openNetworkModal} />\n              <AccountModule />\n              <GlobalPreferencesButton />\n              <ActivityButton apps={apps} />\n            </RightButtonContainer>\n          </TopbarContainer>\n          <div\n            css={`\n              flex-grow: 1;\n              overflow-y: hidden;\n              margin-top: 2px;\n              ${menuPanelOpen && iOS\n                ? `\n                  padding-top: ${8 * GU}px;\n                `\n                : ''}\n            `}\n          >\n            <div\n              css={`\n                display: flex;\n                height: 100%;\n                ${iOS || isSafari\n                  ? `\n                  height: calc(100vh - ${8 * GU}px);\n                `\n                  : ''}\n              `}\n            >\n              <MenuPanel\n                appInstanceGroups={appInstanceGroups}\n                appsStatus={appsStatus}\n                autoClosing={autoClosingPanel}\n                daoAddress={daoAddress}\n                daoStatus={daoStatus}\n                onMenuPanelClose={handleCloseMenuPanel}\n                onOpenApp={handleOpenApp}\n                opened={menuPanelOpen}\n                css=\"z-index: 3\"\n              />\n              <div\n                css={`\n                  flex-grow: 1;\n                  display: flex;\n                  position: relative;\n                  z-index: 1;\n                `}\n              >\n                <Transition\n                  config={springs.lazy}\n                  items={showAppOverlay}\n                  immediate={showAppOverlay}\n                  enter={{ opacity: 1 }}\n                  leave={{ opacity: 0 }}\n                >\n                  {show =>\n                    show &&\n                    (({ opacity }) => (\n                      <AnimatedDiv\n                        style={{ opacity }}\n                        css={`\n                          position: absolute;\n                          z-index: 2;\n                          top: 0;\n                          left: 0;\n                          right: 0;\n                          bottom: 0;\n                          background: ${theme.background};\n                        `}\n                      />\n                    ))\n                  }\n                </Transition>\n                <div\n                  css={`\n                    position: relative;\n                    z-index: 1;\n                    flex-grow: 1;\n                    overflow: hidden;\n                  `}\n                >\n                  <OrgViewApp\n                    apps={apps}\n                    appInstanceGroups={appInstanceGroups}\n                    appsStatus={appsStatus}\n                    canUpgradeOrg={canUpgradeOrg}\n                    daoAddress={daoAddress}\n                    daoStatus={daoStatus}\n                    historyBack={historyBack}\n                    onOpenApp={handleOpenApp}\n                    onShowOrgUpgradePanel={showOrgUpgradePanel}\n                    onUpgradeModalOpen={handleUpgradeModalOpen}\n                    permissionsLoading={permissionsLoading}\n                    repos={repos}\n                    wrapper={wrapper}\n                  />\n\n                  <SignerPanel\n                    apps={apps}\n                    transactionBag={transactionBag}\n                    signatureBag={signatureBag}\n                    web3={web3}\n                  />\n\n                  {canUpgradeOrg && (\n                    <UpgradeOrganizationPanel\n                      daoAddress={daoAddress}\n                      opened={orgUpgradePanelOpened}\n                      onClose={hideOrgUpgradePanel}\n                      repos={repos}\n                      wrapper={wrapper}\n                    />\n                  )}\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </AppWidthContext.Provider>\n      <NetworkSwitchModal\n        visible={networkModalOpened}\n        onClose={closeNetworkSwitchModal}\n      />\n      <UpgradeModal\n        visible={upgradeModalOpened}\n        onClose={handleUpgradeModalClose}\n        onUpgrade={showOrgUpgradePanel}\n        canUpgradeOrg={canUpgradeOrg}\n      />\n    </div>\n  )\n}\n\n// TODO extract topbar into proper component [vr 16-09-2021]\n/* NOTE: Behaviour only in iOS:\n * With the nested div->div->div structure the 3rd div has absolute position in\n * Chrome, Firefox and Safari. Such div gets rendered above the rest of the\n * content (up the tree till a position relative is found) but in iOS it gets\n * rendered below the sibling of the element with position relative (and z-index\n * did not work) this fix gives the element an absolute position (z-index layers\n * are then respected); this also adds the appropriate value to recover the\n * elements height.\n * */\nconst TopbarContainer = styled.div`\n  flex-shrink: 0;\n  position: relative;\n  z-index: 2;\n  height: ${8 * GU}px;\n  display: flex;\n  justify-content: space-between;\n  background: ${props => props.bgColor};\n  box-shadow: 0 2px 3px rgba(0, 0, 0, 0.05);\n\n  ${props =>\n    props.iosMenuPanel\n      ? `\n          position: absolute;\n          width: 100%;\n          z-index: 0;\n        `\n      : ''}\n`\n\nconst RightButtonContainer = styled.div`\n  display: flex;\n  align-items: center;\n  position: absolute;\n  top: 0;\n  right: 16px;\n  height: 100%;\"\n`\nOrgView.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  appsStatus: AppsStatusType.isRequired,\n  canUpgradeOrg: PropTypes.bool,\n  daoAddress: DaoAddressType.isRequired,\n  daoStatus: DaoStatusType.isRequired,\n  historyBack: PropTypes.func.isRequired,\n  permissionsLoading: PropTypes.bool.isRequired,\n  repos: PropTypes.arrayOf(RepoType).isRequired,\n  signatureBag: PropTypes.object,\n  transactionBag: PropTypes.object,\n  visible: PropTypes.bool.isRequired,\n  web3: PropTypes.object,\n  wrapper: AragonType,\n}\n\nOrgView.defaultProps = {\n  transactionBag: null,\n  signatureBag: null,\n}\n\nexport { AppWidthContext }\nexport default OrgView\n","import { useState, useEffect, useMemo } from 'react'\nimport { isEnsDomainAvailable } from '../aragonjs-wrapper'\nimport { completeDomain } from '../check-domain'\nimport { getActiveNetworks } from '../util/network'\nimport { getWeb3Provider } from '../util/web3'\n\n/**\n * This hook checks a list of networks for an ens domain. It returns all\n * network names on which the domain is found.\n *\n * @param {string} domain domain to check\n * @returns {{loading, networks}} object containing a loading state and a list of networks on which\n * the domain was found\n */\nexport function useDetectDao(domain) {\n  const [networks, setNetworks] = useState([])\n  const [loading, setLoading] = useState(true)\n\n  useEffect(() => {\n    setLoading(true)\n\n    let cancelled = false\n\n    const promiseTimeout = function(ms, promise) {\n      // Create a promise that rejects in <ms> milliseconds\n      const timeout = new Promise((resolve, reject) => {\n        const id = setTimeout(() => {\n          clearTimeout(id)\n          // Ignore for prefer-promise-reject-errors\n          // eslint-disable-next-line\n          reject({reason: 'timed out'})\n        }, ms)\n      })\n\n      // Returns a race between our timeout and the passed in promise\n      return Promise.race([promise, timeout])\n    }\n\n    const checkWithProvider = async () => {\n      const networksToCheck = getActiveNetworks()\n      try {\n        const providers = networksToCheck.map(n => ({\n          network: n,\n          provider: getWeb3Provider(n),\n        }))\n        const availabilityPromise = providers.map(p => {\n          // Avoid bad web sockets to freeze the application looking forever\n          return promiseTimeout(\n            3000,\n            isEnsDomainAvailable(p.network, p.provider, completeDomain(domain))\n          )\n        })\n\n        const availableNetworks = await Promise.allSettled(availabilityPromise)\n\n        // get only the ones promises that were fullfilled and ENS were not available (means DAO exists)\n        const daoExists = availableNetworks.map(a => !a.value && !a.reason)\n\n        const daoExistsOnNetworks = networksToCheck.filter(\n          (_, i) => daoExists[i]\n        )\n\n        // NOTE I can't seem to get the hook life cycle right, so I'm tearing\n        // the connections down immediately. [VR 22-09-2021]\n        providers.forEach(p => {\n          if (p.provider.disconnect) {\n            p.provider.disconnect()\n          } else {\n            // Older versions of web3's providers didn't expose a generic interface for disconnecting\n            p.provider.connection.close()\n          }\n        })\n\n        if (!cancelled) {\n          setLoading(false)\n          setNetworks(daoExistsOnNetworks)\n        }\n      } catch (err) {\n        console.error(err)\n      }\n    }\n\n    checkWithProvider()\n    return () => {\n      cancelled = true\n    }\n  }, [domain])\n\n  const data = useMemo(() => {\n    return { loading, networks }\n  }, [networks, loading])\n\n  return data\n}\n","import React, { useCallback, useEffect } from 'react'\nimport PropTypes from 'prop-types'\nimport { useTheme, textStyle, Link, GU, Info } from '@aragon/ui'\nimport styled from 'styled-components'\n\nimport { isAddress } from '../../util/web3'\nimport { useWallet } from '../../contexts/wallet'\nimport { getNetworkFullName, getNetworkShortName } from '../../util/network'\nimport { useDetectDao } from '../../hooks/useDetectDao'\nimport { useRouting } from '../../routing'\nimport { trackEvent, events } from '../../analytics'\n\nDAONotFoundError.propTypes = {\n  dao: PropTypes.string,\n}\n\nfunction DAONotFoundError({ dao }) {\n  const theme = useTheme()\n  const { loading, networks } = useDetectDao(dao)\n  const { networkType } = useWallet()\n\n  useEffect(() => {\n    // analytics\n    trackEvent(events.DAO_NOT_FOUND, {\n      dao_identifier: dao,\n      network: networkType,\n    })\n  }, [dao, networkType])\n\n  return (\n    <React.Fragment>\n      <ModalTitle color={theme.surfaceContent}>\n        Organization not found\n      </ModalTitle>\n      <MessageContainer>\n        {loading ? (\n          <Message color={theme.surfaceContentSecondary}>\n            Searching for it on other networks...\n          </Message>\n        ) : networks?.length ? (\n          <NotFoundOnNetworkMessage dao={dao} alternatives={networks} />\n        ) : (\n          <NotFoundAtAllMessage dao={dao} />\n        )}\n      </MessageContainer>\n      <Info>\n        If you arrived here through a link, please double check that you were\n        given the correct link. Alternatively, you may{' '}\n        <Link\n          onClick={() => {\n            window.location = '/'\n          }}\n        >\n          create a new organization.\n        </Link>\n      </Info>\n    </React.Fragment>\n  )\n}\n\nNotFoundAtAllMessage.propTypes = {\n  dao: PropTypes.string,\n}\n\nfunction NotFoundAtAllMessage({ dao }) {\n  const theme = useTheme()\n  const { networkType } = useWallet()\n\n  return (\n    <Message color={theme.surfaceContentSecondary}>\n      Thereâ€™s no organization associated with{' '}\n      <span css=\"font-weight: bold;\">'{dao}'</span>\n      on the {getNetworkFullName(networkType)}.\n    </Message>\n  )\n}\n\nNotFoundOnNetworkMessage.propTypes = {\n  dao: PropTypes.string,\n  alternatives: PropTypes.arrayOf(PropTypes.string),\n}\n\nfunction NotFoundOnNetworkMessage({ dao, alternatives }) {\n  const theme = useTheme()\n  const routing = useRouting()\n  const { networkType, changeNetworkTypeDisconnected } = useWallet()\n\n  const goToOrg = useCallback(\n    (orgAddress, networType) => {\n      changeNetworkTypeDisconnected(networType)\n      routing.update(locator => ({\n        ...locator,\n        mode: { name: 'org', orgAddress },\n      }))\n    },\n    [routing, changeNetworkTypeDisconnected]\n  )\n\n  return (\n    <React.Fragment>\n      <Message color={theme.surfaceContentSecondary}>\n        Thereâ€™s no organization associated with{' '}\n        <span css=\"font-weight: bold;\">'{dao}'</span> on the{' '}\n        {getNetworkFullName(networkType)}, but it does exist on another chain.\n        You may switch the application to another chain to see it.\n      </Message>\n      <LinksList>\n        {alternatives.map(a => (\n          <li key={a}>\n            <Link onClick={() => goToOrg(dao, a)}>\n              Open {!isAddress(dao) ? dao : 'it'} on {getNetworkShortName(a)}\n            </Link>\n          </li>\n        ))}\n      </LinksList>\n    </React.Fragment>\n  )\n}\n\nconst ModalTitle = styled.h1`\n  color: ${props => props.color};\n  ${textStyle('title2')};\n  margin-bottom: ${1.5 * GU}px;\n  text-align: center;\n`\n\nconst MessageContainer = styled.div`\n  margin-bottom: ${6 * GU}px;\n  text-align: center;\n`\n\nconst Message = styled.p`\n  ${textStyle('body2')};\n  color: ${props => props.color};\n`\n\nconst LinksList = styled.ul`\n  list-style: none;\n  padding-top: ${2 * GU}px;\n`\n\nexport default DAONotFoundError\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Card, GU, useTheme, useViewport } from '@aragon/ui'\nimport HomeButton from '../HomeButton/HomeButton'\n\nimport eagleSvg from '../../assets/eagle.svg'\nimport notFoundImage from '../../assets/dao-not-found.png'\n\nconst EAGLE_DIMENSIONS = [1307, 877]\n\nfunction ErrorScreen({ children }) {\n  const theme = useTheme()\n\n  return (\n    <div\n      css={`\n        height: 100vh;\n        min-width: ${45 * GU}px;\n        overflow: auto;\n        background: ${theme.background} fixed 50% 100% /\n          ${EAGLE_DIMENSIONS[0]}px ${EAGLE_DIMENSIONS[1]}px no-repeat\n          url(${eagleSvg});\n      `}\n    >\n      <HomeButton\n        onClick={() => {\n          // force a refresh rather than only changing the hash\n          window.location = '/'\n        }}\n        css={`\n          position: absolute;\n          top: ${1 * GU}px;\n          left: ${1 * GU}px;\n        `}\n      />\n      <div\n        css={`\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          padding: ${8 * GU}px;\n          min-height: 100%;\n        `}\n      >\n        <Container>\n          <img\n            src={notFoundImage}\n            alt=\"\"\n            width=\"147\"\n            height=\"144\"\n            css={`\n              display: block;\n              margin: ${5 * GU}px auto ${1.5 * GU}px;\n            `}\n          />\n          {children}\n        </Container>\n      </div>\n    </div>\n  )\n}\n\nErrorScreen.propTypes = {\n  children: PropTypes.node,\n}\n\nfunction Container({ children }) {\n  const theme = useTheme()\n  const { width } = useViewport()\n  return width < 60 * GU ? (\n    <div\n      css={`\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        min-width: ${45 * GU}px;\n        overflow: auto;\n        background: ${theme.surface};\n        display: grid;\n        align-items: center;\n      `}\n    >\n      <div\n        css={`\n          padding: ${5 * GU}px ${6 * GU}px ${6 * GU}px;\n        `}\n      >\n        {children}\n      </div>\n    </div>\n  ) : (\n    <Card\n      css={`\n        display: block;\n        padding: ${5 * GU}px ${6 * GU}px;\n        width: 100%;\n        max-width: ${72 * GU}px;\n        height: auto;\n        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);\n        cursor: unset;\n      `}\n    >\n      {children}\n    </Card>\n  )\n}\n\nContainer.propTypes = {\n  children: PropTypes.node,\n}\n\nexport default ErrorScreen\n","import React, { useEffect } from 'react'\nimport PropTypes from 'prop-types'\nimport { Spring, animated } from 'react-spring'\nimport { useTheme } from '@aragon/ui'\nimport { EthereumAddressType, ClientThemeType } from './prop-types'\nimport { useWallet } from './contexts/wallet'\nimport { useClientTheme } from './client-theme'\nimport { useRouting } from './routing'\nimport initWrapper, { pollConnectivity } from './aragonjs-wrapper'\nimport { Onboarding } from './onboarding'\nimport { getWeb3 } from './util/web3'\nimport { log } from './util/utils'\nimport { ActivityProvider } from './contexts/ActivityContext'\nimport { FavoriteDaosProvider } from './contexts/FavoriteDaosContext'\nimport { PermissionsProvider } from './contexts/PermissionsContext'\nimport { IdentityProvider } from './components/IdentityManager/IdentityManager'\nimport { LocalIdentityModalProvider } from './components/LocalIdentityModal/LocalIdentityModalManager'\nimport LocalIdentityModal from './components/LocalIdentityModal/LocalIdentityModal'\nimport GlobalPreferences from './components/GlobalPreferences/GlobalPreferences'\nimport CustomToast from './components/CustomToast/CustomToast'\nimport OrgView from './components/OrgView/OrgView'\nimport { identifyUser } from './analytics'\nimport { isKnownRepo } from './util/repo'\n\nimport {\n  APPS_STATUS_ERROR,\n  APPS_STATUS_READY,\n  APPS_STATUS_LOADING,\n  APPS_STATUS_UNLOADED,\n  DAO_STATUS_ERROR,\n  DAO_STATUS_READY,\n  DAO_STATUS_LOADING,\n  DAO_STATUS_UNLOADED,\n} from './symbols'\nimport { useClientWeb3 } from './contexts/ClientWeb3Context'\n\nimport { DAONotFound } from './errors'\nimport DAONotFoundError from './components/Error/DAONotFoundError'\nimport ErrorScreen from './components/Error/ErrorScreen'\n\nconst INITIAL_DAO_STATE = {\n  apps: [],\n  appIdentifiers: {},\n  appsStatus: APPS_STATUS_UNLOADED,\n  daoAddress: { address: '', domain: '' },\n  daoStatus: DAO_STATUS_UNLOADED,\n  permissions: {},\n  permissionsLoading: true,\n  repos: [],\n  fatalError: null,\n}\n\nclass App extends React.Component {\n  static propTypes = {\n    clientTheme: ClientThemeType.isRequired,\n    routing: PropTypes.object.isRequired,\n    theme: PropTypes.object.isRequired,\n    walletAccount: EthereumAddressType,\n    web3: PropTypes.object.isRequired,\n    networkType: PropTypes.string.isRequired,\n  }\n\n  state = {\n    ...INITIAL_DAO_STATE,\n    connected: false,\n    identityIntent: null,\n    transactionBag: null,\n    signatureBag: null,\n    wrapper: null,\n  }\n\n  componentDidMount() {\n    // analytics\n    if (process.env.REACT_APP_ANALYTICS_KEY) {\n      const cdn = document.createElement('script')\n      cdn.src = 'https://cdn.rudderlabs.com/v1/rudder-analytics.min.js'\n      cdn.async = true\n      document.body.appendChild(cdn)\n\n      const script = document.createElement('script')\n      script.innerText = `!function(){\n        rudderanalytics=window.rudderanalytics=[];for(var methods=[\"load\",\"page\",\"track\",\"identify\",\"alias\",\"group\",\"ready\",\"reset\",\"getAnonymousId\",\"setAnonymousId\"],i=0;i<methods.length;i++){var method=methods[i];rudderanalytics[method]=function(a){return function(){rudderanalytics.push([a].concat(Array.prototype.slice.call(arguments)))}}(method)}\n        rudderanalytics.load(\"${process.env.REACT_APP_ANALYTICS_KEY}\",\"https://rudderstack.aragon.org\");\n        rudderanalytics.page();\n        }();`\n      document.body.appendChild(script)\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.stopPolling) {\n      this.stopPolling()\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const { clientTheme, routing, walletAccount, networkType } = this.props\n    const { wrapper } = this.state\n\n    if (wrapper && walletAccount !== prevProps.walletAccount) {\n      wrapper.setAccounts(walletAccount === null ? [] : [walletAccount])\n    }\n\n    if (\n      wrapper &&\n      (!prevState.wrapper || clientTheme !== prevProps.clientTheme)\n    ) {\n      wrapper.setGuiStyle(clientTheme.appearance, clientTheme.theme)\n    }\n\n    if (prevProps.networkType !== networkType) {\n      if (this.stopPolling) {\n        this.stopPolling()\n      }\n      // readonly provider, because the app can work without the wallet\n      this.stopPolling = pollConnectivity([this.props.web3], connected => {\n        this.setState({ connected })\n      })\n    }\n\n    const { mode } = routing\n    const { mode: prevMode } = prevProps.routing\n    if (\n      mode.name === 'org' &&\n      (mode.orgAddress !== prevMode.orgAddress ||\n        prevProps.networkType !== networkType)\n    ) {\n      this.updateDao(mode.orgAddress)\n    }\n  }\n\n  updateDao(orgAddress) {\n    const {\n      clientTheme,\n      walletAccount,\n      web3,\n      networkType: walletNetwork,\n    } = this.props\n\n    // Cancel the subscriptions / unload the wrapper\n    if (this.state.wrapper) {\n      this.state.wrapper.cancel()\n      this.setState({ wrapper: null })\n    }\n\n    // Reset the DAO state\n    this.setState({\n      ...INITIAL_DAO_STATE,\n    })\n\n    if (orgAddress === null) {\n      return\n    }\n\n    // Loading state\n    this.setState({\n      appsStatus: APPS_STATUS_LOADING,\n      daoStatus: DAO_STATUS_LOADING,\n    })\n\n    log('Init DAO', orgAddress)\n    initWrapper(orgAddress, {\n      networkType: walletNetwork,\n      guiStyle: {\n        appearance: clientTheme.appearance,\n        theme: clientTheme.theme,\n      },\n      provider: web3,\n      walletAccount,\n      onDaoAddress: ({ networkType, address, domain, createdAt }) => {\n        log('dao', networkType, address, domain, createdAt)\n\n        this.setState({\n          daoStatus: DAO_STATUS_READY,\n          daoAddress: { address, domain },\n        })\n      },\n      onApps: apps => {\n        log('apps updated', apps)\n        this.setState({\n          apps,\n          appsStatus: APPS_STATUS_READY,\n        })\n      },\n      onPermissions: permissions => {\n        log('permissions updated', permissions)\n        this.setState({\n          permissions,\n          permissionsLoading: false,\n        })\n      },\n      onForwarders: forwarders => {\n        log('forwarders', forwarders)\n      },\n      onAppIdentifiers: appIdentifiers => {\n        log('app identifiers', appIdentifiers)\n        this.setState({ appIdentifiers })\n      },\n      onInstalledRepos: repos => {\n        const canUpgradeOrg = repos.some(\n          ({ appId, currentVersion, latestVersion }) =>\n            isKnownRepo(appId) &&\n            // If the installed app version is not a published version,\n            // never consider the organization for upgrades\n            Boolean(currentVersion) &&\n            currentVersion.version.split('.')[0] <\n              latestVersion.version.split('.')[0]\n        )\n        this.setState({ canUpgradeOrg, repos })\n      },\n      onTransaction: transactionBag => {\n        log('transaction bag', transactionBag)\n        this.setState({ transactionBag })\n      },\n      onSignatures: signatureBag => {\n        log('signature bag', signatureBag)\n        this.setState({ signatureBag })\n      },\n      onIdentityIntent: async identityIntent => {\n        // set the state for modifying a specific address identity\n        let name = null\n        try {\n          const identity = await this.handleIdentityResolve(\n            identityIntent.address\n          )\n          name = identity.name\n        } catch (_) {}\n        this.setState({\n          identityIntent: {\n            label: name,\n            ...identityIntent,\n          },\n        })\n      },\n      onRequestPath: ({ appAddress, path, resolve, reject }) => {\n        const { routing } = this.props\n        if (appAddress !== routing.mode.instanceId) {\n          reject(\n            `Canâ€™t change the path of ${appAddress}: the app is not currently active.`\n          )\n          return\n        }\n\n        resolve()\n\n        routing.update(({ mode }) => ({\n          mode: {\n            name: 'org',\n            orgAddress: mode.orgAddress,\n            instanceId: mode.instanceId,\n            instancePath: path,\n          },\n        }))\n      },\n    })\n      .then(wrapper => {\n        const { walletAccount } = this.props\n        if (walletAccount !== null) {\n          wrapper.setAccounts([walletAccount])\n        }\n        this.setState({ wrapper })\n        return wrapper\n      })\n      .catch(err => {\n        log(`Wrapper init, fatal error: ${err.name}. ${err.message}.`)\n\n        this.setState({\n          appsStatus: APPS_STATUS_ERROR,\n          daoStatus: DAO_STATUS_ERROR,\n          fatalError: err,\n        })\n      })\n  }\n\n  handleIdentityCancel = () => {\n    const { identityIntent } = this.state\n    identityIntent.reject(new Error('Identity modification cancelled'))\n    this.setState({ identityIntent: null })\n  }\n\n  handleIdentitySave = ({ address, label }) => {\n    const { identityIntent } = this.state\n    this.state.wrapper\n      .modifyAddressIdentity(address, { name: label })\n      .then(identityIntent.resolve)\n      .then(() => this.setState({ identityIntent: null }))\n      .catch(identityIntent.reject)\n  }\n\n  handleIdentityDelete = addresses => {\n    const { identityIntent } = this.state\n    this.state.wrapper\n      .removeLocalIdentities(addresses)\n      .then(identityIntent.resolve)\n      .then(this.setState({ identityIntent: null }))\n      .catch(identityIntent.reject)\n  }\n\n  handleIdentityResolve = address => {\n    // returns promise\n    if (this.state.wrapper) {\n      return this.state.wrapper.resolveAddressIdentity(address)\n    } else {\n      // wrapper has not been initialized\n      // re-request in 100 ms\n      return new Promise(resolve => {\n        setTimeout(async () => {\n          resolve(await this.handleIdentityResolve(address))\n        }, 100)\n      })\n    }\n  }\n\n  handleOpenLocalIdentityModal = address => {\n    return this.state.wrapper.requestAddressIdentityModification(address)\n  }\n\n  render() {\n    const { theme, routing, web3 } = this.props\n    const {\n      apps,\n      appIdentifiers,\n      appsStatus,\n      canUpgradeOrg,\n      daoAddress,\n      daoStatus,\n      fatalError,\n      identityIntent,\n      permissions,\n      permissionsLoading,\n      repos,\n      transactionBag,\n      signatureBag,\n      wrapper,\n    } = this.state\n\n    const { address: intentAddress = null, label: intentLabel = '' } =\n      identityIntent || {}\n\n    if (!routing.mode) {\n      return null\n    }\n\n    if (fatalError !== null) {\n      if (fatalError instanceof DAONotFound) {\n        return (\n          <ErrorScreen>\n            <DAONotFoundError dao={fatalError.dao} />\n          </ErrorScreen>\n        )\n      }\n      throw fatalError\n    }\n\n    const appsWithIdentifiers = apps.map(app => {\n      const identifier = appIdentifiers[app.proxyAddress]\n      return identifier\n        ? {\n            identifier,\n            ...app,\n          }\n        : app\n    })\n\n    return (\n      <Spring\n        from={{ opacity: 0, scale: 0.98 }}\n        to={{ opacity: 1, scale: 1 }}\n        native\n      >\n        {({ opacity, scale }) => (\n          <animated.div\n            style={{\n              opacity,\n              background: theme.background,\n            }}\n          >\n            <animated.div\n              style={{\n                transform: scale.interpolate(v => `scale3d(${v}, ${v}, 1)`),\n              }}\n            >\n              <CustomToast>\n                <IdentityProvider onResolve={this.handleIdentityResolve}>\n                  <LocalIdentityModalProvider\n                    onShowLocalIdentityModal={this.handleOpenLocalIdentityModal}\n                  >\n                    <LocalIdentityModal\n                      address={intentAddress}\n                      label={intentLabel}\n                      opened={identityIntent !== null}\n                      onCancel={this.handleIdentityCancel}\n                      onDelete={this.handleIdentityDelete}\n                      onSave={this.handleIdentitySave}\n                    />\n                    <FavoriteDaosProvider>\n                      <ActivityProvider\n                        daoDomain={daoAddress.domain}\n                        web3={getWeb3(web3)}\n                      >\n                        <PermissionsProvider\n                          wrapper={wrapper}\n                          apps={appsWithIdentifiers}\n                          permissions={permissions}\n                        >\n                          <div css=\"position: relative; z-index: 0\">\n                            <OrgView\n                              apps={appsWithIdentifiers}\n                              appsStatus={appsStatus}\n                              canUpgradeOrg={canUpgradeOrg}\n                              daoAddress={daoAddress}\n                              daoStatus={daoStatus}\n                              historyBack={routing.back}\n                              onRequestAppsReload={this.handleRequestAppsReload}\n                              permissionsLoading={permissionsLoading}\n                              repos={repos}\n                              signatureBag={signatureBag}\n                              transactionBag={transactionBag}\n                              visible={routing.mode.name === 'org'}\n                              web3={getWeb3(web3)}\n                              wrapper={wrapper}\n                            />\n                          </div>\n                        </PermissionsProvider>\n\n                        <Onboarding web3={web3} />\n\n                        <GlobalPreferences\n                          apps={appsWithIdentifiers}\n                          wrapper={wrapper}\n                        />\n                      </ActivityProvider>\n                    </FavoriteDaosProvider>\n                  </LocalIdentityModalProvider>\n                </IdentityProvider>\n              </CustomToast>\n            </animated.div>\n          </animated.div>\n        )}\n      </Spring>\n    )\n  }\n}\n\nexport default function AppHooksWrapper(props) {\n  const { account, connected, networkType, providerInfo } = useWallet()\n\n  const theme = useTheme()\n  const clientTheme = useClientTheme()\n  const routing = useRouting()\n  const { web3 } = useClientWeb3()\n\n  // analytics\n  useEffect(() => {\n    if (\n      connected &&\n      typeof account === 'string' &&\n      providerInfo.id !== 'unknown' &&\n      networkType\n    ) {\n      identifyUser(account, networkType, providerInfo.name)\n    }\n  }, [account, connected, networkType, providerInfo])\n\n  return (\n    <App\n      clientTheme={clientTheme}\n      routing={routing}\n      theme={theme}\n      walletAccount={account}\n      networkType={networkType}\n      web3={web3}\n      {...props}\n    />\n  )\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  Button,\n  Details,\n  GU,\n  Link,\n  RADIUS,\n  textStyle,\n  useTheme,\n} from '@aragon/ui'\n\nconst SUPPORT_URL = 'https://github.com/aragon/aragon/issues/new'\n\nconst GenericError = React.memo(function GenericError({\n  detailsTitle,\n  detailsContent,\n}) {\n  const theme = useTheme()\n\n  return (\n    <React.Fragment>\n      <h1\n        css={`\n          color: ${theme.surfaceContent};\n          ${textStyle('title2')};\n          margin-bottom: ${1.5 * GU}px;\n          text-align: center;\n        `}\n      >\n        An unexpected error has occurred\n      </h1>\n      <p\n        css={`\n          margin-bottom: ${5 * GU}px;\n          text-align: center;\n          color: ${theme.surfaceContentSecondary};\n          ${textStyle('body2')};\n        `}\n      >\n        Something went wrong! Hit reload to restart the app, or you can{' '}\n        <Link href={SUPPORT_URL}>contact</Link> us if the problem persists.\n      </p>\n      {(detailsTitle || detailsContent) && (\n        <Details label=\"Click here to see more details\">\n          <div\n            css={`\n              overflow: auto;\n              padding: ${2 * GU}px;\n              max-height: ${25 * GU}px;\n              border-radius: ${RADIUS}px;\n              color: ${theme.surfaceContent};\n              white-space: pre;\n              background: ${theme.surfaceUnder};\n              ${textStyle('body3')};\n              text-align: left;\n            `}\n          >\n            {detailsTitle && (\n              <h2\n                css={`\n                  ${textStyle('body2')};\n                  margin-bottom: ${1.5 * GU}px;\n                `}\n              >\n                {detailsTitle}\n              </h2>\n            )}\n            {detailsContent}\n          </div>\n        </Details>\n      )}\n      <div>\n        <Button\n          mode=\"strong\"\n          onClick={() => window.location.reload(true)}\n          wide\n          css={`\n            margin-left: 0px;\n          `}\n        >\n          Reload\n        </Button>\n      </div>\n    </React.Fragment>\n  )\n})\n\nGenericError.propTypes = {\n  detailsTitle: PropTypes.node,\n  detailsContent: PropTypes.node,\n}\n\nexport default GenericError\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport GenericError from './components/Error/GenericError'\nimport ErrorScreen from './components/Error/ErrorScreen'\n\nclass GlobalErrorHandler extends React.Component {\n  static propTypes = {\n    children: PropTypes.node,\n  }\n\n  state = { error: null, errorStack: null }\n\n  componentDidCatch(error, errorInfo) {\n    this.setState({\n      error,\n      errorStack: errorInfo.componentStack\n        .replace(/^\\n+|\\n+$/g, '')\n        .replace(/^ {4}/gm, ''),\n    })\n\n    // Once this point is reached, the app can not recover because the routing\n    // system, being below this component in the tree, is not functional\n    // anymore. To make hash changes work despite this (e.g. by pressing the\n    // back button in the browser), the page need to be reloaded.\n    window.removeEventListener('hashchange', this.handleHashchange)\n    window.addEventListener('hashchange', this.handleHashchange)\n  }\n  componentWillUnmount() {\n    window.removeEventListener('hashchange', this.handleHashchange)\n  }\n  handleHashchange = () => {\n    window.location.reload()\n  }\n  render() {\n    const { children } = this.props\n    const { error, errorStack } = this.state\n\n    return error ? (\n      <ErrorScreen>\n        <GenericError\n          detailsTitle={error.message}\n          detailsContent={errorStack}\n        />\n      </ErrorScreen>\n    ) : (\n      children\n    )\n  }\n}\n\nexport default GlobalErrorHandler\n","import 'core-js/stable'\nimport 'regenerator-runtime/runtime'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Main } from '@aragon/ui'\nimport App from './App'\nimport GlobalErrorHandler from './GlobalErrorHandler'\nimport { WalletProvider } from './contexts/wallet'\nimport { ClientThemeProvider, useClientTheme } from './client-theme'\nimport {\n  getLastPackageVersion,\n  getPackageVersion,\n  setPackageVersion,\n} from './local-settings'\nimport { RoutingProvider } from './routing'\nimport { ConsoleVisibleProvider } from './apps/Console/useConsole'\nimport { ClientWeb3Provider } from './contexts/ClientWeb3Context'\nimport { APMProvider } from './contexts/elasticAPM'\n\nconst packageVersion = getPackageVersion()\nconst lastPackageVersion = getLastPackageVersion()\n\nconst [currentMajorVersion] = packageVersion.split('.')\nconst [lastMajorVersion] = lastPackageVersion.split('.')\n\n// Purge localstorage when upgrading between different major versions.\nif (lastMajorVersion !== currentMajorVersion) {\n  window.localStorage.clear()\n\n  // Attempt to clean up indexedDB storage as well.\n  if (\n    window.indexedDB &&\n    window.indexedDB.databases &&\n    window.indexedDB.deleteDatabase\n  ) {\n    // eslint-disable-next-line promise/catch-or-return\n    window.indexedDB\n      .databases()\n      .then(databases =>\n        databases.forEach(({ name }) => window.indexedDB.deleteDatabase(name))\n      )\n  }\n}\n\n// Save the current package version\nif (packageVersion !== lastPackageVersion) {\n  setPackageVersion(packageVersion)\n}\n\nfunction Providers() {\n  const { appearance } = useClientTheme()\n  return (\n    <Main layout={false} scrollView={false} theme={appearance}>\n      <APMProvider>\n        <WalletProvider>\n          <RoutingProvider>\n            <ClientWeb3Provider>\n              <ConsoleVisibleProvider>\n                <GlobalErrorHandler>\n                  <App />\n                </GlobalErrorHandler>\n              </ConsoleVisibleProvider>\n            </ClientWeb3Provider>\n          </RoutingProvider>\n        </WalletProvider>\n      </APMProvider>\n    </Main>\n  )\n}\n\nReactDOM.render(\n  <ClientThemeProvider>\n    <Providers />\n  </ClientThemeProvider>,\n  document.getElementById('root')\n)\n","module.exports = stringify\nstringify.default = stringify\nstringify.stable = deterministicStringify\nstringify.stableStringify = deterministicStringify\n\nvar LIMIT_REPLACE_NODE = '[...]'\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\n\nvar arr = []\nvar replacerStack = []\n\nfunction defaultOptions () {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  }\n}\n\n// Regular stringify\nfunction stringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options)\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer)\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction setReplace (replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace })\n      arr.push([parent, k, val, propertyDescriptor])\n    } else {\n      replacerStack.push([val, k, replace])\n    }\n  } else {\n    parent[k] = replace\n    arr.push([parent, k, val])\n  }\n}\n\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      var keys = Object.keys(val)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        decirc(val[key], key, i, stack, val, depth, options)\n      }\n    }\n    stack.pop()\n  }\n}\n\n// Stable-stringify\nfunction compareFunction (a, b) {\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction deterministicStringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer)\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return\n      }\n    } catch (_) {\n      return\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {}\n      var keys = Object.keys(val).sort(compareFunction)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\n        tmp[key] = val[key]\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val])\n        parent[k] = tmp\n      } else {\n        return tmp\n      }\n    }\n    stack.pop()\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues (replacer) {\n  replacer =\n    typeof replacer !== 'undefined'\n      ? replacer\n      : function (k, v) {\n        return v\n      }\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i]\n        if (part[1] === key && part[0] === val) {\n          val = part[2]\n          replacerStack.splice(i, 1)\n          break\n        }\n      }\n    }\n    return replacer.call(this, key, val)\n  }\n}\n","/* Observable */\nexport { Observable } from './internal/Observable';\nexport { ConnectableObservable } from './internal/observable/ConnectableObservable';\nexport { GroupedObservable } from './internal/operators/groupBy';\nexport { Operator } from './internal/Operator';\nexport { observable } from './internal/symbol/observable';\n\n/* Subjects */\nexport { Subject } from './internal/Subject';\nexport { BehaviorSubject } from './internal/BehaviorSubject';\nexport { ReplaySubject } from './internal/ReplaySubject';\nexport { AsyncSubject } from './internal/AsyncSubject';\n\n/* Schedulers */\nexport { asap, asapScheduler } from './internal/scheduler/asap';\nexport { async, asyncScheduler } from './internal/scheduler/async';\nexport { queue, queueScheduler } from './internal/scheduler/queue';\nexport { animationFrame, animationFrameScheduler } from './internal/scheduler/animationFrame';\nexport { VirtualTimeScheduler, VirtualAction } from './internal/scheduler/VirtualTimeScheduler';\nexport { Scheduler } from './internal/Scheduler';\n\n/* Subscription */\nexport { Subscription } from './internal/Subscription';\nexport { Subscriber } from './internal/Subscriber';\n\n/* Notification */\nexport { Notification, NotificationKind } from './internal/Notification';\n\n/* Utils */\nexport { pipe } from './internal/util/pipe';\nexport { noop } from './internal/util/noop';\nexport { identity } from './internal/util/identity';\nexport { isObservable } from './internal/util/isObservable';\n\n/* Error types */\nexport { ArgumentOutOfRangeError } from './internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from './internal/util/EmptyError';\nexport { ObjectUnsubscribedError } from './internal/util/ObjectUnsubscribedError';\nexport { UnsubscriptionError } from './internal/util/UnsubscriptionError';\nexport { TimeoutError } from './internal/util/TimeoutError';\n\n/* Static observable creation exports */\nexport { bindCallback } from './internal/observable/bindCallback';\nexport { bindNodeCallback } from './internal/observable/bindNodeCallback';\nexport { combineLatest } from './internal/observable/combineLatest';\nexport { concat } from './internal/observable/concat';\nexport { defer } from './internal/observable/defer';\nexport { empty } from './internal/observable/empty';\nexport { forkJoin } from './internal/observable/forkJoin';\nexport { from } from './internal/observable/from';\nexport { fromEvent } from './internal/observable/fromEvent';\nexport { fromEventPattern } from './internal/observable/fromEventPattern';\nexport { generate } from './internal/observable/generate';\nexport { iif } from './internal/observable/iif';\nexport { interval } from './internal/observable/interval';\nexport { merge } from './internal/observable/merge';\nexport { never } from './internal/observable/never';\nexport { of } from './internal/observable/of';\nexport { onErrorResumeNext } from './internal/observable/onErrorResumeNext';\nexport { pairs } from './internal/observable/pairs';\nexport { partition } from './internal/observable/partition';\nexport { race } from './internal/observable/race';\nexport { range } from './internal/observable/range';\nexport { throwError } from './internal/observable/throwError';\nexport { timer } from './internal/observable/timer';\nexport { using } from './internal/observable/using';\nexport { zip } from './internal/observable/zip';\nexport { scheduled } from './internal/scheduled/scheduled';\n\n/* Constants */\nexport { EMPTY } from './internal/observable/empty';\nexport { NEVER } from './internal/observable/never';\n\n/* Types */\nexport * from './internal/types';\n\n/* Config */\nexport { config } from './internal/config';\n","'use strict';\n\nconst processFn = (fn, opts) => function () {\n\tconst P = opts.promiseModule;\n\tconst args = new Array(arguments.length);\n\n\tfor (let i = 0; i < arguments.length; i++) {\n\t\targs[i] = arguments[i];\n\t}\n\n\treturn new P((resolve, reject) => {\n\t\tif (opts.errorFirst) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (opts.multiArgs) {\n\t\t\t\t\tconst results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (let i = 1; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i - 1] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tresults.unshift(err);\n\t\t\t\t\t\treject(results);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t}\n\t\t\t\t} else if (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\targs.push(function (result) {\n\t\t\t\tif (opts.multiArgs) {\n\t\t\t\t\tconst results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(results);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfn.apply(this, args);\n\t});\n};\n\nmodule.exports = (obj, opts) => {\n\topts = Object.assign({\n\t\texclude: [/.+(Sync|Stream)$/],\n\t\terrorFirst: true,\n\t\tpromiseModule: Promise\n\t}, opts);\n\n\tconst filter = key => {\n\t\tconst match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\t\treturn opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n\t};\n\n\tlet ret;\n\tif (typeof obj === 'function') {\n\t\tret = function () {\n\t\t\tif (opts.excludeMain) {\n\t\t\t\treturn obj.apply(this, arguments);\n\t\t\t}\n\n\t\t\treturn processFn(obj, opts).apply(this, arguments);\n\t\t};\n\t} else {\n\t\tret = Object.create(Object.getPrototypeOf(obj));\n\t}\n\n\tfor (const key in obj) { // eslint-disable-line guard-for-in\n\t\tconst x = obj[key];\n\t\tret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;\n\t}\n\n\treturn ret;\n};\n","module.exports = IdIterator\n\nfunction IdIterator(opts){\n  opts = opts || {}\n  var max = opts.max || Number.MAX_SAFE_INTEGER\n  var idCounter = typeof opts.start !== 'undefined' ? opts.start : Math.floor(Math.random() * max)\n\n  return function createRandomId () {\n    idCounter = idCounter % max\n    return idCounter++\n  }\n\n}","const extend = require('xtend')\nconst createRandomId = require('json-rpc-random-id')()\n\nmodule.exports = EthQuery\n\n\nfunction EthQuery(provider){\n  const self = this\n  self.currentProvider = provider\n}\n\n//\n// base queries\n//\n\n// default block\nEthQuery.prototype.getBalance =                          generateFnWithDefaultBlockFor(2, 'eth_getBalance')\nEthQuery.prototype.getCode =                             generateFnWithDefaultBlockFor(2, 'eth_getCode')\nEthQuery.prototype.getTransactionCount =                 generateFnWithDefaultBlockFor(2, 'eth_getTransactionCount')\nEthQuery.prototype.getStorageAt =                        generateFnWithDefaultBlockFor(3, 'eth_getStorageAt')\nEthQuery.prototype.call =                                generateFnWithDefaultBlockFor(2, 'eth_call')\n// standard\nEthQuery.prototype.protocolVersion =                     generateFnFor('eth_protocolVersion')\nEthQuery.prototype.syncing =                             generateFnFor('eth_syncing')\nEthQuery.prototype.coinbase =                            generateFnFor('eth_coinbase')\nEthQuery.prototype.mining =                              generateFnFor('eth_mining')\nEthQuery.prototype.hashrate =                            generateFnFor('eth_hashrate')\nEthQuery.prototype.gasPrice =                            generateFnFor('eth_gasPrice')\nEthQuery.prototype.accounts =                            generateFnFor('eth_accounts')\nEthQuery.prototype.blockNumber =                         generateFnFor('eth_blockNumber')\nEthQuery.prototype.getBlockTransactionCountByHash =      generateFnFor('eth_getBlockTransactionCountByHash')\nEthQuery.prototype.getBlockTransactionCountByNumber =    generateFnFor('eth_getBlockTransactionCountByNumber')\nEthQuery.prototype.getUncleCountByBlockHash =            generateFnFor('eth_getUncleCountByBlockHash')\nEthQuery.prototype.getUncleCountByBlockNumber =          generateFnFor('eth_getUncleCountByBlockNumber')\nEthQuery.prototype.sign =                                generateFnFor('eth_sign')\nEthQuery.prototype.sendTransaction =                     generateFnFor('eth_sendTransaction')\nEthQuery.prototype.sendRawTransaction =                  generateFnFor('eth_sendRawTransaction')\nEthQuery.prototype.estimateGas =                         generateFnFor('eth_estimateGas')\nEthQuery.prototype.getBlockByHash =                      generateFnFor('eth_getBlockByHash')\nEthQuery.prototype.getBlockByNumber =                    generateFnFor('eth_getBlockByNumber')\nEthQuery.prototype.getTransactionByHash =                generateFnFor('eth_getTransactionByHash')\nEthQuery.prototype.getTransactionByBlockHashAndIndex =   generateFnFor('eth_getTransactionByBlockHashAndIndex')\nEthQuery.prototype.getTransactionByBlockNumberAndIndex = generateFnFor('eth_getTransactionByBlockNumberAndIndex')\nEthQuery.prototype.getTransactionReceipt =               generateFnFor('eth_getTransactionReceipt')\nEthQuery.prototype.getUncleByBlockHashAndIndex =         generateFnFor('eth_getUncleByBlockHashAndIndex')\nEthQuery.prototype.getUncleByBlockNumberAndIndex =       generateFnFor('eth_getUncleByBlockNumberAndIndex')\nEthQuery.prototype.getCompilers =                        generateFnFor('eth_getCompilers')\nEthQuery.prototype.compileLLL =                          generateFnFor('eth_compileLLL')\nEthQuery.prototype.compileSolidity =                     generateFnFor('eth_compileSolidity')\nEthQuery.prototype.compileSerpent =                      generateFnFor('eth_compileSerpent')\nEthQuery.prototype.newFilter =                           generateFnFor('eth_newFilter')\nEthQuery.prototype.newBlockFilter =                      generateFnFor('eth_newBlockFilter')\nEthQuery.prototype.newPendingTransactionFilter =         generateFnFor('eth_newPendingTransactionFilter')\nEthQuery.prototype.uninstallFilter =                     generateFnFor('eth_uninstallFilter')\nEthQuery.prototype.getFilterChanges =                    generateFnFor('eth_getFilterChanges')\nEthQuery.prototype.getFilterLogs =                       generateFnFor('eth_getFilterLogs')\nEthQuery.prototype.getLogs =                             generateFnFor('eth_getLogs')\nEthQuery.prototype.getWork =                             generateFnFor('eth_getWork')\nEthQuery.prototype.submitWork =                          generateFnFor('eth_submitWork')\nEthQuery.prototype.submitHashrate =                      generateFnFor('eth_submitHashrate')\n\n// network level\n\nEthQuery.prototype.sendAsync = function(opts, cb){\n  const self = this\n  self.currentProvider.sendAsync(createPayload(opts), function(err, response){\n    if (!err && response.error) err = new Error('EthQuery - RPC Error - '+response.error.message)\n    if (err) return cb(err)\n    cb(null, response.result)\n  })\n}\n\n// util\n\nfunction generateFnFor(methodName){\n  return function(){\n    const self = this\n    var args = [].slice.call(arguments)\n    var cb = args.pop()\n    self.sendAsync({\n      method: methodName,\n      params: args,\n    }, cb)\n  }\n}\n\nfunction generateFnWithDefaultBlockFor(argCount, methodName){\n  return function(){\n    const self = this\n    var args = [].slice.call(arguments)\n    var cb = args.pop()\n    // set optional default block param\n    if (args.length < argCount) args.push('latest')\n    self.sendAsync({\n      method: methodName,\n      params: args,\n    }, cb)\n  }\n}\n\nfunction createPayload(data){\n  return extend({\n    // defaults\n    id: createRandomId(),\n    jsonrpc: '2.0',\n    params: [],\n    // user-specified\n  }, data)\n}\n","const util = require('util')\nconst EventEmitter = require('events/')\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n}\n\nmodule.exports = SafeEventEmitter\n\n\nfunction SafeEventEmitter() {\n  EventEmitter.call(this)\n}\n\nutil.inherits(SafeEventEmitter, EventEmitter)\n\nSafeEventEmitter.prototype.emit = function (type) {\n  // copied from https://github.com/Gozala/events/blob/master/events.js\n  // modified lines are commented with \"edited:\"\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    // edited: using safeApply\n    safeApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      // edited: using safeApply\n      safeApply(listeners[i], this, args);\n  }\n\n  return true;\n}\n\nfunction safeApply(handler, context, args) {\n  try {\n    ReflectApply(handler, context, args)\n  } catch (err) {\n    // throw error after timeout so as not to interupt the stack\n    setTimeout(() => {\n      throw err\n    })\n  }\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n","const EthQuery = require('eth-query')\nconst pify = require('pify')\nconst SafeEventEmitter = require('safe-event-emitter')\n\nconst sec = 1000\n\nconst calculateSum = (accumulator, currentValue) => accumulator + currentValue\nconst blockTrackerEvents = ['sync', 'latest']\n\nclass BaseBlockTracker extends SafeEventEmitter {\n\n  //\n  // public\n  //\n\n  constructor (opts = {}) {\n    super()\n    // config\n    this._blockResetDuration = opts.blockResetDuration || 20 * sec\n    // state\n    this._blockResetTimeout\n    this._currentBlock = null\n    this._isRunning = false\n    // bind functions for internal use\n    this._onNewListener = this._onNewListener.bind(this)\n    this._onRemoveListener = this._onRemoveListener.bind(this)\n    this._resetCurrentBlock = this._resetCurrentBlock.bind(this)\n    // listen for handler changes\n    this._setupInternalEvents()\n  }\n\n  isRunning () {\n    return this._isRunning\n  }\n\n  getCurrentBlock () {\n    return this._currentBlock\n  }\n\n  async getLatestBlock () {\n    // return if available\n    if (this._currentBlock) return this._currentBlock\n    // wait for a new latest block\n    const latestBlock = await new Promise(resolve => this.once('latest', resolve))\n    // return newly set current block\n    return latestBlock\n  }\n\n  // dont allow module consumer to remove our internal event listeners\n  removeAllListeners (eventName) {\n    // perform default behavior, preserve fn arity\n    if (eventName) {\n      super.removeAllListeners(eventName)\n    } else {\n      super.removeAllListeners()\n    }\n    // re-add internal events\n    this._setupInternalEvents()\n    // trigger stop check just in case\n    this._onRemoveListener()\n  }\n\n  //\n  // to be implemented in subclass\n  //\n\n  _start () {\n    // default behavior is noop\n  }\n\n  _end () {\n    // default behavior is noop\n  }\n\n  //\n  // private\n  //\n\n  _setupInternalEvents () {\n    // first remove listeners for idempotence\n    this.removeListener('newListener', this._onNewListener)\n    this.removeListener('removeListener', this._onRemoveListener)\n    // then add them\n    this.on('newListener', this._onNewListener)\n    this.on('removeListener', this._onRemoveListener)\n  }\n\n  _onNewListener (eventName, handler) {\n    // `newListener` is called *before* the listener is added\n    if (!blockTrackerEvents.includes(eventName)) return\n    this._maybeStart()\n  }\n\n  _onRemoveListener (eventName, handler) {\n    // `removeListener` is called *after* the listener is removed\n    if (this._getBlockTrackerEventCount() > 0) return\n    this._maybeEnd()\n  }\n\n  _maybeStart () {\n    if (this._isRunning) return\n    this._isRunning = true\n    // cancel setting latest block to stale\n    this._cancelBlockResetTimeout()\n    this._start()\n  }\n\n  _maybeEnd () {\n    if (!this._isRunning) return\n    this._isRunning = false\n    this._setupBlockResetTimeout()\n    this._end()\n  }\n\n  _getBlockTrackerEventCount () {\n    return blockTrackerEvents\n      .map(eventName => this.listenerCount(eventName))\n      .reduce(calculateSum)\n  }\n\n  _newPotentialLatest (newBlock) {\n    const currentBlock = this._currentBlock\n    // only update if blok number is higher\n    if (currentBlock && (hexToInt(newBlock) <= hexToInt(currentBlock))) return\n    this._setCurrentBlock(newBlock)\n  }\n\n  _setCurrentBlock (newBlock) {\n    const oldBlock = this._currentBlock\n    this._currentBlock = newBlock\n    this.emit('latest', newBlock)\n    this.emit('sync', { oldBlock, newBlock })\n  }\n\n  _setupBlockResetTimeout () {\n    // clear any existing timeout\n    this._cancelBlockResetTimeout()\n    // clear latest block when stale\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration)\n    // nodejs - dont hold process open\n    if (this._blockResetTimeout.unref) {\n      this._blockResetTimeout.unref()\n    }\n  }\n\n  _cancelBlockResetTimeout () {\n    clearTimeout(this._blockResetTimeout)\n  }\n\n  _resetCurrentBlock () {\n    this._currentBlock = null\n  }\n\n}\n\nmodule.exports = BaseBlockTracker\n\nfunction hexToInt(hexInt) {\n  return Number.parseInt(hexInt, 16)\n}\n","const pify = require('pify')\nconst BaseBlockTracker = require('./base')\n\nconst sec = 1000\n\nclass PollingBlockTracker extends BaseBlockTracker {\n\n  constructor (opts = {}) {\n    // parse + validate args\n    if (!opts.provider) throw new Error('PollingBlockTracker - no provider specified.')\n    const pollingInterval = opts.pollingInterval || 20 * sec\n    const retryTimeout = opts.retryTimeout || pollingInterval / 10\n    const keepEventLoopActive = opts.keepEventLoopActive !== undefined ? opts.keepEventLoopActive : true\n    const setSkipCacheFlag = opts.setSkipCacheFlag || false\n    // BaseBlockTracker constructor\n    super(Object.assign({\n      blockResetDuration: pollingInterval,\n    }, opts))\n    // config\n    this._provider = opts.provider\n    this._pollingInterval = pollingInterval\n    this._retryTimeout = retryTimeout\n    this._keepEventLoopActive = keepEventLoopActive\n    this._setSkipCacheFlag = setSkipCacheFlag\n  }\n\n  //\n  // public\n  //\n\n  // trigger block polling\n  async checkForLatestBlock () {\n    await this._updateLatestBlock()\n    return await this.getLatestBlock()\n  }\n\n  //\n  // private\n  //\n\n  _start () {\n    this._performSync().catch(err => this.emit('error', err))\n  }\n\n  async _performSync () {\n    while (this._isRunning) {\n      try {\n        await this._updateLatestBlock()\n        await timeout(this._pollingInterval, !this._keepEventLoopActive)\n      } catch (err) {\n        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\\n${err.stack}`)\n        try {\n          this.emit('error', newErr)\n        } catch (emitErr) {\n          console.error(newErr)\n        }\n        await timeout(this._retryTimeout, !this._keepEventLoopActive)\n      }\n    }\n  }\n\n  async _updateLatestBlock () {\n    // fetch + set latest block\n    const latestBlock = await this._fetchLatestBlock()\n    this._newPotentialLatest(latestBlock)\n  }\n\n  async _fetchLatestBlock () {\n    const req = { jsonrpc: \"2.0\", id: 1, method: 'eth_blockNumber', params: [] }\n    if (this._setSkipCacheFlag) req.skipCache = true\n    const res = await pify((cb) => this._provider.sendAsync(req, cb))()\n    if (res.error) throw new Error(`PollingBlockTracker - encountered error fetching block:\\n${res.error}`)\n    return res.result\n  }\n\n}\n\nmodule.exports = PollingBlockTracker\n\nfunction timeout (duration, unref) {\n  return new Promise(resolve => {\n    const timoutRef = setTimeout(resolve, duration)\n    // don't keep process open\n    if (timoutRef.unref && unref) {\n      timoutRef.unref()\n    }\n  })\n}\n","module.exports = function createScaffoldMiddleware (handlers) {\n  return (req, res, next, end) => {\n    const handler = handlers[req.method]\n    // if no handler, return\n    if (handler === undefined) {\n      return next()\n    }\n    // if handler is fn, call as middleware\n    if (typeof handler === 'function') {\n      return handler(req, res, next, end)\n    }\n    // if handler is some other value, use as result\n    res.result = handler\n    return end()\n  }\n}\n","// for backwards compat\nmodule.exports = require('json-rpc-engine/src/createScaffoldMiddleware')\n",null,null,null,null,null,null,null,null,null,"/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import { __awaiter, __generator } from \"tslib\";\nvar Semaphore = /** @class */ (function () {\n    function Semaphore(_maxConcurrency) {\n        this._maxConcurrency = _maxConcurrency;\n        this._queue = [];\n        if (_maxConcurrency <= 0) {\n            throw new Error('semaphore must be initialized to a positive value');\n        }\n        this._value = _maxConcurrency;\n    }\n    Semaphore.prototype.acquire = function () {\n        var _this = this;\n        var locked = this.isLocked();\n        var ticket = new Promise(function (r) { return _this._queue.push(r); });\n        if (!locked)\n            this._dispatch();\n        return ticket;\n    };\n    Semaphore.prototype.runExclusive = function (callback) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, value, release;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this.acquire()];\n                    case 1:\n                        _a = _b.sent(), value = _a[0], release = _a[1];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, , 4, 5]);\n                        return [4 /*yield*/, callback(value)];\n                    case 3: return [2 /*return*/, _b.sent()];\n                    case 4:\n                        release();\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Semaphore.prototype.isLocked = function () {\n        return this._value <= 0;\n    };\n    Semaphore.prototype.release = function () {\n        if (this._maxConcurrency > 1) {\n            throw new Error('this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead');\n        }\n        if (this._currentReleaser) {\n            var releaser = this._currentReleaser;\n            this._currentReleaser = undefined;\n            releaser();\n        }\n    };\n    Semaphore.prototype._dispatch = function () {\n        var _this = this;\n        var nextConsumer = this._queue.shift();\n        if (!nextConsumer)\n            return;\n        var released = false;\n        this._currentReleaser = function () {\n            if (released)\n                return;\n            released = true;\n            _this._value++;\n            _this._dispatch();\n        };\n        nextConsumer([this._value--, this._currentReleaser]);\n    };\n    return Semaphore;\n}());\nexport default Semaphore;\n","import { __awaiter, __generator } from \"tslib\";\nimport Semaphore from './Semaphore';\nvar Mutex = /** @class */ (function () {\n    function Mutex() {\n        this._semaphore = new Semaphore(1);\n    }\n    Mutex.prototype.acquire = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, releaser;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this._semaphore.acquire()];\n                    case 1:\n                        _a = _b.sent(), releaser = _a[1];\n                        return [2 /*return*/, releaser];\n                }\n            });\n        });\n    };\n    Mutex.prototype.runExclusive = function (callback) {\n        return this._semaphore.runExclusive(function () { return callback(); });\n    };\n    Mutex.prototype.isLocked = function () {\n        return this._semaphore.isLocked();\n    };\n    Mutex.prototype.release = function () {\n        this._semaphore.release();\n    };\n    return Mutex;\n}());\nexport default Mutex;\n","import { __awaiter, __generator } from \"tslib\";\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function withTimeout(sync, timeout, timeoutError) {\n    var _this = this;\n    if (timeoutError === void 0) { timeoutError = new Error('timeout'); }\n    return {\n        acquire: function () {\n            return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\n                var isTimeout, ticket, release;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            isTimeout = false;\n                            setTimeout(function () {\n                                isTimeout = true;\n                                reject(timeoutError);\n                            }, timeout);\n                            return [4 /*yield*/, sync.acquire()];\n                        case 1:\n                            ticket = _a.sent();\n                            if (isTimeout) {\n                                release = Array.isArray(ticket) ? ticket[1] : ticket;\n                                release();\n                            }\n                            else {\n                                resolve(ticket);\n                            }\n                            return [2 /*return*/];\n                    }\n                });\n            }); });\n        },\n        runExclusive: function (callback) {\n            return __awaiter(this, void 0, void 0, function () {\n                var release, ticket;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            release = function () { return undefined; };\n                            _a.label = 1;\n                        case 1:\n                            _a.trys.push([1, , 7, 8]);\n                            return [4 /*yield*/, this.acquire()];\n                        case 2:\n                            ticket = _a.sent();\n                            if (!Array.isArray(ticket)) return [3 /*break*/, 4];\n                            release = ticket[1];\n                            return [4 /*yield*/, callback(ticket[0])];\n                        case 3: return [2 /*return*/, _a.sent()];\n                        case 4:\n                            release = ticket;\n                            return [4 /*yield*/, callback()];\n                        case 5: return [2 /*return*/, _a.sent()];\n                        case 6: return [3 /*break*/, 8];\n                        case 7:\n                            release();\n                            return [7 /*endfinally*/];\n                        case 8: return [2 /*return*/];\n                    }\n                });\n            });\n        },\n        release: function () {\n            sync.release();\n        },\n        isLocked: function () { return sync.isLocked(); },\n    };\n}\n","export { default as Mutex } from './Mutex';\nexport { default as Semaphore } from './Semaphore';\nexport { withTimeout } from './withTimeout';\n","'use strict';\n\nconst processFn = (fn, options, proxy, unwrapped) => function (...arguments_) {\n\tconst P = options.promiseModule;\n\n\treturn new P((resolve, reject) => {\n\t\tif (options.multiArgs) {\n\t\t\targuments_.push((...result) => {\n\t\t\t\tif (options.errorFirst) {\n\t\t\t\t\tif (result[0]) {\n\t\t\t\t\t\treject(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.shift();\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (options.errorFirst) {\n\t\t\targuments_.push((error, result) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\targuments_.push(resolve);\n\t\t}\n\n\t\tconst self = this === proxy ? unwrapped : this;\n\t\tReflect.apply(fn, self, arguments_);\n\t});\n};\n\nconst filterCache = new WeakMap();\n\nmodule.exports = (input, options) => {\n\toptions = {\n\t\texclude: [/.+(?:Sync|Stream)$/],\n\t\terrorFirst: true,\n\t\tpromiseModule: Promise,\n\t\t...options\n\t};\n\n\tconst objectType = typeof input;\n\tif (!(input !== null && (objectType === 'object' || objectType === 'function'))) {\n\t\tthrow new TypeError(`Expected \\`input\\` to be a \\`Function\\` or \\`Object\\`, got \\`${input === null ? 'null' : objectType}\\``);\n\t}\n\n\tconst filter = (target, key) => {\n\t\tlet cached = filterCache.get(target);\n\n\t\tif (!cached) {\n\t\t\tcached = {};\n\t\t\tfilterCache.set(target, cached);\n\t\t}\n\n\t\tif (key in cached) {\n\t\t\treturn cached[key];\n\t\t}\n\n\t\tconst match = pattern => (typeof pattern === 'string' || typeof key === 'symbol') ? key === pattern : pattern.test(key);\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(target, key);\n\t\tconst writableOrConfigurableOwn = (desc === undefined || desc.writable || desc.configurable);\n\t\tconst included = options.include ? options.include.some(match) : !options.exclude.some(match);\n\t\tconst shouldFilter = included && writableOrConfigurableOwn;\n\t\tcached[key] = shouldFilter;\n\t\treturn shouldFilter;\n\t};\n\n\tconst cache = new WeakMap();\n\n\tconst proxy = new Proxy(input, {\n\t\tapply(target, thisArg, args) {\n\t\t\tconst cached = cache.get(target);\n\n\t\t\tif (cached) {\n\t\t\t\treturn Reflect.apply(cached, thisArg, args);\n\t\t\t}\n\n\t\t\tconst pified = options.excludeMain ? target : processFn(target, options, proxy, target);\n\t\t\tcache.set(target, pified);\n\t\t\treturn Reflect.apply(pified, thisArg, args);\n\t\t},\n\n\t\tget(target, key) {\n\t\t\tconst property = target[key];\n\n\t\t\t// eslint-disable-next-line no-use-extend-native/no-use-extend-native\n\t\t\tif (!filter(target, key) || property === Function.prototype[key]) {\n\t\t\t\treturn property;\n\t\t\t}\n\n\t\t\tconst cached = cache.get(property);\n\n\t\t\tif (cached) {\n\t\t\t\treturn cached;\n\t\t\t}\n\n\t\t\tif (typeof property === 'function') {\n\t\t\t\tconst pified = processFn(property, options, proxy, target);\n\t\t\t\tcache.set(property, pified);\n\t\t\t\treturn pified;\n\t\t\t}\n\n\t\t\treturn property;\n\t\t}\n\t});\n\n\treturn proxy;\n};\n","const SafeEventEmitter = require('@metamask/safe-event-emitter').default\n\nclass BaseFilter extends SafeEventEmitter {\n\n  constructor () {\n    super()\n    this.updates = []\n  }\n\n  async initialize () {}\n\n  async update () {\n    throw new Error('BaseFilter - no update method specified')\n  }\n\n  addResults (newResults) {\n    this.updates = this.updates.concat(newResults)\n    newResults.forEach(result => this.emit('update', result))\n  }\n\n  addInitialResults (newResults) {}\n\n  getChangesAndClear () {\n    const updates = this.updates\n    this.updates = []\n    return updates\n  }\n  \n}\n\nmodule.exports = BaseFilter\n","const BaseFilter = require('./base-filter')\n\n// tracks all results ever recorded\nclass BaseFilterWithHistory extends BaseFilter {\n\n  constructor () {\n    super()\n    this.allResults = []\n  }\n\n  async update () {\n    throw new Error('BaseFilterWithHistory - no update method specified')\n  }\n\n  addResults (newResults) {\n    this.allResults = this.allResults.concat(newResults)\n    super.addResults(newResults)\n  }\n\n  addInitialResults (newResults) {\n    this.allResults = this.allResults.concat(newResults)\n    super.addInitialResults(newResults)\n  }\n\n  getAllResults () {\n    return this.allResults\n  }\n\n}\n\nmodule.exports = BaseFilterWithHistory","\nmodule.exports = {\n  minBlockRef,\n  maxBlockRef,\n  sortBlockRefs,\n  bnToHex,\n  blockRefIsNumber,\n  hexToInt,\n  incrementHexInt,\n  intToHex,\n  unsafeRandomBytes,\n}\n\nfunction minBlockRef(...refs) {\n  const sortedRefs = sortBlockRefs(refs)\n  return sortedRefs[0]\n}\n\nfunction maxBlockRef(...refs) {\n  const sortedRefs = sortBlockRefs(refs)\n  return sortedRefs[sortedRefs.length-1]\n}\n\nfunction sortBlockRefs(refs) {\n  return refs.sort((refA, refB) => {\n    if (refA === 'latest' || refB === 'earliest') return 1\n    if (refB === 'latest' || refA === 'earliest') return -1\n    return hexToInt(refA) - hexToInt(refB)\n  })\n}\n\nfunction bnToHex(bn) {\n  return '0x' + bn.toString(16)\n}\n\nfunction blockRefIsNumber(blockRef){\n  return blockRef && !['earliest', 'latest', 'pending'].includes(blockRef)\n}\n\nfunction hexToInt(hexString) {\n  if (hexString === undefined || hexString === null) return hexString\n  return Number.parseInt(hexString, 16)\n}\n\nfunction incrementHexInt(hexString){\n  if (hexString === undefined || hexString === null) return hexString\n  const value = hexToInt(hexString)\n  return intToHex(value + 1)\n}\n\nfunction intToHex(int) {\n  if (int === undefined || int === null) return int\n  let hexString = int.toString(16)\n  const needsLeftPad = hexString.length % 2\n  if (needsLeftPad) hexString = '0' + hexString\n  return '0x' + hexString\n}\n\nfunction unsafeRandomBytes(byteCount) {\n  let result = '0x'\n  for (let i = 0; i < byteCount; i++) {\n    result += unsafeRandomNibble()\n    result += unsafeRandomNibble()\n  }\n  return result\n}\n\nfunction unsafeRandomNibble() {\n  return Math.floor(Math.random() * 16).toString(16)\n}\n","const EthQuery = require('eth-query')\nconst pify = require('pify')\nconst BaseFilterWithHistory = require('./base-filter-history')\nconst { bnToHex, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require('./hexUtils')\n\nclass LogFilter extends BaseFilterWithHistory {\n\n  constructor ({ provider, params }) {\n    super()\n    this.type = 'log'\n    this.ethQuery = new EthQuery(provider)\n    this.params = Object.assign({\n      fromBlock: 'latest',\n      toBlock: 'latest',\n      address: undefined,\n      topics: [],\n    }, params)\n    // normalize address parameter\n    if (this.params.address) {\n      // ensure array\n      if (!Array.isArray(this.params.address)) {\n        this.params.address = [this.params.address]\n      }\n      // ensure lowercase\n      this.params.address = this.params.address.map(address => address.toLowerCase())\n    }\n  }\n\n  async initialize({ currentBlock }) {\n    // resolve params.fromBlock\n    let fromBlock = this.params.fromBlock\n    if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock\n    if ('earliest' === fromBlock) fromBlock = '0x0'\n    this.params.fromBlock = fromBlock\n    // set toBlock for initial lookup\n    const toBlock = minBlockRef(this.params.toBlock, currentBlock)\n    const params = Object.assign({}, this.params, { toBlock })\n    // fetch logs and add to results\n    const newLogs = await this._fetchLogs(params)\n    this.addInitialResults(newLogs)\n  }\n\n  async update ({ oldBlock, newBlock }) {\n    // configure params for this update\n    const toBlock = newBlock\n    let fromBlock\n    // oldBlock is empty on first sync\n    if (oldBlock) {\n      fromBlock = incrementHexInt(oldBlock)\n    } else {\n      fromBlock = newBlock\n    }\n    // fetch logs\n    const params = Object.assign({}, this.params, { fromBlock, toBlock })\n    const newLogs = await this._fetchLogs(params)\n    const matchingLogs = newLogs.filter(log => this.matchLog(log))\n\n    // add to results\n    this.addResults(matchingLogs)\n  }\n\n  async _fetchLogs (params) {\n    const newLogs = await pify(cb => this.ethQuery.getLogs(params, cb))()\n    // add to results\n    return newLogs\n  }\n\n  matchLog(log) {\n    // check if block number in bounds:\n    if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber)) return false\n    if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber)) return false\n\n    // address is correct:\n    const normalizedLogAddress = log.address && log.address.toLowerCase()\n    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false\n\n    // topics match:\n    // topics are position-dependant\n    // topics can be nested to represent `or` [[a || b], c]\n    // topics can be null, representing a wild card for that position\n    const topicsMatch = this.params.topics.every((topicPattern, index) => {\n      // pattern is longer than actual topics\n      let logTopic = log.topics[index]\n      if (!logTopic) return false\n      logTopic = logTopic.toLowerCase()\n      // normalize subTopics\n      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern]\n      // check for wild card\n      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null)\n      if (subtopicsIncludeWildcard) return true\n      subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase())\n      // check each possible matching topic\n      const topicDoesMatch = subtopicsToMatch.includes(logTopic)\n      return topicDoesMatch\n    })\n\n    return topicsMatch\n  }\n\n}\n\nmodule.exports = LogFilter\n","module.exports = getBlocksForRange\n\nasync function getBlocksForRange({ provider, fromBlock, toBlock }) {\n  if (!fromBlock) fromBlock = toBlock\n\n  const fromBlockNumber = hexToInt(fromBlock)\n  const toBlockNumber = hexToInt(toBlock)\n  const blockCountToQuery = toBlockNumber - fromBlockNumber + 1\n  // load all blocks from old to new (inclusive)\n  const missingBlockNumbers = Array(blockCountToQuery).fill()\n                              .map((_,index) => fromBlockNumber + index)\n                              .map(intToHex)\n  const blockBodies = await Promise.all(\n    missingBlockNumbers.map(blockNum => query(provider, 'eth_getBlockByNumber', [blockNum, false]))\n  )\n  return blockBodies\n}\n\nfunction hexToInt(hexString) {\n  if (hexString === undefined || hexString === null) return hexString\n  return Number.parseInt(hexString, 16)\n}\n\nfunction incrementHexInt(hexString){\n  if (hexString === undefined || hexString === null) return hexString\n  const value = hexToInt(hexString)\n  return intToHex(value + 1)\n}\n\nfunction intToHex(int) {\n  if (int === undefined || int === null) return int\n  const hexString = int.toString(16)\n  return '0x' + hexString\n}\n\nfunction query(provider, method, params) {\n  return new Promise((resolve, reject) => {\n    provider.sendAsync({ id: 1, jsonrpc: '2.0', method, params }, (err, res) => {\n      if (err) return reject(err)\n      resolve(res.result)\n    })\n  })\n}\n","const BaseFilter = require('./base-filter')\nconst getBlocksForRange = require('./getBlocksForRange')\nconst { incrementHexInt } = require('./hexUtils')\n\nclass BlockFilter extends BaseFilter {\n\n  constructor ({ provider, params }) {\n    super()\n    this.type = 'block'\n    this.provider = provider\n  }\n\n  async update ({ oldBlock, newBlock }) {\n    const toBlock = newBlock\n    const fromBlock = incrementHexInt(oldBlock)\n    const blockBodies = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock })\n    const blockHashes = blockBodies.map((block) => block.hash)\n    this.addResults(blockHashes)\n  }\n\n}\n\nmodule.exports = BlockFilter\n","const BaseFilter = require('./base-filter')\nconst getBlocksForRange = require('./getBlocksForRange')\nconst { incrementHexInt } = require('./hexUtils')\n\nclass TxFilter extends BaseFilter {\n\n  constructor ({ provider }) {\n    super()\n    this.type = 'tx'\n    this.provider = provider\n  }\n\n  async update ({ oldBlock }) {\n    const toBlock = oldBlock\n    const fromBlock = incrementHexInt(oldBlock)\n    const blocks = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock })\n    const blockTxHashes = []\n    for (const block of blocks) {\n      blockTxHashes.push(...block.transactions)\n    }\n    // add to results\n    this.addResults(blockTxHashes)\n  }\n\n}\n\nmodule.exports = TxFilter\n","const Mutex = require('async-mutex').Mutex\nconst { createAsyncMiddleware } = require('json-rpc-engine')\nconst createJsonRpcMiddleware = require('eth-json-rpc-middleware/scaffold')\nconst LogFilter = require('./log-filter.js')\nconst BlockFilter = require('./block-filter.js')\nconst TxFilter = require('./tx-filter.js')\nconst { intToHex, hexToInt } = require('./hexUtils')\n\nmodule.exports = createEthFilterMiddleware\n\nfunction createEthFilterMiddleware({ blockTracker, provider }) {\n\n  // create filter collection\n  let filterIndex = 0\n  let filters = {}\n  // create update mutex\n  const mutex = new Mutex()\n  const waitForFree = mutexMiddlewareWrapper({ mutex })\n\n  const middleware = createJsonRpcMiddleware({\n    // install filters\n    eth_newFilter:                   waitForFree(toFilterCreationMiddleware(newLogFilter)),\n    eth_newBlockFilter:              waitForFree(toFilterCreationMiddleware(newBlockFilter)),\n    eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),\n    // uninstall filters\n    eth_uninstallFilter:             waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),\n    // checking filter changes\n    eth_getFilterChanges:            waitForFree(toAsyncRpcMiddleware(getFilterChanges)),\n    eth_getFilterLogs:               waitForFree(toAsyncRpcMiddleware(getFilterLogs)),\n  })\n\n  // setup filter updating and destroy handler\n  const filterUpdater = async ({ oldBlock, newBlock }) => {\n    if (filters.length === 0) return\n    // lock update reads\n    const releaseLock = await mutex.acquire()\n    try {\n      // process all filters in parallel\n      await Promise.all(objValues(filters).map(async (filter) => {\n        try {\n         await filter.update({ oldBlock, newBlock })\n        } catch (err) {\n          // handle each error individually so filter update errors don't affect other filters\n          console.error(err)\n        }\n      }))\n    } catch (err) {\n      // log error so we don't skip the releaseLock\n      console.error(err)\n    }\n    // unlock update reads\n    releaseLock()\n  }\n\n  // expose filter methods directly\n  middleware.newLogFilter = newLogFilter\n  middleware.newBlockFilter = newBlockFilter\n  middleware.newPendingTransactionFilter = newPendingTransactionFilter\n  middleware.uninstallFilter = uninstallFilterHandler\n  middleware.getFilterChanges = getFilterChanges\n  middleware.getFilterLogs = getFilterLogs\n\n  // expose destroy method for cleanup\n  middleware.destroy = () => {\n    uninstallAllFilters()\n  }\n\n  return middleware\n\n  //\n  // new filters\n  //\n\n  async function newLogFilter(params) {\n    const filter = new LogFilter({ provider, params })\n    const filterIndex = await installFilter(filter)\n    return filter\n  }\n\n  async function newBlockFilter() {\n    const filter = new BlockFilter({ provider })\n    const filterIndex = await installFilter(filter)\n    return filter\n  }\n\n  async function newPendingTransactionFilter() {\n    const filter = new TxFilter({ provider })\n    const filterIndex = await installFilter(filter)\n    return filter\n  }\n\n  //\n  // get filter changes\n  //\n\n  async function getFilterChanges(filterIndexHex) {\n    const filterIndex = hexToInt(filterIndexHex)\n    const filter = filters[filterIndex]\n    if (!filter) {\n      throw new Error(`No filter for index \"${filterIndex}\"`)\n    }\n    const results = filter.getChangesAndClear()\n    return results\n  }\n\n  async function getFilterLogs(filterIndexHex) {\n    const filterIndex = hexToInt(filterIndexHex)\n    const filter = filters[filterIndex]\n    if (!filter) {\n      throw new Error(`No filter for index \"${filterIndex}\"`)\n    }\n    // only return results for log filters\n    if (filter.type === 'log') {\n      results = filter.getAllResults()\n    } else {\n      results = []\n    }\n    return results\n  }\n\n\n  //\n  // remove filters\n  //\n\n\n  async function uninstallFilterHandler(filterIndexHex) {\n    // check filter exists\n    const filterIndex = hexToInt(filterIndexHex)\n    const filter = filters[filterIndex]\n    const result = Boolean(filter)\n    // uninstall filter\n    if (result) {\n      await uninstallFilter(filterIndex)\n    }\n    return result\n  }\n\n  //\n  // utils\n  //\n\n  async function installFilter(filter) {\n    const prevFilterCount = objValues(filters).length\n    // install filter\n    const currentBlock = await blockTracker.getLatestBlock()\n    await filter.initialize({ currentBlock })\n    filterIndex++\n    filters[filterIndex] = filter\n    filter.id = filterIndex\n    filter.idHex = intToHex(filterIndex)\n    // update block tracker subs\n    const newFilterCount = objValues(filters).length\n    updateBlockTrackerSubs({ prevFilterCount, newFilterCount })\n    return filterIndex\n  }\n\n  async function uninstallFilter(filterIndex) {\n    const prevFilterCount = objValues(filters).length\n    delete filters[filterIndex]\n    // update block tracker subs\n    const newFilterCount = objValues(filters).length\n    updateBlockTrackerSubs({ prevFilterCount, newFilterCount })\n  }\n\n  async function uninstallAllFilters() {\n    const prevFilterCount = objValues(filters).length\n    filters = {}\n    // update block tracker subs\n    updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 })\n  }\n\n  function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {\n    // subscribe\n    if (prevFilterCount === 0 && newFilterCount > 0) {\n      blockTracker.on('sync', filterUpdater)\n      return\n    }\n    // unsubscribe\n    if (prevFilterCount > 0 && newFilterCount === 0) {\n      blockTracker.removeListener('sync', filterUpdater)\n      return\n    }\n  }\n\n}\n\n// helper for turning filter constructors into rpc middleware\nfunction toFilterCreationMiddleware(createFilterFn) {\n  return toAsyncRpcMiddleware(async (...args) => {\n    const filter = await createFilterFn(...args)\n    const result = intToHex(filter.id)\n    return result\n  })\n}\n\n// helper for pulling out req.params and setting res.result\nfunction toAsyncRpcMiddleware(asyncFn) {\n  return createAsyncMiddleware(async (req, res) => {\n    const result = await asyncFn.apply(null, req.params)\n    res.result = result\n  })\n}\n\nfunction mutexMiddlewareWrapper({ mutex }) {\n  return (middleware) => {\n    return async (req, res, next, end) => {\n      // wait for mutex available\n      // we can release immediately because\n      // we just need to make sure updates aren't active\n      const releaseLock = await mutex.acquire()\n      releaseLock()\n      middleware(req, res, next, end)\n    }\n  }\n}\n\nfunction objValues(obj, fn){\n  const values = []\n  for (let key in obj) {\n    values.push(obj[key])\n  }\n  return values\n}\n","const SafeEventEmitter = require('@metamask/safe-event-emitter').default\nconst createScaffoldMiddleware = require('eth-json-rpc-middleware/scaffold')\nconst { createAsyncMiddleware } = require('json-rpc-engine')\nconst createFilterMiddleware = require('./index.js')\nconst { unsafeRandomBytes, incrementHexInt } = require('./hexUtils.js')\nconst getBlocksForRange = require('./getBlocksForRange.js')\n\nmodule.exports = createSubscriptionMiddleware\n\n\nfunction createSubscriptionMiddleware({ blockTracker, provider }) {\n  // state and utilities for handling subscriptions\n  const subscriptions = {}\n  const filterManager = createFilterMiddleware({ blockTracker, provider })\n\n  // internal flag\n  let isDestroyed = false\n\n  // create subscriptionManager api object\n  const events = new SafeEventEmitter()\n  const middleware = createScaffoldMiddleware({\n    eth_subscribe: createAsyncMiddleware(subscribe),\n    eth_unsubscribe: createAsyncMiddleware(unsubscribe),\n  })\n  middleware.destroy = destroy\n  return { events, middleware }\n\n  async function subscribe(req, res) {\n\n    if (isDestroyed) throw new Error(\n      'SubscriptionManager - attempting to use after destroying'\n    )\n\n    const subscriptionType = req.params[0]\n    // subId is 16 byte hex string\n    const subId = unsafeRandomBytes(16)\n\n    // create sub\n    let sub\n    switch (subscriptionType) {\n      case 'newHeads':\n        sub = createSubNewHeads({ subId })\n        break\n      case 'logs':\n        const filterParams = req.params[1]\n        const filter = await filterManager.newLogFilter(filterParams)\n        sub = createSubFromFilter({ subId, filter })\n        break\n      default:\n        throw new Error(`SubscriptionManager - unsupported subscription type \"${subscriptionType}\"`)\n\n    }\n    subscriptions[subId] = sub\n\n    res.result = subId\n    return\n\n    function createSubNewHeads({ subId }) {\n      const sub = {\n        type: subscriptionType,\n        destroy: async () => {\n          blockTracker.removeListener('sync', sub.update)\n        },\n        update: async ({ oldBlock, newBlock }) => {\n          // for newHeads\n          const toBlock = newBlock\n          const fromBlock = incrementHexInt(oldBlock)\n          const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock })\n          const results = rawBlocks.map(normalizeBlock)\n          results.forEach((value) => {\n            _emitSubscriptionResult(subId, value)\n          })\n        }\n      }\n      // check for subscription updates on new block\n      blockTracker.on('sync', sub.update)\n      return sub\n    }\n\n    function createSubFromFilter({ subId, filter }){\n      filter.on('update', result => _emitSubscriptionResult(subId, result))\n      const sub = {\n        type: subscriptionType,\n        destroy: async () => {\n          return await filterManager.uninstallFilter(filter.idHex)\n        },\n      }\n      return sub\n    }\n  }\n\n  async function unsubscribe(req, res) {\n\n    if (isDestroyed) throw new Error(\n      'SubscriptionManager - attempting to use after destroying'\n    )\n\n    const id = req.params[0]\n    const subscription = subscriptions[id]\n    // if missing, return \"false\" to indicate it was not removed\n    if (!subscription) {\n      res.result = false\n      return\n    }\n    // cleanup subscription\n    delete subscriptions[id]\n    await subscription.destroy()\n    res.result = true\n  }\n\n  function _emitSubscriptionResult(filterIdHex, value) {\n    events.emit('notification', {\n      jsonrpc: '2.0',\n      method: 'eth_subscription',\n      params: {\n        subscription: filterIdHex,\n        result: value,\n      },\n    })\n  }\n\n  function destroy () {\n    events.removeAllListeners()\n    for (const id in subscriptions) {\n      subscriptions[id].destroy()\n      delete subscriptions[id]\n    }\n    isDestroyed = true\n  }\n}\n\nfunction normalizeBlock(block) {\n  return {\n    hash: block.hash,\n    parentHash: block.parentHash,\n    sha3Uncles: block.sha3Uncles,\n    miner: block.miner,\n    stateRoot: block.stateRoot,\n    transactionsRoot: block.transactionsRoot,\n    receiptsRoot: block.receiptsRoot,\n    logsBloom: block.logsBloom,\n    difficulty: block.difficulty,\n    number: block.number,\n    gasLimit: block.gasLimit,\n    gasUsed: block.gasUsed,\n    nonce: block.nonce,\n    mixHash: block.mixHash,\n    timestamp: block.timestamp,\n    extraData: block.extraData,\n  }\n}\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nexports.default = {};\nmodule.exports = exports[\"default\"];","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = once;\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nmodule.exports = exports['default'];","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar ar€€